{"version":3,"sources":["../../../src/modules/admin/admin.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    NotFoundException,\r\n    BadRequestException,\r\n} from '@nestjs/common';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport {\r\n    UserStatus,\r\n    UserRole,\r\n    JobStatus,\r\n    HRApprovalStatus,\r\n    RefundStatus,\r\n    PaymentStatus,\r\n    AuditAction,\r\n} from '../../common/constants';\r\n\r\n@Injectable()\r\nexport class AdminService {\r\n    constructor(private prisma: PrismaService) { }\r\n\r\n    // ===========================================\r\n    // DASHBOARD\r\n    // ===========================================\r\n\r\n    async getDashboardMetrics() {\r\n        const [\r\n            totalUsers,\r\n            totalCandidates,\r\n            totalHRs,\r\n            totalEmployees,\r\n            totalJobs,\r\n            activeJobs,\r\n            totalPayments,\r\n            totalRevenue,\r\n            pendingRefunds,\r\n            todayApplications,\r\n        ] = await Promise.all([\r\n            this.prisma.user.count(),\r\n            this.prisma.user.count({ where: { role: UserRole.CANDIDATE } }),\r\n            this.prisma.user.count({ where: { role: UserRole.HR } }),\r\n            this.prisma.user.count({ where: { role: UserRole.EMPLOYEE } }),\r\n            this.prisma.job.count(),\r\n            this.prisma.job.count({ where: { status: JobStatus.ACTIVE } }),\r\n            this.prisma.payment.count({ where: { status: PaymentStatus.SUCCESS } }),\r\n            this.prisma.payment.aggregate({\r\n                where: { status: PaymentStatus.SUCCESS },\r\n                _sum: { amount: true },\r\n            }),\r\n            this.prisma.refund.count({ where: { status: RefundStatus.REQUESTED } }),\r\n            this.prisma.jobApplication.count({\r\n                where: {\r\n                    createdAt: { gte: new Date(new Date().setHours(0, 0, 0, 0)) },\r\n                },\r\n            }),\r\n        ]);\r\n\r\n        return {\r\n            users: {\r\n                total: totalUsers,\r\n                candidates: totalCandidates,\r\n                hrs: totalHRs,\r\n                employees: totalEmployees,\r\n            },\r\n            jobs: {\r\n                total: totalJobs,\r\n                active: activeJobs,\r\n            },\r\n            revenue: {\r\n                totalPayments,\r\n                totalAmount: totalRevenue._sum.amount || 0,\r\n                pendingRefunds,\r\n            },\r\n            activity: {\r\n                todayApplications,\r\n            },\r\n        };\r\n    }\r\n\r\n    // ===========================================\r\n    // USER MANAGEMENT\r\n    // ===========================================\r\n\r\n    async getAllUsers(page = 1, limit = 20, role?: UserRole, status?: UserStatus) {\r\n        const where: any = {};\r\n        if (role) where.role = role;\r\n        if (status) where.status = status;\r\n\r\n        const skip = (page - 1) * limit;\r\n\r\n        const [users, total] = await Promise.all([\r\n            this.prisma.user.findMany({\r\n                where,\r\n                skip,\r\n                take: limit,\r\n                include: {\r\n                    Candidate: { select: { firstName: true, lastName: true } },\r\n                    HR: { select: { companyName: true, approvalStatus: true } },\r\n                    Employee: { select: { companyName: true, referralCount: true } },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n            }),\r\n            this.prisma.user.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            data: users,\r\n            meta: { page, limit, total, totalPages: Math.ceil(total / limit) },\r\n        };\r\n    }\r\n\r\n    async blockUser(userId: string, adminId: string) {\r\n        const user = await this.prisma.user.findUnique({ where: { id: userId } });\r\n        if (!user) throw new NotFoundException('User not found');\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: userId },\r\n                data: { status: UserStatus.BLOCKED },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'User',\r\n                    entityId: userId,\r\n                    metadata: { action: 'block' },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: 'User blocked' };\r\n    }\r\n\r\n    async unblockUser(userId: string, adminId: string) {\r\n        const user = await this.prisma.user.findUnique({ where: { id: userId } });\r\n        if (!user) throw new NotFoundException('User not found');\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: userId },\r\n                data: { status: UserStatus.ACTIVE },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'User',\r\n                    entityId: userId,\r\n                    metadata: { action: 'unblock' },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: 'User unblocked' };\r\n    }\r\n\r\n    // ===========================================\r\n    // HR APPROVAL\r\n    // ===========================================\r\n\r\n    async getPendingHRApprovals() {\r\n        return this.prisma.hR.findMany({\r\n            where: { approvalStatus: HRApprovalStatus.PENDING },\r\n            include: {\r\n                User: { select: { email: true, createdAt: true } },\r\n            },\r\n            orderBy: { createdAt: 'asc' },\r\n        });\r\n    }\r\n\r\n    async approveHR(hrId: string, adminId: string) {\r\n        const hr = await this.prisma.hR.findUnique({ where: { id: hrId } });\r\n        if (!hr) throw new NotFoundException('HR not found');\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.hR.update({\r\n                where: { id: hrId },\r\n                data: {\r\n                    approvalStatus: HRApprovalStatus.APPROVED,\r\n                    approvedBy: adminId,\r\n                    approvedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            await tx.user.update({\r\n                where: { id: hr.userId },\r\n                data: { status: UserStatus.ACTIVE },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'HR',\r\n                    entityId: hrId,\r\n                    metadata: { action: 'approve' },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: 'HR approved' };\r\n    }\r\n\r\n    async rejectHR(hrId: string, adminId: string, reason: string) {\r\n        const hr = await this.prisma.hR.findUnique({ where: { id: hrId } });\r\n        if (!hr) throw new NotFoundException('HR not found');\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.hR.update({\r\n                where: { id: hrId },\r\n                data: {\r\n                    approvalStatus: HRApprovalStatus.REJECTED,\r\n                    rejectionReason: reason,\r\n                },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'HR',\r\n                    entityId: hrId,\r\n                    metadata: { action: 'reject', reason },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: 'HR rejected' };\r\n    }\r\n\r\n    // ===========================================\r\n    // JOB MANAGEMENT\r\n    // ===========================================\r\n\r\n    async getAllJobs(page = 1, limit = 20, status?: JobStatus) {\r\n        const where: any = {};\r\n        if (status) where.status = status;\r\n\r\n        const skip = (page - 1) * limit;\r\n\r\n        const [jobs, total] = await Promise.all([\r\n            this.prisma.job.findMany({\r\n                where,\r\n                skip,\r\n                take: limit,\r\n                include: {\r\n                    HR: { select: { companyName: true } },\r\n                    _count: { select: { JobApplication: true } },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n            }),\r\n            this.prisma.job.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            data: jobs,\r\n            meta: { page, limit, total, totalPages: Math.ceil(total / limit) },\r\n        };\r\n    }\r\n\r\n    async approveJob(jobId: string, adminId: string) {\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.job.update({\r\n                where: { id: jobId },\r\n                data: {\r\n                    status: JobStatus.ACTIVE,\r\n                    postedAt: new Date(),\r\n                    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\r\n                },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'Job',\r\n                    entityId: jobId,\r\n                    metadata: { action: 'approve' },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: 'Job approved' };\r\n    }\r\n\r\n    async expireJob(jobId: string, adminId: string) {\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.job.update({\r\n                where: { id: jobId },\r\n                data: { status: JobStatus.EXPIRED },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'Job',\r\n                    entityId: jobId,\r\n                    metadata: { action: 'expire' },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: 'Job expired' };\r\n    }\r\n\r\n    async createJob(jobData: any, adminId: string) {\r\n        // Generate slug from title\r\n        const baseSlug = (jobData.title || 'job')\r\n            .toLowerCase()\r\n            .replace(/[^a-z0-9]+/g, '-')\r\n            .replace(/^-|-$/g, '');\r\n        const randomSuffix = Math.random().toString(36).substring(2, 8);\r\n        const slug = `${baseSlug}-${randomSuffix}`;\r\n\r\n        const newJob = await this.prisma.job.create({\r\n            data: {\r\n                slug,\r\n                title: jobData.title,\r\n                description: jobData.description || '',\r\n                companyName: jobData.companyName,\r\n                location: jobData.location,\r\n                salaryMin: jobData.salaryMin,\r\n                salaryMax: jobData.salaryMax,\r\n                experienceMin: jobData.experienceMin || 0,\r\n                experienceMax: jobData.experienceMax,\r\n                referralFee: jobData.referralFee || 499,\r\n                status: JobStatus.ACTIVE,\r\n                postedAt: new Date(),\r\n                expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\r\n                // hrId is optional for admin-created jobs\r\n            },\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.ADMIN_OVERRIDE,\r\n                entityType: 'Job',\r\n                entityId: newJob.id,\r\n                metadata: { action: 'create', jobData },\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Job created successfully', data: newJob };\r\n    }\r\n\r\n    async updateJob(jobId: string, jobData: any, adminId: string) {\r\n        const job = await this.prisma.job.findUnique({ where: { id: jobId } });\r\n        if (!job) throw new NotFoundException('Job not found');\r\n\r\n        const updatedJob = await this.prisma.job.update({\r\n            where: { id: jobId },\r\n            data: jobData,\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.ADMIN_OVERRIDE,\r\n                entityType: 'Job',\r\n                entityId: jobId,\r\n                metadata: { action: 'update', changes: jobData },\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Job updated successfully', data: updatedJob };\r\n    }\r\n\r\n    async deleteJob(jobId: string, adminId: string) {\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            include: { _count: { select: { JobApplication: true } } },\r\n        });\r\n\r\n        if (!job) throw new NotFoundException('Job not found');\r\n\r\n        // Check if there are applications\r\n        if (job._count.JobApplication > 0) {\r\n            throw new BadRequestException(\r\n                `Cannot delete job with ${job._count.JobApplication} applications. Please expire the job instead.`\r\n            );\r\n        }\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.job.delete({ where: { id: jobId } });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'Job',\r\n                    entityId: jobId,\r\n                    metadata: { action: 'delete', jobTitle: job.title },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: 'Job deleted successfully' };\r\n    }\r\n\r\n    // ===========================================\r\n    // CANDIDATE MANAGEMENT\r\n    // ===========================================\r\n\r\n    async getAllCandidates(page = 1, limit = 20, search?: string) {\r\n        const where: any = { role: UserRole.CANDIDATE };\r\n\r\n        if (search) {\r\n            where.OR = [\r\n                { email: { contains: search, mode: 'insensitive' } },\r\n                { Candidate: { firstName: { contains: search, mode: 'insensitive' } } },\r\n                { Candidate: { lastName: { contains: search, mode: 'insensitive' } } },\r\n            ];\r\n        }\r\n\r\n        const skip = (page - 1) * limit;\r\n\r\n        const [candidates, total] = await Promise.all([\r\n            this.prisma.user.findMany({\r\n                where,\r\n                skip,\r\n                take: limit,\r\n                include: {\r\n                    Candidate: {\r\n                        include: {\r\n                            JobApplication: {\r\n                                include: {\r\n                                    Job: { select: { title: true, companyName: true } },\r\n                                },\r\n                                orderBy: { createdAt: 'desc' },\r\n                                take: 5,\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n            }),\r\n            this.prisma.user.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            data: candidates,\r\n            meta: { page, limit, total, totalPages: Math.ceil(total / limit) },\r\n        };\r\n    }\r\n\r\n    async deleteUser(userId: string, adminId: string) {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n            include: {\r\n                Candidate: { include: { _count: { select: { JobApplication: true } } } },\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!user) throw new NotFoundException('User not found');\r\n        if (user.role === UserRole.ADMIN) {\r\n            throw new BadRequestException('Cannot delete admin users');\r\n        }\r\n\r\n        // Check for active applications\r\n        if (user.Candidate && user.Candidate._count.JobApplication > 0) {\r\n            throw new BadRequestException(\r\n                'Cannot delete user with active applications. Please block the user instead.'\r\n            );\r\n        }\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            // Delete related data based on role\r\n            if (user.Candidate) {\r\n                await tx.candidate.delete({ where: { userId } });\r\n            }\r\n            if (user.HR) {\r\n                await tx.hR.delete({ where: { userId } });\r\n            }\r\n            if (user.Employee) {\r\n                await tx.employee.delete({ where: { userId } });\r\n            }\r\n\r\n            await tx.user.delete({ where: { id: userId } });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'User',\r\n                    entityId: userId,\r\n                    metadata: { action: 'delete', email: user.email, role: user.role },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: 'User deleted successfully' };\r\n    }\r\n\r\n    // ===========================================\r\n    // APPLICATION MANAGEMENT\r\n    // ===========================================\r\n\r\n    async getAllApplications(\r\n        page = 1,\r\n        limit = 20,\r\n        status?: string,\r\n        jobId?: string,\r\n        search?: string,\r\n    ) {\r\n        const where: any = {};\r\n\r\n        if (status) where.status = status;\r\n        if (jobId) where.jobId = jobId;\r\n\r\n        if (search) {\r\n            where.OR = [\r\n                { Candidate: { firstName: { contains: search, mode: 'insensitive' } } },\r\n                { Candidate: { lastName: { contains: search, mode: 'insensitive' } } },\r\n                { Job: { title: { contains: search, mode: 'insensitive' } } },\r\n                { Job: { companyName: { contains: search, mode: 'insensitive' } } },\r\n            ];\r\n        }\r\n\r\n        const skip = (page - 1) * limit;\r\n\r\n        const [applications, total] = await Promise.all([\r\n            this.prisma.jobApplication.findMany({\r\n                where,\r\n                skip,\r\n                take: limit,\r\n                include: {\r\n                    Candidate: {\r\n                        select: {\r\n                            id: true,\r\n                            firstName: true,\r\n                            lastName: true,\r\n                            headline: true,\r\n                            totalExperience: true,\r\n                        },\r\n                    },\r\n                    Job: {\r\n                        select: {\r\n                            id: true,\r\n                            title: true,\r\n                            companyName: true,\r\n                            status: true,\r\n                        },\r\n                    },\r\n                    Interview: {\r\n                        select: {\r\n                            id: true,\r\n                            status: true,\r\n                            paymentStatus: true,\r\n                            scheduledDate: true,\r\n                        },\r\n                    },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n            }),\r\n            this.prisma.jobApplication.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            data: applications,\r\n            meta: { page, limit, total, totalPages: Math.ceil(total / limit) },\r\n        };\r\n    }\r\n\r\n    async updateApplicationStatus(\r\n        applicationId: string,\r\n        newStatus: string,\r\n        adminId: string,\r\n        reason?: string,\r\n    ) {\r\n        const application = await this.prisma.jobApplication.findUnique({\r\n            where: { id: applicationId },\r\n        });\r\n\r\n        if (!application) throw new NotFoundException('Application not found');\r\n\r\n        const oldStatus = application.status;\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.jobApplication.update({\r\n                where: { id: applicationId },\r\n                data: { status: newStatus as any },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'JobApplication',\r\n                    entityId: applicationId,\r\n                    oldValue: { status: oldStatus },\r\n                    newValue: { status: newStatus },\r\n                    metadata: { action: 'status_override', reason },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: `Application status updated to ${newStatus}` };\r\n    }\r\n\r\n    // ===========================================\r\n    // PAYMENT & REFUND\r\n    // ===========================================\r\n\r\n    async getAllPayments(page = 1, limit = 20, status?: PaymentStatus) {\r\n        const where: any = {};\r\n        if (status) where.status = status;\r\n\r\n        const skip = (page - 1) * limit;\r\n\r\n        const [payments, total] = await Promise.all([\r\n            this.prisma.payment.findMany({\r\n                where,\r\n                skip,\r\n                take: limit,\r\n                include: {\r\n                    JobApplication: {\r\n                        include: {\r\n                            Candidate: { select: { firstName: true, lastName: true } },\r\n                            Job: { select: { title: true, companyName: true } },\r\n                        },\r\n                    },\r\n                    Refund: true,\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n            }),\r\n            this.prisma.payment.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            data: payments,\r\n            meta: { page, limit, total, totalPages: Math.ceil(total / limit) },\r\n        };\r\n    }\r\n\r\n    async getPendingRefunds() {\r\n        return this.prisma.refund.findMany({\r\n            where: { status: RefundStatus.REQUESTED },\r\n            include: {\r\n                Payment: {\r\n                    include: {\r\n                        JobApplication: {\r\n                            include: {\r\n                                Candidate: { select: { firstName: true, lastName: true } },\r\n                                Job: { select: { title: true, companyName: true } },\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n            orderBy: { createdAt: 'asc' },\r\n        });\r\n    }\r\n\r\n    async approveRefund(refundId: string, adminId: string, notes?: string) {\r\n        const refund = await this.prisma.refund.findUnique({\r\n            where: { id: refundId },\r\n            include: { Payment: true },\r\n        });\r\n\r\n        if (!refund) throw new NotFoundException('Refund not found');\r\n        if (refund.status !== RefundStatus.REQUESTED) {\r\n            throw new BadRequestException('Refund already processed');\r\n        }\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.refund.update({\r\n                where: { id: refundId },\r\n                data: {\r\n                    status: RefundStatus.APPROVED,\r\n                    processedBy: adminId,\r\n                    processedAt: new Date(),\r\n                    adminNotes: notes,\r\n                },\r\n            });\r\n\r\n            await tx.payment.update({\r\n                where: { id: refund.paymentId },\r\n                data: { status: PaymentStatus.REFUNDED },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.REFUND_PROCESSED,\r\n                    entityType: 'Refund',\r\n                    entityId: refundId,\r\n                    metadata: { action: 'approve', notes },\r\n                },\r\n            });\r\n        });\r\n\r\n        // TODO: Process actual Razorpay refund\r\n\r\n        return { success: true, message: 'Refund approved' };\r\n    }\r\n\r\n    async rejectRefund(refundId: string, adminId: string, reason: string) {\r\n        const refund = await this.prisma.refund.findUnique({\r\n            where: { id: refundId },\r\n        });\r\n\r\n        if (!refund) throw new NotFoundException('Refund not found');\r\n        if (refund.status !== RefundStatus.REQUESTED) {\r\n            throw new BadRequestException('Refund already processed');\r\n        }\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.refund.update({\r\n                where: { id: refundId },\r\n                data: {\r\n                    status: RefundStatus.REJECTED,\r\n                    processedBy: adminId,\r\n                    processedAt: new Date(),\r\n                    adminNotes: reason,\r\n                },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.REFUND_PROCESSED,\r\n                    entityType: 'Refund',\r\n                    entityId: refundId,\r\n                    metadata: { action: 'reject', reason },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: 'Refund rejected' };\r\n    }\r\n\r\n    // ===========================================\r\n    // AUDIT LOGS\r\n    // ===========================================\r\n\r\n    async getAuditLogs(page = 1, limit = 50, action?: AuditAction) {\r\n        const where: any = {};\r\n        if (action) where.action = action;\r\n\r\n        const skip = (page - 1) * limit;\r\n\r\n        const [logs, total] = await Promise.all([\r\n            this.prisma.auditLog.findMany({\r\n                where,\r\n                skip,\r\n                take: limit,\r\n                include: {\r\n                    User: { select: { email: true } },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n            }),\r\n            this.prisma.auditLog.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            data: logs,\r\n            meta: { page, limit, total, totalPages: Math.ceil(total / limit) },\r\n        };\r\n    }\r\n\r\n    // ===========================================\r\n    // INTERVIEW MANAGEMENT\r\n    // ===========================================\r\n\r\n    async getAllInterviews(page = 1, limit = 20, status?: string) {\r\n        const where: any = {};\r\n        if (status) where.status = status;\r\n\r\n        const skip = (page - 1) * limit;\r\n\r\n        const [interviews, total] = await Promise.all([\r\n            this.prisma.interview.findMany({\r\n                where,\r\n                skip,\r\n                take: limit,\r\n                include: {\r\n                    JobApplication: {\r\n                        include: {\r\n                            Candidate: { select: { firstName: true, lastName: true } },\r\n                            Job: { select: { title: true, companyName: true } },\r\n                        },\r\n                    },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n            }),\r\n            this.prisma.interview.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            data: interviews,\r\n            meta: { page, limit, total, totalPages: Math.ceil(total / limit) },\r\n        };\r\n    }\r\n\r\n    async getInterviewStats() {\r\n        const [\r\n            total,\r\n            interviewConfirmed,\r\n            paymentSuccess,\r\n            completed,\r\n            candidateNoShow,\r\n            hrNoShow,\r\n            cancelled,\r\n        ] = await Promise.all([\r\n            this.prisma.interview.count(),\r\n            this.prisma.interview.count({ where: { status: 'INTERVIEW_CONFIRMED' } }),\r\n            this.prisma.interview.count({ where: { status: 'PAYMENT_SUCCESS' } }),\r\n            this.prisma.interview.count({ where: { status: 'INTERVIEW_COMPLETED' } }),\r\n            this.prisma.interview.count({ where: { status: 'CANDIDATE_NO_SHOW' } }),\r\n            this.prisma.interview.count({ where: { status: 'HR_NO_SHOW' } }),\r\n            this.prisma.interview.count({ where: { status: 'CANCELLED' } }),\r\n        ]);\r\n\r\n        // Calculate no-show rate\r\n        const totalCompleted = completed + candidateNoShow + hrNoShow;\r\n        const noShowRate = totalCompleted > 0\r\n            ? (((candidateNoShow + hrNoShow) / totalCompleted) * 100).toFixed(2)\r\n            : '0.00';\r\n\r\n        return {\r\n            total,\r\n            byStatus: {\r\n                interviewConfirmed,\r\n                paymentSuccess,\r\n                completed,\r\n                candidateNoShow,\r\n                hrNoShow,\r\n                cancelled,\r\n            },\r\n            noShowRate: `${noShowRate}%`,\r\n            completionRate: total > 0\r\n                ? `${((completed / total) * 100).toFixed(2)}%`\r\n                : '0.00%',\r\n        };\r\n    }\r\n\r\n    async updateInterviewStatus(\r\n        interviewId: string,\r\n        newStatus: string,\r\n        adminId: string,\r\n        reason?: string,\r\n    ) {\r\n        const interview = await this.prisma.interview.findUnique({\r\n            where: { id: interviewId },\r\n        });\r\n\r\n        if (!interview) throw new NotFoundException('Interview not found');\r\n\r\n        const oldStatus = interview.status;\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            const updateData: any = { status: newStatus };\r\n\r\n            // Set appropriate timestamps based on new status\r\n            if (newStatus === 'INTERVIEW_COMPLETED') {\r\n                updateData.completedAt = new Date();\r\n            }\r\n\r\n            await tx.interview.update({\r\n                where: { id: interviewId },\r\n                data: updateData,\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'Interview',\r\n                    entityId: interviewId,\r\n                    oldValue: { status: oldStatus },\r\n                    newValue: { status: newStatus },\r\n                    metadata: { action: 'status_change', reason },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: `Interview status updated to ${newStatus}` };\r\n    }\r\n\r\n    async markInterviewCompleted(interviewId: string, adminId: string, notes?: string) {\r\n        return this.updateInterviewStatus(interviewId, 'INTERVIEW_COMPLETED', adminId, notes);\r\n    }\r\n\r\n    async markInterviewNoShow(\r\n        interviewId: string,\r\n        adminId: string,\r\n        noShowType: 'CANDIDATE' | 'HR',\r\n        notes?: string,\r\n    ) {\r\n        const interview = await this.prisma.interview.findUnique({\r\n            where: { id: interviewId },\r\n            include: {\r\n                application: {\r\n                    include: {\r\n                        Candidate: { select: { userId: true } },\r\n                        Job: { include: { HR: { select: { userId: true } } } },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!interview) throw new NotFoundException('Interview not found');\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            // Mark interview with appropriate no-show status\r\n            const noShowStatus = noShowType === 'CANDIDATE' ? 'CANDIDATE_NO_SHOW' : 'HR_NO_SHOW';\r\n            await tx.interview.update({\r\n                where: { id: interviewId },\r\n                data: { status: noShowStatus },\r\n            });\r\n\r\n            // Log the no-show with details\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'Interview',\r\n                    entityId: interviewId,\r\n                    metadata: {\r\n                        action: 'no_show',\r\n                        noShowType,\r\n                        notes,\r\n                        candidateId: interview.application?.candidateId || null,\r\n                        jobId: interview.application?.jobId || null,\r\n                    },\r\n                },\r\n            });\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            message: `Interview marked as no-show (${noShowType})`,\r\n        };\r\n    }\r\n\r\n    // ===========================================\r\n    // SKILL BUCKET MANAGEMENT\r\n    // ===========================================\r\n\r\n    async getAllSkillBuckets(includeInactive = false) {\r\n        return this.prisma.skillBucket.findMany({\r\n            where: includeInactive ? {} : { isActive: true },\r\n            include: {\r\n                Test: {\r\n                    select: {\r\n                        id: true,\r\n                        title: true,\r\n                        duration: true,\r\n                        totalQuestionBank: true,\r\n                    },\r\n                },\r\n                testTemplate: {\r\n                    select: {\r\n                        id: true,\r\n                        name: true,\r\n                        duration: true,\r\n                        passingCriteria: true,\r\n                    },\r\n                },\r\n                _count: {\r\n                    select: {\r\n                        jobs: true,\r\n                        attempts: true,\r\n                        jobRequirements: true,\r\n                    },\r\n                },\r\n            },\r\n            orderBy: { code: 'asc' },\r\n        });\r\n    }\r\n\r\n    async createSkillBucket(data: {\r\n        code: string;\r\n        name: string;\r\n        description?: string;\r\n        displayName?: string;\r\n        experienceMin?: number;\r\n        experienceMax?: number;\r\n        testId?: string;\r\n        testTemplateId?: string;\r\n    }, adminId: string) {\r\n        // Check if code already exists\r\n        const existing = await this.prisma.skillBucket.findUnique({\r\n            where: { code: data.code },\r\n        });\r\n\r\n        if (existing) {\r\n            throw new BadRequestException(`Skill bucket with code '${data.code}' already exists`);\r\n        }\r\n\r\n        const skillBucket = await this.prisma.skillBucket.create({\r\n            data: {\r\n                code: data.code,\r\n                name: data.name,\r\n                description: data.description,\r\n                displayName: data.displayName || `HR Shortlisting Check - ${data.name}`,\r\n                experienceMin: data.experienceMin ?? 0,\r\n                experienceMax: data.experienceMax ?? 3,\r\n                testId: data.testId,\r\n                testTemplateId: data.testTemplateId,\r\n            },\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.CREATE,\r\n                entityType: 'SkillBucket',\r\n                entityId: skillBucket.id,\r\n                newValue: data as any,\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Skill bucket created', data: skillBucket };\r\n    }\r\n\r\n    async updateSkillBucket(id: string, data: any, adminId: string) {\r\n        const existing = await this.prisma.skillBucket.findUnique({ where: { id } });\r\n        if (!existing) throw new NotFoundException('Skill bucket not found');\r\n\r\n        const updated = await this.prisma.skillBucket.update({\r\n            where: { id },\r\n            data,\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.UPDATE,\r\n                entityType: 'SkillBucket',\r\n                entityId: id,\r\n                oldValue: existing as any,\r\n                newValue: data,\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Skill bucket updated', data: updated };\r\n    }\r\n\r\n    async deleteSkillBucket(id: string, adminId: string) {\r\n        const bucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id },\r\n            include: {\r\n                _count: {\r\n                    select: {\r\n                        jobs: true,\r\n                        attempts: true,\r\n                        jobRequirements: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!bucket) throw new NotFoundException('Skill bucket not found');\r\n\r\n        // Check if skill bucket is in use\r\n        if (bucket._count.jobs > 0 || bucket._count.jobRequirements > 0) {\r\n            throw new BadRequestException(\r\n                `Cannot delete skill bucket: it is assigned to ${bucket._count.jobs + bucket._count.jobRequirements} job(s). Deactivate it instead.`\r\n            );\r\n        }\r\n\r\n        // If there are attempts, just deactivate instead of hard delete\r\n        if (bucket._count.attempts > 0) {\r\n            await this.prisma.skillBucket.update({\r\n                where: { id },\r\n                data: { isActive: false },\r\n            });\r\n\r\n            await this.prisma.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.UPDATE,\r\n                    entityType: 'SkillBucket',\r\n                    entityId: id,\r\n                    metadata: { action: 'deactivate', reason: 'has_attempts' },\r\n                },\r\n            });\r\n\r\n            return { success: true, message: 'Skill bucket deactivated (has test attempts)' };\r\n        }\r\n\r\n        // Safe to hard delete\r\n        await this.prisma.skillBucket.delete({ where: { id } });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.DELETE,\r\n                entityType: 'SkillBucket',\r\n                entityId: id,\r\n                oldValue: bucket as any,\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Skill bucket deleted' };\r\n    }\r\n\r\n    // ===========================================\r\n    // JOB SKILL REQUIREMENTS\r\n    // ===========================================\r\n\r\n    async addSkillRequirementToJob(jobId: string, skillBucketId: string, adminId: string) {\r\n        const job = await this.prisma.job.findUnique({ where: { id: jobId } });\r\n        if (!job) throw new NotFoundException('Job not found');\r\n\r\n        const bucket = await this.prisma.skillBucket.findUnique({ where: { id: skillBucketId } });\r\n        if (!bucket) throw new NotFoundException('Skill bucket not found');\r\n\r\n        const requirement = await this.prisma.jobRequiredSkillBucket.upsert({\r\n            where: {\r\n                jobId_skillBucketId: { jobId, skillBucketId },\r\n            },\r\n            create: {\r\n                jobId,\r\n                skillBucketId,\r\n            },\r\n            update: {},\r\n            include: {\r\n                SkillBucket: true,\r\n            },\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.CREATE,\r\n                entityType: 'JobRequiredSkillBucket',\r\n                entityId: requirement.id,\r\n                metadata: { jobId, skillBucketId, skillBucketCode: bucket.code },\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Skill requirement added to job', data: requirement };\r\n    }\r\n\r\n    async removeSkillRequirementFromJob(jobId: string, skillBucketId: string, adminId: string) {\r\n        const requirement = await this.prisma.jobRequiredSkillBucket.findUnique({\r\n            where: {\r\n                jobId_skillBucketId: { jobId, skillBucketId },\r\n            },\r\n        });\r\n\r\n        if (!requirement) throw new NotFoundException('Skill requirement not found for this job');\r\n\r\n        await this.prisma.jobRequiredSkillBucket.delete({\r\n            where: {\r\n                jobId_skillBucketId: { jobId, skillBucketId },\r\n            },\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.DELETE,\r\n                entityType: 'JobRequiredSkillBucket',\r\n                entityId: requirement.id,\r\n                metadata: { jobId, skillBucketId },\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Skill requirement removed from job' };\r\n    }\r\n\r\n    async getJobSkillRequirements(jobId: string) {\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            include: {\r\n                SkillBucket: true, // Legacy single bucket\r\n                requiredSkillBucket: {\r\n                    include: {\r\n                        SkillBucket: true,\r\n                    },\r\n                    orderBy: { displayOrder: 'asc' },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!job) throw new NotFoundException('Job not found');\r\n\r\n        return {\r\n            jobId: job.id,\r\n            jobTitle: job.title,\r\n            legacySkillBucket: job.SkillBucket,\r\n            compositeRequirements: job.requiredSkillBuckets,\r\n        };\r\n    }\r\n\r\n    // ===========================================\r\n    // PAYMENT CONTROL (ADMIN OVERRIDE)\r\n    // ===========================================\r\n\r\n    async updatePaymentStatus(paymentId: string, newStatus: PaymentStatus, adminId: string, reason?: string) {\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { id: paymentId },\r\n        });\r\n\r\n        if (!payment) throw new NotFoundException('Payment not found');\r\n\r\n        const oldStatus = payment.status;\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.payment.update({\r\n                where: { id: paymentId },\r\n                data: {\r\n                    status: newStatus,\r\n                    ...(newStatus === PaymentStatus.SUCCESS && { paidAt: new Date() }),\r\n                },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'Payment',\r\n                    entityId: paymentId,\r\n                    oldValue: { status: oldStatus },\r\n                    newValue: { status: newStatus },\r\n                    metadata: { action: 'status_override', reason },\r\n                },\r\n            });\r\n        });\r\n\r\n        return { success: true, message: `Payment status updated to ${newStatus}` };\r\n    }\r\n\r\n    async issueManualRefund(paymentId: string, adminId: string, reason: string) {\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { id: paymentId },\r\n            include: { Refund: true },\r\n        });\r\n\r\n        if (!payment) throw new NotFoundException('Payment not found');\r\n        if (payment.status !== PaymentStatus.SUCCESS) {\r\n            throw new BadRequestException('Can only refund successful payments');\r\n        }\r\n        if (payment.Refund) {\r\n            throw new BadRequestException('Payment already has a refund request');\r\n        }\r\n\r\n        await this.prisma.$transaction(async (tx) => {\r\n            // Create refund record\r\n            const refund = await tx.refund.create({\r\n                data: {\r\n                    paymentId,\r\n                    amount: payment.amount,\r\n                    reason: `ADMIN Refund: ${reason}`,\r\n                    status: RefundStatus.APPROVED,\r\n                    processedBy: adminId,\r\n                    processedAt: new Date(),\r\n                    adminNotes: 'Manual refund by admin',\r\n                },\r\n            });\r\n\r\n            // Update payment status\r\n            await tx.payment.update({\r\n                where: { id: paymentId },\r\n                data: { status: PaymentStatus.REFUNDED },\r\n            });\r\n\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: adminId,\r\n                    action: AuditAction.REFUND_PROCESSED,\r\n                    entityType: 'Refund',\r\n                    entityId: refund.id,\r\n                    metadata: { action: 'manual_refund', reason, amount: payment.amount },\r\n                },\r\n            });\r\n        });\r\n\r\n        // TODO: Process actual Razorpay refund\r\n\r\n        return { success: true, message: 'Manual refund issued successfully' };\r\n    }\r\n\r\n    // ===========================================\r\n    // REVENUE REPORTS\r\n    // ===========================================\r\n\r\n    async getRevenueReport(startDate?: Date, endDate?: Date) {\r\n        const dateFilter: any = {};\r\n        if (startDate) dateFilter.gte = startDate;\r\n        if (endDate) dateFilter.lte = endDate;\r\n\r\n        const payments = await this.prisma.payment.findMany({\r\n            where: {\r\n                status: PaymentStatus.SUCCESS,\r\n                ...(Object.keys(dateFilter).length > 0 && { paidAt: dateFilter }),\r\n            },\r\n            select: {\r\n                amount: true,\r\n                paidAt: true,\r\n                currency: true,\r\n            },\r\n            orderBy: { paidAt: 'desc' },\r\n        });\r\n\r\n        const totalRevenue = payments.reduce((sum, p) => sum + p.amount, 0);\r\n        const refunds = await this.prisma.refund.aggregate({\r\n            where: {\r\n                status: RefundStatus.APPROVED,\r\n                ...(Object.keys(dateFilter).length > 0 && { processedAt: dateFilter }),\r\n            },\r\n            _sum: { amount: true },\r\n        });\r\n\r\n        const netRevenue = totalRevenue - (refunds._sum.amount || 0);\r\n\r\n        // Group by date for charting\r\n        const dailyRevenue: Record<string, number> = {};\r\n        for (const p of payments) {\r\n            if (p.paidAt) {\r\n                const dateKey = p.paidAt.toISOString().split('T')[0];\r\n                dailyRevenue[dateKey] = (dailyRevenue[dateKey] || 0) + p.amount;\r\n            }\r\n        }\r\n\r\n        return {\r\n            summary: {\r\n                totalRevenue,\r\n                totalRefunds: refunds._sum.amount || 0,\r\n                netRevenue,\r\n                transactionCount: payments.length,\r\n            },\r\n            dailyBreakdown: Object.entries(dailyRevenue).map(([date, amount]) => ({\r\n                date,\r\n                amount,\r\n            })),\r\n        };\r\n    }\r\n\r\n    // ===========================================\r\n    // ENHANCED ANALYTICS\r\n    // ===========================================\r\n\r\n    async getEnhancedAnalytics() {\r\n        const [\r\n            // User metrics\r\n            totalCandidates,\r\n            totalHRs,\r\n            activeUsers,\r\n            blockedUsers,\r\n\r\n            // Test metrics\r\n            totalTestAttempts,\r\n            passedTests,\r\n            failedTests,\r\n\r\n            // Interview metrics\r\n            totalInterviews,\r\n            completedInterviews,\r\n            scheduledInterviews,\r\n\r\n            // Payment metrics\r\n            totalPayments,\r\n            successfulPayments,\r\n            refundedPayments,\r\n        ] = await Promise.all([\r\n            this.prisma.user.count({ where: { role: UserRole.CANDIDATE } }),\r\n            this.prisma.user.count({ where: { role: UserRole.HR } }),\r\n            this.prisma.user.count({ where: { status: UserStatus.ACTIVE } }),\r\n            this.prisma.user.count({ where: { status: UserStatus.BLOCKED } }),\r\n\r\n            this.prisma.skillTestAttempt.count(),\r\n            this.prisma.skillTestAttempt.count({ where: { isPassed: true } }),\r\n            this.prisma.skillTestAttempt.count({ where: { isPassed: false } }),\r\n\r\n            this.prisma.interview.count(),\r\n            this.prisma.interview.count({ where: { status: 'INTERVIEW_COMPLETED' } }),\r\n            this.prisma.interview.count({ where: { status: 'PAYMENT_SUCCESS' } }),\r\n\r\n            this.prisma.payment.count(),\r\n            this.prisma.payment.count({ where: { status: PaymentStatus.SUCCESS } }),\r\n            this.prisma.payment.count({ where: { status: PaymentStatus.REFUNDED } }),\r\n        ]);\r\n\r\n        const testPassRate = totalTestAttempts > 0\r\n            ? ((passedTests / totalTestAttempts) * 100).toFixed(2)\r\n            : '0.00';\r\n\r\n        const interviewCompletionRate = totalInterviews > 0\r\n            ? ((completedInterviews / totalInterviews) * 100).toFixed(2)\r\n            : '0.00';\r\n\r\n        return {\r\n            users: {\r\n                totalCandidates,\r\n                totalHRs,\r\n                activeUsers,\r\n                blockedUsers,\r\n            },\r\n            tests: {\r\n                totalAttempts: totalTestAttempts,\r\n                passed: passedTests,\r\n                failed: failedTests,\r\n                passRate: `${testPassRate}%`,\r\n            },\r\n            interviews: {\r\n                total: totalInterviews,\r\n                completed: completedInterviews,\r\n                scheduled: scheduledInterviews,\r\n                completionRate: `${interviewCompletionRate}%`,\r\n            },\r\n            Payment: {\r\n                total: totalPayments,\r\n                successful: successfulPayments,\r\n                refunded: refundedPayments,\r\n            },\r\n        };\r\n    }\r\n\r\n    // ===========================================\r\n    // TEST OVERRIDE CONTROLS (ADMIN POWER FEATURES)\r\n    // ===========================================\r\n\r\n    /**\r\n     * Admin manually marks a candidate as PASSED for a skill test\r\n     * Creates a SkillTestAttempt with isPassed: true\r\n     */\r\n    async manuallyPassTest(\r\n        candidateId: string,\r\n        skillBucketId: string,\r\n        adminId: string,\r\n        reason: string,\r\n        validityDays: number = 7,\r\n    ) {\r\n        // Verify candidate exists\r\n        const candidate = await this.prisma.candidate.findUnique({ where: { id: candidateId } });\r\n        if (!candidate) throw new NotFoundException('Candidate not found');\r\n\r\n        // Verify skill bucket exists\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({ where: { id: skillBucketId } });\r\n        if (!skillBucket) throw new NotFoundException('Skill bucket not found');\r\n\r\n        const now = new Date();\r\n        const validTill = new Date(now.getTime() + validityDays * 24 * 60 * 60 * 1000);\r\n\r\n        const attempt = await this.prisma.skillTestAttempt.create({\r\n            data: {\r\n                candidateId,\r\n                skillBucketId,\r\n                isPassed: true,\r\n                score: 100, // Admin-granted pass\r\n                validTill,\r\n                retestAllowedAt: null,\r\n            },\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.ADMIN_OVERRIDE,\r\n                entityType: 'SkillTestAttempt',\r\n                entityId: attempt.id,\r\n                newValue: { isPassed: true, validTill, validityDays, reason },\r\n                metadata: { action: 'manual_pass', candidateId, skillBucketId },\r\n            },\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            message: `Candidate manually passed for ${skillBucket.name}. Valid until ${validTill.toISOString()}`,\r\n            attempt,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Admin manually marks a candidate as FAILED for a skill test\r\n     * Creates a SkillTestAttempt with isPassed: false and immediate retest allowed\r\n     */\r\n    async manuallyFailTest(\r\n        candidateId: string,\r\n        skillBucketId: string,\r\n        adminId: string,\r\n        reason: string,\r\n    ) {\r\n        // Verify candidate exists\r\n        const candidate = await this.prisma.candidate.findUnique({ where: { id: candidateId } });\r\n        if (!candidate) throw new NotFoundException('Candidate not found');\r\n\r\n        // Verify skill bucket exists\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({ where: { id: skillBucketId } });\r\n        if (!skillBucket) throw new NotFoundException('Skill bucket not found');\r\n\r\n        const now = new Date();\r\n\r\n        const attempt = await this.prisma.skillTestAttempt.create({\r\n            data: {\r\n                candidateId,\r\n                skillBucketId,\r\n                isPassed: false,\r\n                score: 0, // Admin-forced fail\r\n                validTill: null,\r\n                retestAllowedAt: now, // Immediate retest allowed since admin forced it\r\n            },\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.ADMIN_OVERRIDE,\r\n                entityType: 'SkillTestAttempt',\r\n                entityId: attempt.id,\r\n                newValue: { isPassed: false, reason },\r\n                metadata: { action: 'manual_fail', candidateId, skillBucketId },\r\n            },\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            message: `Candidate manually failed for ${skillBucket.name}. Immediate retest allowed.`,\r\n            attempt,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Admin extends the validity of an existing test attempt\r\n     */\r\n    async extendTestValidity(\r\n        attemptId: string,\r\n        newValidTill: Date,\r\n        adminId: string,\r\n        reason: string,\r\n    ) {\r\n        const attempt = await this.prisma.skillTestAttempt.findUnique({\r\n            where: { id: attemptId },\r\n            include: { SkillBucket: true },\r\n        });\r\n\r\n        if (!attempt) throw new NotFoundException('Test attempt not found');\r\n        if (!attempt.isPassed) throw new BadRequestException('Can only extend validity for passed tests');\r\n\r\n        const oldValidTill = attempt.validTill;\r\n\r\n        const updated = await this.prisma.skillTestAttempt.update({\r\n            where: { id: attemptId },\r\n            data: { validTill: newValidTill },\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.ADMIN_OVERRIDE,\r\n                entityType: 'SkillTestAttempt',\r\n                entityId: attemptId,\r\n                oldValue: { validTill: oldValidTill },\r\n                newValue: { validTill: newValidTill, reason },\r\n                metadata: { action: 'extend_validity' },\r\n            },\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            message: `Validity extended to ${newValidTill.toISOString()}`,\r\n            attempt: updated,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Admin resets the retest cooldown for a failed test attempt\r\n     * Allows candidate to immediately retake the test\r\n     */\r\n    async resetRetestCooldown(\r\n        attemptId: string,\r\n        adminId: string,\r\n        reason: string,\r\n    ) {\r\n        const attempt = await this.prisma.skillTestAttempt.findUnique({\r\n            where: { id: attemptId },\r\n            include: { SkillBucket: true },\r\n        });\r\n\r\n        if (!attempt) throw new NotFoundException('Test attempt not found');\r\n        if (attempt.isPassed) throw new BadRequestException('Cooldown reset only applies to failed tests');\r\n\r\n        const now = new Date();\r\n        const oldRetestAllowedAt = attempt.retestAllowedAt;\r\n\r\n        const updated = await this.prisma.skillTestAttempt.update({\r\n            where: { id: attemptId },\r\n            data: { retestAllowedAt: now },\r\n        });\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId: adminId,\r\n                action: AuditAction.ADMIN_OVERRIDE,\r\n                entityType: 'SkillTestAttempt',\r\n                entityId: attemptId,\r\n                oldValue: { retestAllowedAt: oldRetestAllowedAt },\r\n                newValue: { retestAllowedAt: now, reason },\r\n                metadata: { action: 'reset_cooldown' },\r\n            },\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            message: 'Retest cooldown reset. Candidate can now retake the test.',\r\n            attempt: updated,\r\n        };\r\n    }\r\n}\r\n\r\n\r\n"],"names":["AdminService","getDashboardMetrics","totalUsers","totalCandidates","totalHRs","totalEmployees","totalJobs","activeJobs","totalPayments","totalRevenue","pendingRefunds","todayApplications","Promise","all","prisma","user","count","where","role","UserRole","CANDIDATE","HR","EMPLOYEE","job","status","JobStatus","ACTIVE","payment","PaymentStatus","SUCCESS","aggregate","_sum","amount","refund","RefundStatus","REQUESTED","jobApplication","createdAt","gte","Date","setHours","users","total","candidates","hrs","employees","jobs","active","revenue","totalAmount","activity","getAllUsers","page","limit","skip","findMany","take","include","Candidate","select","firstName","lastName","companyName","approvalStatus","Employee","referralCount","orderBy","data","meta","totalPages","Math","ceil","blockUser","userId","adminId","findUnique","id","NotFoundException","$transaction","tx","update","UserStatus","BLOCKED","auditLog","create","action","AuditAction","ADMIN_OVERRIDE","entityType","entityId","metadata","success","message","unblockUser","getPendingHRApprovals","hR","HRApprovalStatus","PENDING","User","email","approveHR","hrId","hr","APPROVED","approvedBy","approvedAt","rejectHR","reason","REJECTED","rejectionReason","getAllJobs","_count","JobApplication","approveJob","jobId","postedAt","expiresAt","now","expireJob","EXPIRED","createJob","jobData","baseSlug","title","toLowerCase","replace","randomSuffix","random","toString","substring","slug","newJob","description","location","salaryMin","salaryMax","experienceMin","experienceMax","referralFee","updateJob","updatedJob","changes","deleteJob","BadRequestException","delete","jobTitle","getAllCandidates","search","OR","contains","mode","Job","deleteUser","ADMIN","candidate","employee","getAllApplications","applications","headline","totalExperience","Interview","paymentStatus","scheduledDate","updateApplicationStatus","applicationId","newStatus","application","oldStatus","oldValue","newValue","getAllPayments","payments","Refund","getPendingRefunds","Payment","approveRefund","refundId","notes","processedBy","processedAt","adminNotes","paymentId","REFUNDED","REFUND_PROCESSED","rejectRefund","getAuditLogs","logs","getAllInterviews","interviews","interview","getInterviewStats","interviewConfirmed","paymentSuccess","completed","candidateNoShow","hrNoShow","cancelled","totalCompleted","noShowRate","toFixed","byStatus","completionRate","updateInterviewStatus","interviewId","updateData","completedAt","markInterviewCompleted","markInterviewNoShow","noShowType","noShowStatus","candidateId","getAllSkillBuckets","includeInactive","skillBucket","isActive","Test","duration","totalQuestionBank","testTemplate","name","passingCriteria","attempts","jobRequirements","code","createSkillBucket","existing","displayName","testId","testTemplateId","CREATE","updateSkillBucket","updated","UPDATE","deleteSkillBucket","bucket","DELETE","addSkillRequirementToJob","skillBucketId","requirement","jobRequiredSkillBucket","upsert","jobId_skillBucketId","SkillBucket","skillBucketCode","removeSkillRequirementFromJob","getJobSkillRequirements","requiredSkillBucket","displayOrder","legacySkillBucket","compositeRequirements","requiredSkillBuckets","updatePaymentStatus","paidAt","issueManualRefund","getRevenueReport","startDate","endDate","dateFilter","lte","Object","keys","length","currency","reduce","sum","p","refunds","netRevenue","dailyRevenue","dateKey","toISOString","split","summary","totalRefunds","transactionCount","dailyBreakdown","entries","map","date","getEnhancedAnalytics","activeUsers","blockedUsers","totalTestAttempts","passedTests","failedTests","totalInterviews","completedInterviews","scheduledInterviews","successfulPayments","refundedPayments","skillTestAttempt","isPassed","testPassRate","interviewCompletionRate","tests","totalAttempts","passed","failed","passRate","scheduled","successful","refunded","manuallyPassTest","validityDays","validTill","getTime","attempt","score","retestAllowedAt","manuallyFailTest","extendTestValidity","attemptId","newValidTill","oldValidTill","resetRetestCooldown","oldRetestAllowedAt"],"mappings":"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"}