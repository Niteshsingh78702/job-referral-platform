{"version":3,"sources":["../../../../src/modules/auth/services/auth.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    UnauthorizedException,\r\n    ConflictException,\r\n    BadRequestException,\r\n    Logger,\r\n} from '@nestjs/common';\r\nimport * as bcrypt from 'bcrypt';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../../prisma/prisma.service';\r\nimport { OtpService } from './otp.service';\r\nimport { TokenService, TokenPair, JwtPayload } from './token.service';\r\nimport { GoogleAuthService } from './google-auth.service';\r\nimport { EmailService } from '../../email';\r\nimport {\r\n    RegisterDto,\r\n    LoginDto,\r\n    SendOtpDto,\r\n    VerifyOtpDto,\r\n    RefreshTokenDto,\r\n    ResetPasswordDto,\r\n    ChangePasswordDto,\r\n    GoogleAuthDto,\r\n    ForgotPasswordDto,\r\n    ResetPasswordWithTokenDto,\r\n} from '../dto';\r\nimport { UserRole, UserStatus, AuditAction } from '../../../common/constants';\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n    private readonly logger = new Logger(AuthService.name);\r\n\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private otpService: OtpService,\r\n        private tokenService: TokenService,\r\n        private googleAuthService: GoogleAuthService,\r\n        private emailService: EmailService,\r\n    ) { }\r\n\r\n    // Register new user\r\n    async register(dto: RegisterDto, deviceInfo?: any): Promise<{ token: TokenPair; user: any }> {\r\n        // Check if email already exists\r\n        const existingUser = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (existingUser) {\r\n            throw new ConflictException('Email already registered');\r\n        }\r\n\r\n        // Check phone if provided\r\n        if (dto.phone) {\r\n            const existingPhone = await this.prisma.user.findUnique({\r\n                where: { phone: dto.phone },\r\n            });\r\n            if (existingPhone) {\r\n                throw new ConflictException('Phone number already registered');\r\n            }\r\n        }\r\n\r\n        // Hash password\r\n        const passwordHash = await bcrypt.hash(dto.password, 12);\r\n\r\n        // Create user and profile in transaction\r\n        const result = await this.prisma.$transaction(async (tx) => {\r\n            const user = await tx.user.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    email: dto.email,\r\n                    phone: dto.phone,\r\n                    passwordHash,\r\n                    role: dto.role || UserRole.CANDIDATE,\r\n                    status: UserStatus.PENDING,\r\n                    updatedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Create candidate profile if role is CANDIDATE\r\n            if (user.role === UserRole.CANDIDATE) {\r\n                await tx.candidate.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        firstName: dto.firstName,\r\n                        lastName: dto.lastName,\r\n                        updatedAt: new Date(),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create employee profile if role is EMPLOYEE\r\n            if (user.role === UserRole.EMPLOYEE) {\r\n                await tx.employee.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        companyName: dto.companyName || 'Unknown Company',\r\n                        companyEmail: dto.email,\r\n                        designation: dto.designation,\r\n                        isVerified: false,\r\n                        updatedAt: new Date(),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create HR profile if role is HR\r\n            if (user.role === UserRole.HR) {\r\n                await tx.hR.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        companyName: dto.companyName || 'Unknown Company',\r\n                        companyEmail: dto.email,\r\n                        designation: dto.designation,\r\n                        updatedAt: new Date(),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n\r\n                // FRAUD DETECTION: Check for multi-account patterns\r\n                await this.checkMultiAccountFraud(tx, user.id, deviceInfo);\r\n            }\r\n\r\n            // Create audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user.id,\r\n                    action: AuditAction.CREATE,\r\n                    entityType: 'User',\r\n                    entityId: user.id,\r\n                    metadata: { registrationSource: 'email' },\r\n                },\r\n            });\r\n\r\n            return user;\r\n        });\r\n\r\n        // Fetch the full user with profile data\r\n        const fullUser = await this.prisma.user.findUnique({\r\n            where: { id: result.id },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: result.id,\r\n            email: result.email,\r\n            role: result.role,\r\n        };\r\n\r\n        const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n        // Build user response with profile data for frontend\r\n        const userResponse = {\r\n            id: result.id,\r\n            email: result.email,\r\n            role: result.role,\r\n            status: result.status,\r\n            firstName: dto.firstName || fullUser?.Candidate?.firstName,\r\n            lastName: dto.lastName || fullUser?.Candidate?.lastName,\r\n        };\r\n\r\n        return {\r\n            token,\r\n            user: userResponse,\r\n        };\r\n    }\r\n\r\n    // Login with email/password\r\n    async login(dto: LoginDto, deviceInfo?: any): Promise<{ token: TokenPair; user: any }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!user || !user.passwordHash) {\r\n            throw new UnauthorizedException('Invalid credentials');\r\n        }\r\n\r\n        if (user.status === UserStatus.BLOCKED) {\r\n            throw new UnauthorizedException('Account is blocked');\r\n        }\r\n\r\n        // Verify password\r\n        const isValid = await bcrypt.compare(dto.password, user.passwordHash);\r\n        if (!isValid) {\r\n            throw new UnauthorizedException('Invalid credentials');\r\n        }\r\n\r\n        // Update last login\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: user.id },\r\n                data: { lastLoginAt: new Date() },\r\n            });\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user.id,\r\n                    action: AuditAction.LOGIN,\r\n                    entityType: 'User',\r\n                    entityId: user.id,\r\n                    metadata: { ip: deviceInfo?.ip },\r\n                },\r\n            });\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n        // Remove sensitive data from user\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n        return {\r\n            token,\r\n            user: userWithoutPassword,\r\n        };\r\n    }\r\n\r\n    // Send OTP\r\n    async sendOtp(dto: SendOtpDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        // For registration flow, user might not exist\r\n        if (dto.type !== 'email_verify' && !user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Generate and store OTP\r\n        const otp = this.otpService.generateOtp();\r\n        const userId = user?.id || dto.email;\r\n        await this.otpService.storeOtp(userId, dto.type, otp);\r\n\r\n        // Store in database as well for tracking\r\n        if (user) {\r\n            await this.prisma.oTPToken.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user.id,\r\n                    otp,\r\n                    type: dto.type,\r\n                    expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes\r\n                },\r\n            });\r\n        }\r\n\r\n        // TODO: Send OTP via email/SMS\r\n        // In development, log the OTP\r\n        if (process.env.NODE_ENV === 'development') {\r\n            console.log(`OTP for ${dto.email}: ${otp}`);\r\n        }\r\n\r\n        return { message: 'OTP sent successfully' };\r\n    }\r\n\r\n    // Verify OTP\r\n    async verifyOtp(dto: VerifyOtpDto): Promise<TokenPair | { message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify OTP\r\n        const isValid = await this.otpService.verifyOtp(user.id, dto.type, dto.otp);\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid or expired OTP');\r\n        }\r\n\r\n        // Mark OTP as used in database\r\n        await this.prisma.oTPToken.updateMany({\r\n            where: {\r\n                userId: user.id,\r\n                otp: dto.otp,\r\n                type: dto.type,\r\n                usedAt: null,\r\n            },\r\n            data: { usedAt: new Date() },\r\n        });\r\n\r\n        // Update user verification status\r\n        if (dto.type === 'email_verify') {\r\n            await this.prisma.user.update({\r\n                where: { id: user.id },\r\n                data: {\r\n                    emailVerified: true,\r\n                    status: UserStatus.ACTIVE,\r\n                },\r\n            });\r\n        } else if (dto.type === 'phone_verify') {\r\n            await this.prisma.user.update({\r\n                where: { id: user.id },\r\n                data: { phoneVerified: true },\r\n            });\r\n        }\r\n\r\n        // For login OTP, return tokens\r\n        if (dto.type === 'login') {\r\n            const payload: JwtPayload = {\r\n                sub: user.id,\r\n                email: user.email,\r\n                role: user.role,\r\n            };\r\n            return this.tokenService.generateTokenPair(payload);\r\n        }\r\n\r\n        return { message: 'OTP verified successfully' };\r\n    }\r\n\r\n    // Refresh token\r\n    async refreshToken(dto: RefreshTokenDto): Promise<TokenPair> {\r\n        // Extract user ID from refresh token\r\n        const parts = dto.refreshToken.split('.');\r\n        if (parts.length !== 3) {\r\n            throw new UnauthorizedException('Invalid refresh token format');\r\n        }\r\n\r\n        const userId = parts[0];\r\n\r\n        // Validate refresh token\r\n        const isValid = await this.tokenService.validateRefreshToken(\r\n            userId,\r\n            dto.refreshToken,\r\n        );\r\n\r\n        if (!isValid) {\r\n            throw new UnauthorizedException('Invalid or expired refresh token');\r\n        }\r\n\r\n        // Get user\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n        });\r\n\r\n        if (!user || user.status === UserStatus.BLOCKED) {\r\n            throw new UnauthorizedException('User not found or blocked');\r\n        }\r\n\r\n        // Generate new token pair\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        return this.tokenService.generateTokenPair(payload);\r\n    }\r\n\r\n    // Logout\r\n    async logout(userId: string): Promise<{ message: string }> {\r\n        await this.tokenService.revokeRefreshToken(userId);\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.LOGOUT,\r\n                entityType: 'User',\r\n                entityId: userId,\r\n            },\r\n        });\r\n\r\n        return { message: 'Logged out successfully' };\r\n    }\r\n\r\n    // Reset password\r\n    async resetPassword(dto: ResetPasswordDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify OTP\r\n        const isValid = await this.otpService.verifyOtp(\r\n            user.id,\r\n            'password_reset',\r\n            dto.otp,\r\n        );\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid or expired OTP');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.user.update({\r\n            where: { id: user.id },\r\n            data: { passwordHash },\r\n        });\r\n\r\n        // Revoke all tokens\r\n        await this.tokenService.revokeRefreshToken(user.id);\r\n\r\n        return { message: 'Password reset successfully' };\r\n    }\r\n\r\n    // Change password\r\n    async changePassword(\r\n        userId: string,\r\n        dto: ChangePasswordDto,\r\n    ): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n        });\r\n\r\n        if (!user || !user.passwordHash) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify current password\r\n        const isValid = await bcrypt.compare(\r\n            dto.currentPassword,\r\n            user.passwordHash,\r\n        );\r\n        if (!isValid) {\r\n            throw new BadRequestException('Current password is incorrect');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.user.update({\r\n            where: { id: userId },\r\n            data: { passwordHash },\r\n        });\r\n\r\n        return { message: 'Password changed successfully' };\r\n    }\r\n\r\n    // Get current user\r\n    async getCurrentUser(userId: string) {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Remove sensitive data\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n        return userWithoutPassword;\r\n    }\r\n\r\n    // ==========================================\r\n    // FORGOT PASSWORD / RESET WITH TOKEN\r\n    // ==========================================\r\n\r\n    // Request password reset (sends email with link)\r\n    async forgotPassword(dto: ForgotPasswordDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n            include: { Candidate: true },\r\n        });\r\n\r\n        // Always return success message to prevent email enumeration\r\n        if (!user) {\r\n            this.logger.log(`Password reset requested for non-existent email: ${dto.email}`);\r\n            return { message: 'If an account exists with this email, you will receive a password reset link.' };\r\n        }\r\n\r\n        // Generate secure reset token\r\n        const resetToken = crypto.randomBytes(32).toString('hex');\r\n        const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour\r\n\r\n        // Delete any existing reset tokens for this user\r\n        await this.prisma.passwordResetToken.deleteMany({\r\n            where: { userId: user.id },\r\n        });\r\n\r\n        // Create new reset token\r\n        await this.prisma.passwordResetToken.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId: user.id,\r\n                token: resetToken,\r\n                expiresAt,\r\n            },\r\n        });\r\n\r\n        // Get user name for email\r\n        const userName = user.Candidate?.firstName || 'User';\r\n\r\n        // Send reset email\r\n        await this.emailService.sendPasswordResetEmail(\r\n            user.email,\r\n            resetToken,\r\n            userName,\r\n        );\r\n\r\n        return { message: 'If an account exists with this email, you will receive a password reset link.' };\r\n    }\r\n\r\n    // Reset password with token (from email link)\r\n    async resetPasswordWithToken(dto: ResetPasswordWithTokenDto): Promise<{ message: string }> {\r\n        const resetToken = await this.prisma.passwordResetToken.findUnique({\r\n            where: { token: dto.token },\r\n            include: { User: true },\r\n        });\r\n\r\n        if (!resetToken) {\r\n            throw new BadRequestException('Invalid or expired reset link');\r\n        }\r\n\r\n        if (resetToken.usedAt) {\r\n            throw new BadRequestException('This reset link has already been used');\r\n        }\r\n\r\n        if (new Date() > resetToken.expiresAt) {\r\n            throw new BadRequestException('This reset link has expired');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: resetToken.userId },\r\n                data: { passwordHash },\r\n            });\r\n\r\n            // Mark token as used\r\n            await tx.passwordResetToken.update({\r\n                where: { id: resetToken.id },\r\n                data: { usedAt: new Date() },\r\n            });\r\n        });\r\n\r\n        // Revoke all refresh tokens for security\r\n        await this.tokenService.revokeRefreshToken(resetToken.userId);\r\n\r\n        return { message: 'Password reset successfully. Please login with your new password.' };\r\n    }\r\n\r\n    // ==========================================\r\n    // GOOGLE OAUTH LOGIN\r\n    // ==========================================\r\n\r\n    async googleLogin(dto: GoogleAuthDto, deviceInfo?: any): Promise<{ token: TokenPair; user: any; isNewUser: boolean }> {\r\n        // Verify Google token\r\n        const googlePayload = await this.googleAuthService.verifyIdToken(dto.idToken);\r\n\r\n        // Check if user exists by Google ID\r\n        let user = await this.prisma.user.findUnique({\r\n            where: { googleId: googlePayload.sub },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        let isNewUser = false;\r\n\r\n        if (!user) {\r\n            // Check if user exists by email (account linking)\r\n            const existingEmailUser = await this.prisma.user.findUnique({\r\n                where: { email: googlePayload.email },\r\n                include: {\r\n                    Candidate: true,\r\n                    HR: true,\r\n                    Employee: true,\r\n                },\r\n            });\r\n\r\n            if (existingEmailUser) {\r\n                // Link Google account to existing user\r\n                user = await this.prisma.user.update({\r\n                    where: { id: existingEmailUser.id },\r\n                    data: {\r\n                        googleId: googlePayload.sub,\r\n                        authProvider: existingEmailUser.authProvider === 'email' ? 'email,google' : existingEmailUser.authProvider,\r\n                        emailVerified: true, // Google verifies email\r\n                    },\r\n                    include: {\r\n                        Candidate: true,\r\n                        HR: true,\r\n                        Employee: true,\r\n                    },\r\n                });\r\n                this.logger.log(`Linked Google account to existing user: ${user.email}`);\r\n            } else {\r\n                // Create new user with Google\r\n                isNewUser = true;\r\n                const role = dto.role || UserRole.CANDIDATE;\r\n\r\n                user = await this.prisma.$transaction(async (tx) => {\r\n                    const newUser = await tx.user.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            email: googlePayload.email,\r\n                            googleId: googlePayload.sub,\r\n                            authProvider: 'google',\r\n                            role,\r\n                            status: UserStatus.ACTIVE, // Google users are auto-verified\r\n                            emailVerified: true,\r\n                            updatedAt: new Date(),\r\n                        },\r\n                    });\r\n\r\n                    // Create role-specific profile\r\n                    if (role === UserRole.CANDIDATE) {\r\n                        await tx.candidate.create({\r\n                            data: {\r\n                                id: crypto.randomUUID(),\r\n                                userId: newUser.id,\r\n                                firstName: googlePayload.given_name || googlePayload.name?.split(' ')[0] || 'User',\r\n                                lastName: googlePayload.family_name || googlePayload.name?.split(' ').slice(1).join(' ') || '',\r\n                                avatarUrl: googlePayload.picture,\r\n                                updatedAt: new Date(),\r\n                            },\r\n                        });\r\n                    } else if (role === UserRole.EMPLOYEE) {\r\n                        await tx.employee.create({\r\n                            data: {\r\n                                id: crypto.randomUUID(),\r\n                                userId: newUser.id,\r\n                                companyName: dto.companyName || 'Unknown Company',\r\n                                companyEmail: googlePayload.email,\r\n                                designation: dto.designation,\r\n                                updatedAt: new Date(),\r\n                            },\r\n                        });\r\n                    } else if (role === UserRole.HR) {\r\n                        await tx.hR.create({\r\n                            data: {\r\n                                id: crypto.randomUUID(),\r\n                                userId: newUser.id,\r\n                                companyName: dto.companyName || 'Unknown Company',\r\n                                companyEmail: googlePayload.email,\r\n                                designation: dto.designation,\r\n                                updatedAt: new Date(),\r\n                            },\r\n                        });\r\n                    }\r\n\r\n                    // Audit log\r\n                    await tx.auditLog.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            userId: newUser.id,\r\n                            action: AuditAction.CREATE,\r\n                            entityType: 'User',\r\n                            entityId: newUser.id,\r\n                            metadata: { registrationSource: 'google' },\r\n                        },\r\n                    });\r\n\r\n                    return tx.user.findUnique({\r\n                        where: { id: newUser.id },\r\n                        include: {\r\n                            Candidate: true,\r\n                            HR: true,\r\n                            Employee: true,\r\n                        },\r\n                    });\r\n                });\r\n\r\n                // Send welcome email for new users\r\n                const userName = googlePayload.given_name || googlePayload.name || 'there';\r\n                await this.emailService.sendWelcomeEmail(googlePayload.email, userName);\r\n            }\r\n        }\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('Failed to create or find user');\r\n        }\r\n\r\n        // Update last login\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: user!.id },\r\n                data: { lastLoginAt: new Date() },\r\n            });\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user!.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user!.id,\r\n                    action: AuditAction.LOGIN,\r\n                    entityType: 'User',\r\n                    entityId: user!.id,\r\n                    metadata: { loginMethod: 'google' },\r\n                },\r\n            });\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n        // Remove sensitive data\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n        return {\r\n            token,\r\n            user: userWithoutPassword,\r\n            isNewUser,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * FRAUD DETECTION: Check for multi-account patterns\r\n     * Flags when same device ID or IP address is used to register multiple accounts\r\n     */\r\n    private async checkMultiAccountFraud(tx: any, userId: string, deviceInfo: any): Promise<void> {\r\n        const deviceId = deviceInfo.deviceId || 'unknown';\r\n        const ipAddress = deviceInfo.ip || 'unknown';\r\n\r\n        // Skip checks for unknown values\r\n        if (deviceId === 'unknown' && ipAddress === 'unknown') {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Check for same device ID used by other accounts\r\n            if (deviceId !== 'unknown') {\r\n                const existingDeviceLogs = await tx.deviceLog.findMany({\r\n                    where: {\r\n                        deviceId,\r\n                        userId: { not: userId },\r\n                    },\r\n                    distinct: ['userId'],\r\n                    take: 5,\r\n                });\r\n\r\n                if (existingDeviceLogs.length > 0) {\r\n                    const otherUserIds = existingDeviceLogs.map((log: any) => log.userId);\r\n                    await tx.suspiciousActivity.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            userId,\r\n                            activityType: 'MULTI_ACCOUNT_DEVICE',\r\n                            severity: existingDeviceLogs.length >= 3 ? 'HIGH' : 'MEDIUM',\r\n                            deviceId,\r\n                            ipAddress,\r\n                            details: {\r\n                                otherAccountsCount: existingDeviceLogs.length,\r\n                                otherUserIds,\r\n                                message: `Device ${deviceId} was used to register ${existingDeviceLogs.length + 1} accounts`,\r\n                            },\r\n                        },\r\n                    });\r\n                    this.logger.warn(\r\n                        `FRAUD ALERT: Multi-account detected on device ${deviceId}. ` +\r\n                        `User ${userId} shares device with ${existingDeviceLogs.length} other accounts.`\r\n                    );\r\n                }\r\n            }\r\n\r\n            // Check for same IP used by multiple accounts recently (last 24h)\r\n            if (ipAddress !== 'unknown') {\r\n                const recentDate = new Date(Date.now() - 24 * 60 * 60 * 1000);\r\n                const existingIpLogs = await tx.deviceLog.findMany({\r\n                    where: {\r\n                        ipAddress,\r\n                        userId: { not: userId },\r\n                        createdAt: { gte: recentDate },\r\n                    },\r\n                    distinct: ['userId'],\r\n                    take: 5,\r\n                });\r\n\r\n                if (existingIpLogs.length >= 2) {\r\n                    const otherUserIds = existingIpLogs.map((log: any) => log.userId);\r\n                    await tx.suspiciousActivity.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            userId,\r\n                            activityType: 'MULTI_ACCOUNT_IP',\r\n                            severity: existingIpLogs.length >= 5 ? 'HIGH' : 'LOW',\r\n                            deviceId,\r\n                            ipAddress,\r\n                            details: {\r\n                                otherAccountsCount: existingIpLogs.length,\r\n                                otherUserIds,\r\n                                timeWindow: '24h',\r\n                                message: `IP ${ipAddress} registered ${existingIpLogs.length + 1} accounts in last 24 hours`,\r\n                            },\r\n                        },\r\n                    });\r\n                    this.logger.warn(\r\n                        `FRAUD ALERT: Rapid registrations from IP ${ipAddress}. ` +\r\n                        `${existingIpLogs.length + 1} accounts in 24h.`\r\n                    );\r\n                }\r\n            }\r\n        } catch (error) {\r\n            // Don't block registration if fraud check fails\r\n            this.logger.error('Fraud check failed', error);\r\n        }\r\n    }\r\n}\r\n"],"names":["AuthService","register","dto","deviceInfo","existingUser","prisma","user","findUnique","where","email","ConflictException","phone","existingPhone","passwordHash","bcrypt","hash","password","result","$transaction","tx","create","data","id","crypto","randomUUID","role","UserRole","CANDIDATE","status","UserStatus","PENDING","updatedAt","Date","candidate","userId","firstName","lastName","EMPLOYEE","employee","companyName","companyEmail","designation","isVerified","HR","hR","deviceLog","deviceId","ipAddress","ip","userAgent","checkMultiAccountFraud","auditLog","action","AuditAction","CREATE","entityType","entityId","metadata","registrationSource","fullUser","include","Candidate","Employee","payload","sub","token","tokenService","generateTokenPair","userResponse","login","UnauthorizedException","BLOCKED","isValid","compare","update","lastLoginAt","LOGIN","userWithoutPassword","sendOtp","type","BadRequestException","otp","otpService","generateOtp","storeOtp","oTPToken","expiresAt","now","process","env","NODE_ENV","console","log","message","verifyOtp","updateMany","usedAt","emailVerified","ACTIVE","phoneVerified","refreshToken","parts","split","length","validateRefreshToken","logout","revokeRefreshToken","LOGOUT","resetPassword","newPassword","changePassword","currentPassword","getCurrentUser","forgotPassword","logger","resetToken","randomBytes","toString","passwordResetToken","deleteMany","userName","emailService","sendPasswordResetEmail","resetPasswordWithToken","User","googleLogin","googlePayload","googleAuthService","verifyIdToken","idToken","googleId","isNewUser","existingEmailUser","authProvider","newUser","given_name","name","family_name","slice","join","avatarUrl","picture","sendWelcomeEmail","loginMethod","existingDeviceLogs","findMany","not","distinct","take","otherUserIds","map","suspiciousActivity","activityType","severity","details","otherAccountsCount","warn","recentDate","existingIpLogs","createdAt","gte","timeWindow","error","Logger"],"mappings":"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"}