{"version":3,"sources":["../../../../src/modules/auth/services/auth.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  UnauthorizedException,\r\n  ConflictException,\r\n  BadRequestException,\r\n  Logger,\r\n} from '@nestjs/common';\r\nimport * as bcrypt from 'bcrypt';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../../prisma/prisma.service';\r\nimport { OtpService } from './otp.service';\r\nimport { TokenService, TokenPair, JwtPayload } from './token.service';\r\nimport { GoogleAuthService } from './google-auth.service';\r\nimport { EmailService } from '../../email';\r\nimport {\r\n  RegisterDto,\r\n  LoginDto,\r\n  SendOtpDto,\r\n  VerifyOtpDto,\r\n  RefreshTokenDto,\r\n  ResetPasswordDto,\r\n  ChangePasswordDto,\r\n  GoogleAuthDto,\r\n  ForgotPasswordDto,\r\n  ResetPasswordWithTokenDto,\r\n} from '../dto';\r\nimport { UserRole, UserStatus, AuditAction } from '../../../common/constants';\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n  private readonly logger = new Logger(AuthService.name);\r\n\r\n  constructor(\r\n    private prisma: PrismaService,\r\n    private otpService: OtpService,\r\n    private tokenService: TokenService,\r\n    private googleAuthService: GoogleAuthService,\r\n    private emailService: EmailService,\r\n  ) {}\r\n\r\n  // Register new user\r\n  async register(\r\n    dto: RegisterDto,\r\n    deviceInfo?: any,\r\n  ): Promise<{ token: TokenPair; user: any }> {\r\n    // Check if email already exists\r\n    const existingUser = await this.prisma.user.findUnique({\r\n      where: { email: dto.email },\r\n    });\r\n\r\n    if (existingUser) {\r\n      throw new ConflictException('Email already registered');\r\n    }\r\n\r\n    // Check phone if provided\r\n    if (dto.phone) {\r\n      const existingPhone = await this.prisma.user.findUnique({\r\n        where: { phone: dto.phone },\r\n      });\r\n      if (existingPhone) {\r\n        throw new ConflictException('Phone number already registered');\r\n      }\r\n    }\r\n\r\n    // Hash password\r\n    const passwordHash = await bcrypt.hash(dto.password, 12);\r\n\r\n    // Create user and profile in transaction\r\n    const result = await this.prisma.$transaction(async (tx) => {\r\n      const user = await tx.user.create({\r\n        data: {\r\n          id: crypto.randomUUID(),\r\n          email: dto.email,\r\n          phone: dto.phone,\r\n          passwordHash,\r\n          role: dto.role || UserRole.CANDIDATE,\r\n          status: UserStatus.PENDING,\r\n          updatedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Create candidate profile if role is CANDIDATE\r\n      if (user.role === UserRole.CANDIDATE) {\r\n        await tx.candidate.create({\r\n          data: {\r\n            id: crypto.randomUUID(),\r\n            userId: user.id,\r\n            firstName: dto.firstName,\r\n            lastName: dto.lastName,\r\n            updatedAt: new Date(),\r\n          },\r\n        });\r\n      }\r\n\r\n      // Create employee profile if role is EMPLOYEE\r\n      if (user.role === UserRole.EMPLOYEE) {\r\n        await tx.employee.create({\r\n          data: {\r\n            id: crypto.randomUUID(),\r\n            userId: user.id,\r\n            companyName: dto.companyName || 'Unknown Company',\r\n            companyEmail: dto.email,\r\n            designation: dto.designation,\r\n            isVerified: false,\r\n            updatedAt: new Date(),\r\n          },\r\n        });\r\n      }\r\n\r\n      // Create HR profile if role is HR\r\n      if (user.role === UserRole.HR) {\r\n        await tx.hR.create({\r\n          data: {\r\n            id: crypto.randomUUID(),\r\n            userId: user.id,\r\n            companyName: dto.companyName || 'Unknown Company',\r\n            companyEmail: dto.email,\r\n            designation: dto.designation,\r\n            updatedAt: new Date(),\r\n          },\r\n        });\r\n      }\r\n\r\n      // Log device\r\n      if (deviceInfo) {\r\n        await tx.deviceLog.create({\r\n          data: {\r\n            id: crypto.randomUUID(),\r\n            userId: user.id,\r\n            deviceId: deviceInfo.deviceId || 'unknown',\r\n            ipAddress: deviceInfo.ip || 'unknown',\r\n            userAgent: deviceInfo.userAgent,\r\n          },\r\n        });\r\n\r\n        // FRAUD DETECTION: Check for multi-account patterns\r\n        await this.checkMultiAccountFraud(tx, user.id, deviceInfo);\r\n      }\r\n\r\n      // Create audit log\r\n      await tx.auditLog.create({\r\n        data: {\r\n          id: crypto.randomUUID(),\r\n          userId: user.id,\r\n          action: AuditAction.CREATE,\r\n          entityType: 'User',\r\n          entityId: user.id,\r\n          metadata: { registrationSource: 'email' },\r\n        },\r\n      });\r\n\r\n      return user;\r\n    });\r\n\r\n    // Fetch the full user with profile data\r\n    const fullUser = await this.prisma.user.findUnique({\r\n      where: { id: result.id },\r\n      include: {\r\n        Candidate: true,\r\n        HR: true,\r\n        Employee: true,\r\n      },\r\n    });\r\n\r\n    // Generate tokens\r\n    const payload: JwtPayload = {\r\n      sub: result.id,\r\n      email: result.email,\r\n      role: result.role,\r\n    };\r\n\r\n    const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n    // Build user response with profile data for frontend\r\n    const userResponse = {\r\n      id: result.id,\r\n      email: result.email,\r\n      role: result.role,\r\n      status: result.status,\r\n      firstName: dto.firstName || fullUser?.Candidate?.firstName,\r\n      lastName: dto.lastName || fullUser?.Candidate?.lastName,\r\n    };\r\n\r\n    return {\r\n      token,\r\n      user: userResponse,\r\n    };\r\n  }\r\n\r\n  // Login with email/password\r\n  async login(\r\n    dto: LoginDto,\r\n    deviceInfo?: any,\r\n  ): Promise<{ token: TokenPair; user: any }> {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { email: dto.email },\r\n      include: {\r\n        Candidate: true,\r\n        HR: true,\r\n        Employee: true,\r\n      },\r\n    });\r\n\r\n    if (!user || !user.passwordHash) {\r\n      throw new UnauthorizedException('Invalid credentials');\r\n    }\r\n\r\n    if (user.status === UserStatus.BLOCKED) {\r\n      throw new UnauthorizedException('Account is blocked');\r\n    }\r\n\r\n    // Verify password\r\n    const isValid = await bcrypt.compare(dto.password, user.passwordHash);\r\n    if (!isValid) {\r\n      throw new UnauthorizedException('Invalid credentials');\r\n    }\r\n\r\n    // Update last login\r\n    await this.prisma.$transaction(async (tx) => {\r\n      await tx.user.update({\r\n        where: { id: user.id },\r\n        data: { lastLoginAt: new Date() },\r\n      });\r\n\r\n      // Log device\r\n      if (deviceInfo) {\r\n        await tx.deviceLog.create({\r\n          data: {\r\n            id: crypto.randomUUID(),\r\n            userId: user.id,\r\n            deviceId: deviceInfo.deviceId || 'unknown',\r\n            ipAddress: deviceInfo.ip || 'unknown',\r\n            userAgent: deviceInfo.userAgent,\r\n          },\r\n        });\r\n      }\r\n\r\n      // Audit log\r\n      await tx.auditLog.create({\r\n        data: {\r\n          id: crypto.randomUUID(),\r\n          userId: user.id,\r\n          action: AuditAction.LOGIN,\r\n          entityType: 'User',\r\n          entityId: user.id,\r\n          metadata: { ip: deviceInfo?.ip },\r\n        },\r\n      });\r\n    });\r\n\r\n    // Generate tokens\r\n    const payload: JwtPayload = {\r\n      sub: user.id,\r\n      email: user.email,\r\n      role: user.role,\r\n    };\r\n\r\n    const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n    // Remove sensitive data from user\r\n    const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n    return {\r\n      token,\r\n      user: userWithoutPassword,\r\n    };\r\n  }\r\n\r\n  // Send OTP\r\n  async sendOtp(dto: SendOtpDto): Promise<{ message: string }> {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { email: dto.email },\r\n    });\r\n\r\n    // For registration flow, user might not exist\r\n    if (dto.type !== 'email_verify' && !user) {\r\n      throw new BadRequestException('User not found');\r\n    }\r\n\r\n    // Generate and store OTP\r\n    const otp = this.otpService.generateOtp();\r\n    const userId = user?.id || dto.email;\r\n    await this.otpService.storeOtp(userId, dto.type, otp);\r\n\r\n    // Store in database as well for tracking\r\n    if (user) {\r\n      await this.prisma.oTPToken.create({\r\n        data: {\r\n          id: crypto.randomUUID(),\r\n          userId: user.id,\r\n          otp,\r\n          type: dto.type,\r\n          expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes\r\n        },\r\n      });\r\n    }\r\n\r\n    // TODO: Send OTP via email/SMS\r\n    // In development, log the OTP\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log(`OTP for ${dto.email}: ${otp}`);\r\n    }\r\n\r\n    return { message: 'OTP sent successfully' };\r\n  }\r\n\r\n  // Verify OTP\r\n  async verifyOtp(dto: VerifyOtpDto): Promise<TokenPair | { message: string }> {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { email: dto.email },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new BadRequestException('User not found');\r\n    }\r\n\r\n    // Verify OTP\r\n    const isValid = await this.otpService.verifyOtp(user.id, dto.type, dto.otp);\r\n    if (!isValid) {\r\n      throw new BadRequestException('Invalid or expired OTP');\r\n    }\r\n\r\n    // Mark OTP as used in database\r\n    await this.prisma.oTPToken.updateMany({\r\n      where: {\r\n        userId: user.id,\r\n        otp: dto.otp,\r\n        type: dto.type,\r\n        usedAt: null,\r\n      },\r\n      data: { usedAt: new Date() },\r\n    });\r\n\r\n    // Update user verification status\r\n    if (dto.type === 'email_verify') {\r\n      await this.prisma.user.update({\r\n        where: { id: user.id },\r\n        data: {\r\n          emailVerified: true,\r\n          status: UserStatus.ACTIVE,\r\n        },\r\n      });\r\n    } else if (dto.type === 'phone_verify') {\r\n      await this.prisma.user.update({\r\n        where: { id: user.id },\r\n        data: { phoneVerified: true },\r\n      });\r\n    }\r\n\r\n    // For login OTP, return tokens\r\n    if (dto.type === 'login') {\r\n      const payload: JwtPayload = {\r\n        sub: user.id,\r\n        email: user.email,\r\n        role: user.role,\r\n      };\r\n      return this.tokenService.generateTokenPair(payload);\r\n    }\r\n\r\n    return { message: 'OTP verified successfully' };\r\n  }\r\n\r\n  // Refresh token\r\n  async refreshToken(dto: RefreshTokenDto): Promise<TokenPair> {\r\n    // Extract user ID from refresh token\r\n    const parts = dto.refreshToken.split('.');\r\n    if (parts.length !== 3) {\r\n      throw new UnauthorizedException('Invalid refresh token format');\r\n    }\r\n\r\n    const userId = parts[0];\r\n\r\n    // Validate refresh token\r\n    const isValid = await this.tokenService.validateRefreshToken(\r\n      userId,\r\n      dto.refreshToken,\r\n    );\r\n\r\n    if (!isValid) {\r\n      throw new UnauthorizedException('Invalid or expired refresh token');\r\n    }\r\n\r\n    // Get user\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { id: userId },\r\n    });\r\n\r\n    if (!user || user.status === UserStatus.BLOCKED) {\r\n      throw new UnauthorizedException('User not found or blocked');\r\n    }\r\n\r\n    // Generate new token pair\r\n    const payload: JwtPayload = {\r\n      sub: user.id,\r\n      email: user.email,\r\n      role: user.role,\r\n    };\r\n\r\n    return this.tokenService.generateTokenPair(payload);\r\n  }\r\n\r\n  // Logout\r\n  async logout(userId: string): Promise<{ message: string }> {\r\n    await this.tokenService.revokeRefreshToken(userId);\r\n\r\n    await this.prisma.auditLog.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        userId,\r\n        action: AuditAction.LOGOUT,\r\n        entityType: 'User',\r\n        entityId: userId,\r\n      },\r\n    });\r\n\r\n    return { message: 'Logged out successfully' };\r\n  }\r\n\r\n  // Reset password\r\n  async resetPassword(dto: ResetPasswordDto): Promise<{ message: string }> {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { email: dto.email },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new BadRequestException('User not found');\r\n    }\r\n\r\n    // Verify OTP\r\n    const isValid = await this.otpService.verifyOtp(\r\n      user.id,\r\n      'password_reset',\r\n      dto.otp,\r\n    );\r\n    if (!isValid) {\r\n      throw new BadRequestException('Invalid or expired OTP');\r\n    }\r\n\r\n    // Update password\r\n    const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n    await this.prisma.user.update({\r\n      where: { id: user.id },\r\n      data: { passwordHash },\r\n    });\r\n\r\n    // Revoke all tokens\r\n    await this.tokenService.revokeRefreshToken(user.id);\r\n\r\n    return { message: 'Password reset successfully' };\r\n  }\r\n\r\n  // Change password\r\n  async changePassword(\r\n    userId: string,\r\n    dto: ChangePasswordDto,\r\n  ): Promise<{ message: string }> {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { id: userId },\r\n    });\r\n\r\n    if (!user || !user.passwordHash) {\r\n      throw new BadRequestException('User not found');\r\n    }\r\n\r\n    // Verify current password\r\n    const isValid = await bcrypt.compare(\r\n      dto.currentPassword,\r\n      user.passwordHash,\r\n    );\r\n    if (!isValid) {\r\n      throw new BadRequestException('Current password is incorrect');\r\n    }\r\n\r\n    // Update password\r\n    const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n    await this.prisma.user.update({\r\n      where: { id: userId },\r\n      data: { passwordHash },\r\n    });\r\n\r\n    return { message: 'Password changed successfully' };\r\n  }\r\n\r\n  // Get current user\r\n  async getCurrentUser(userId: string) {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { id: userId },\r\n      include: {\r\n        Candidate: true,\r\n        HR: true,\r\n        Employee: true,\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new BadRequestException('User not found');\r\n    }\r\n\r\n    // Remove sensitive data\r\n    const { passwordHash, ...userWithoutPassword } = user;\r\n    return userWithoutPassword;\r\n  }\r\n\r\n  // ==========================================\r\n  // FORGOT PASSWORD / RESET WITH TOKEN\r\n  // ==========================================\r\n\r\n  // Request password reset (sends email with link)\r\n  async forgotPassword(dto: ForgotPasswordDto): Promise<{ message: string }> {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { email: dto.email },\r\n      include: { Candidate: true },\r\n    });\r\n\r\n    // Always return success message to prevent email enumeration\r\n    if (!user) {\r\n      this.logger.log(\r\n        `Password reset requested for non-existent email: ${dto.email}`,\r\n      );\r\n      return {\r\n        message:\r\n          'If an account exists with this email, you will receive a password reset link.',\r\n      };\r\n    }\r\n\r\n    // Generate secure reset token\r\n    const resetToken = crypto.randomBytes(32).toString('hex');\r\n    const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour\r\n\r\n    // Delete any existing reset tokens for this user\r\n    await this.prisma.passwordResetToken.deleteMany({\r\n      where: { userId: user.id },\r\n    });\r\n\r\n    // Create new reset token\r\n    await this.prisma.passwordResetToken.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        userId: user.id,\r\n        token: resetToken,\r\n        expiresAt,\r\n      },\r\n    });\r\n\r\n    // Get user name for email\r\n    const userName = user.Candidate?.firstName || 'User';\r\n\r\n    // Send reset email\r\n    await this.emailService.sendPasswordResetEmail(\r\n      user.email,\r\n      resetToken,\r\n      userName,\r\n    );\r\n\r\n    return {\r\n      message:\r\n        'If an account exists with this email, you will receive a password reset link.',\r\n    };\r\n  }\r\n\r\n  // Reset password with token (from email link)\r\n  async resetPasswordWithToken(\r\n    dto: ResetPasswordWithTokenDto,\r\n  ): Promise<{ message: string }> {\r\n    const resetToken = await this.prisma.passwordResetToken.findUnique({\r\n      where: { token: dto.token },\r\n      include: { User: true },\r\n    });\r\n\r\n    if (!resetToken) {\r\n      throw new BadRequestException('Invalid or expired reset link');\r\n    }\r\n\r\n    if (resetToken.usedAt) {\r\n      throw new BadRequestException('This reset link has already been used');\r\n    }\r\n\r\n    if (new Date() > resetToken.expiresAt) {\r\n      throw new BadRequestException('This reset link has expired');\r\n    }\r\n\r\n    // Update password\r\n    const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n    await this.prisma.$transaction(async (tx) => {\r\n      await tx.user.update({\r\n        where: { id: resetToken.userId },\r\n        data: { passwordHash },\r\n      });\r\n\r\n      // Mark token as used\r\n      await tx.passwordResetToken.update({\r\n        where: { id: resetToken.id },\r\n        data: { usedAt: new Date() },\r\n      });\r\n    });\r\n\r\n    // Revoke all refresh tokens for security\r\n    await this.tokenService.revokeRefreshToken(resetToken.userId);\r\n\r\n    return {\r\n      message:\r\n        'Password reset successfully. Please login with your new password.',\r\n    };\r\n  }\r\n\r\n  // ==========================================\r\n  // GOOGLE OAUTH LOGIN\r\n  // ==========================================\r\n\r\n  async googleLogin(\r\n    dto: GoogleAuthDto,\r\n    deviceInfo?: any,\r\n  ): Promise<{ token: TokenPair; user: any; isNewUser: boolean }> {\r\n    // Verify Google token\r\n    const googlePayload = await this.googleAuthService.verifyIdToken(\r\n      dto.idToken,\r\n    );\r\n\r\n    // Check if user exists by Google ID\r\n    let user = await this.prisma.user.findUnique({\r\n      where: { googleId: googlePayload.sub },\r\n      include: {\r\n        Candidate: true,\r\n        HR: true,\r\n        Employee: true,\r\n      },\r\n    });\r\n\r\n    let isNewUser = false;\r\n\r\n    if (!user) {\r\n      // Check if user exists by email (account linking)\r\n      const existingEmailUser = await this.prisma.user.findUnique({\r\n        where: { email: googlePayload.email },\r\n        include: {\r\n          Candidate: true,\r\n          HR: true,\r\n          Employee: true,\r\n        },\r\n      });\r\n\r\n      if (existingEmailUser) {\r\n        // Link Google account to existing user\r\n        user = await this.prisma.user.update({\r\n          where: { id: existingEmailUser.id },\r\n          data: {\r\n            googleId: googlePayload.sub,\r\n            authProvider:\r\n              existingEmailUser.authProvider === 'email'\r\n                ? 'email,google'\r\n                : existingEmailUser.authProvider,\r\n            emailVerified: true, // Google verifies email\r\n          },\r\n          include: {\r\n            Candidate: true,\r\n            HR: true,\r\n            Employee: true,\r\n          },\r\n        });\r\n        this.logger.log(\r\n          `Linked Google account to existing user: ${user.email}`,\r\n        );\r\n      } else {\r\n        // Create new user with Google\r\n        isNewUser = true;\r\n        const role = dto.role || UserRole.CANDIDATE;\r\n\r\n        user = await this.prisma.$transaction(async (tx) => {\r\n          const newUser = await tx.user.create({\r\n            data: {\r\n              id: crypto.randomUUID(),\r\n              email: googlePayload.email,\r\n              googleId: googlePayload.sub,\r\n              authProvider: 'google',\r\n              role,\r\n              status: UserStatus.ACTIVE, // Google users are auto-verified\r\n              emailVerified: true,\r\n              updatedAt: new Date(),\r\n            },\r\n          });\r\n\r\n          // Create role-specific profile\r\n          if (role === UserRole.CANDIDATE) {\r\n            await tx.candidate.create({\r\n              data: {\r\n                id: crypto.randomUUID(),\r\n                userId: newUser.id,\r\n                firstName:\r\n                  googlePayload.given_name ||\r\n                  googlePayload.name?.split(' ')[0] ||\r\n                  'User',\r\n                lastName:\r\n                  googlePayload.family_name ||\r\n                  googlePayload.name?.split(' ').slice(1).join(' ') ||\r\n                  '',\r\n                avatarUrl: googlePayload.picture,\r\n                updatedAt: new Date(),\r\n              },\r\n            });\r\n          } else if (role === UserRole.EMPLOYEE) {\r\n            await tx.employee.create({\r\n              data: {\r\n                id: crypto.randomUUID(),\r\n                userId: newUser.id,\r\n                companyName: dto.companyName || 'Unknown Company',\r\n                companyEmail: googlePayload.email,\r\n                designation: dto.designation,\r\n                updatedAt: new Date(),\r\n              },\r\n            });\r\n          } else if (role === UserRole.HR) {\r\n            await tx.hR.create({\r\n              data: {\r\n                id: crypto.randomUUID(),\r\n                userId: newUser.id,\r\n                companyName: dto.companyName || 'Unknown Company',\r\n                companyEmail: googlePayload.email,\r\n                designation: dto.designation,\r\n                updatedAt: new Date(),\r\n              },\r\n            });\r\n          }\r\n\r\n          // Audit log\r\n          await tx.auditLog.create({\r\n            data: {\r\n              id: crypto.randomUUID(),\r\n              userId: newUser.id,\r\n              action: AuditAction.CREATE,\r\n              entityType: 'User',\r\n              entityId: newUser.id,\r\n              metadata: { registrationSource: 'google' },\r\n            },\r\n          });\r\n\r\n          return tx.user.findUnique({\r\n            where: { id: newUser.id },\r\n            include: {\r\n              Candidate: true,\r\n              HR: true,\r\n              Employee: true,\r\n            },\r\n          });\r\n        });\r\n\r\n        // Send welcome email for new users\r\n        const userName =\r\n          googlePayload.given_name || googlePayload.name || 'there';\r\n        await this.emailService.sendWelcomeEmail(googlePayload.email, userName);\r\n      }\r\n    }\r\n\r\n    if (!user) {\r\n      throw new BadRequestException('Failed to create or find user');\r\n    }\r\n\r\n    // Update last login\r\n    await this.prisma.$transaction(async (tx) => {\r\n      await tx.user.update({\r\n        where: { id: user.id },\r\n        data: { lastLoginAt: new Date() },\r\n      });\r\n\r\n      // Log device\r\n      if (deviceInfo) {\r\n        await tx.deviceLog.create({\r\n          data: {\r\n            id: crypto.randomUUID(),\r\n            userId: user.id,\r\n            deviceId: deviceInfo.deviceId || 'unknown',\r\n            ipAddress: deviceInfo.ip || 'unknown',\r\n            userAgent: deviceInfo.userAgent,\r\n          },\r\n        });\r\n      }\r\n\r\n      // Audit log\r\n      await tx.auditLog.create({\r\n        data: {\r\n          id: crypto.randomUUID(),\r\n          userId: user.id,\r\n          action: AuditAction.LOGIN,\r\n          entityType: 'User',\r\n          entityId: user.id,\r\n          metadata: { loginMethod: 'google' },\r\n        },\r\n      });\r\n    });\r\n\r\n    // Generate tokens\r\n    const payload: JwtPayload = {\r\n      sub: user.id,\r\n      email: user.email,\r\n      role: user.role,\r\n    };\r\n\r\n    const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n    // Remove sensitive data\r\n    const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n    return {\r\n      token,\r\n      user: userWithoutPassword,\r\n      isNewUser,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * FRAUD DETECTION: Check for multi-account patterns\r\n   * Flags when same device ID or IP address is used to register multiple accounts\r\n   */\r\n  private async checkMultiAccountFraud(\r\n    tx: any,\r\n    userId: string,\r\n    deviceInfo: any,\r\n  ): Promise<void> {\r\n    const deviceId = deviceInfo.deviceId || 'unknown';\r\n    const ipAddress = deviceInfo.ip || 'unknown';\r\n\r\n    // Skip checks for unknown values\r\n    if (deviceId === 'unknown' && ipAddress === 'unknown') {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Check for same device ID used by other accounts\r\n      if (deviceId !== 'unknown') {\r\n        const existingDeviceLogs = await tx.deviceLog.findMany({\r\n          where: {\r\n            deviceId,\r\n            userId: { not: userId },\r\n          },\r\n          distinct: ['userId'],\r\n          take: 5,\r\n        });\r\n\r\n        if (existingDeviceLogs.length > 0) {\r\n          const otherUserIds = existingDeviceLogs.map((log: any) => log.userId);\r\n          await tx.suspiciousActivity.create({\r\n            data: {\r\n              id: crypto.randomUUID(),\r\n              userId,\r\n              activityType: 'MULTI_ACCOUNT_DEVICE',\r\n              severity: existingDeviceLogs.length >= 3 ? 'HIGH' : 'MEDIUM',\r\n              deviceId,\r\n              ipAddress,\r\n              details: {\r\n                otherAccountsCount: existingDeviceLogs.length,\r\n                otherUserIds,\r\n                message: `Device ${deviceId} was used to register ${existingDeviceLogs.length + 1} accounts`,\r\n              },\r\n            },\r\n          });\r\n          this.logger.warn(\r\n            `FRAUD ALERT: Multi-account detected on device ${deviceId}. ` +\r\n              `User ${userId} shares device with ${existingDeviceLogs.length} other accounts.`,\r\n          );\r\n        }\r\n      }\r\n\r\n      // Check for same IP used by multiple accounts recently (last 24h)\r\n      if (ipAddress !== 'unknown') {\r\n        const recentDate = new Date(Date.now() - 24 * 60 * 60 * 1000);\r\n        const existingIpLogs = await tx.deviceLog.findMany({\r\n          where: {\r\n            ipAddress,\r\n            userId: { not: userId },\r\n            createdAt: { gte: recentDate },\r\n          },\r\n          distinct: ['userId'],\r\n          take: 5,\r\n        });\r\n\r\n        if (existingIpLogs.length >= 2) {\r\n          const otherUserIds = existingIpLogs.map((log: any) => log.userId);\r\n          await tx.suspiciousActivity.create({\r\n            data: {\r\n              id: crypto.randomUUID(),\r\n              userId,\r\n              activityType: 'MULTI_ACCOUNT_IP',\r\n              severity: existingIpLogs.length >= 5 ? 'HIGH' : 'LOW',\r\n              deviceId,\r\n              ipAddress,\r\n              details: {\r\n                otherAccountsCount: existingIpLogs.length,\r\n                otherUserIds,\r\n                timeWindow: '24h',\r\n                message: `IP ${ipAddress} registered ${existingIpLogs.length + 1} accounts in last 24 hours`,\r\n              },\r\n            },\r\n          });\r\n          this.logger.warn(\r\n            `FRAUD ALERT: Rapid registrations from IP ${ipAddress}. ` +\r\n              `${existingIpLogs.length + 1} accounts in 24h.`,\r\n          );\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // Don't block registration if fraud check fails\r\n      this.logger.error('Fraud check failed', error);\r\n    }\r\n  }\r\n}\r\n"],"names":["AuthService","register","dto","deviceInfo","existingUser","prisma","user","findUnique","where","email","ConflictException","phone","existingPhone","passwordHash","bcrypt","hash","password","result","$transaction","tx","create","data","id","crypto","randomUUID","role","UserRole","CANDIDATE","status","UserStatus","PENDING","updatedAt","Date","candidate","userId","firstName","lastName","EMPLOYEE","employee","companyName","companyEmail","designation","isVerified","HR","hR","deviceLog","deviceId","ipAddress","ip","userAgent","checkMultiAccountFraud","auditLog","action","AuditAction","CREATE","entityType","entityId","metadata","registrationSource","fullUser","include","Candidate","Employee","payload","sub","token","tokenService","generateTokenPair","userResponse","login","UnauthorizedException","BLOCKED","isValid","compare","update","lastLoginAt","LOGIN","userWithoutPassword","sendOtp","type","BadRequestException","otp","otpService","generateOtp","storeOtp","oTPToken","expiresAt","now","process","env","NODE_ENV","console","log","message","verifyOtp","updateMany","usedAt","emailVerified","ACTIVE","phoneVerified","refreshToken","parts","split","length","validateRefreshToken","logout","revokeRefreshToken","LOGOUT","resetPassword","newPassword","changePassword","currentPassword","getCurrentUser","forgotPassword","logger","resetToken","randomBytes","toString","passwordResetToken","deleteMany","userName","emailService","sendPasswordResetEmail","resetPasswordWithToken","User","googleLogin","googlePayload","googleAuthService","verifyIdToken","idToken","googleId","isNewUser","existingEmailUser","authProvider","newUser","given_name","name","family_name","slice","join","avatarUrl","picture","sendWelcomeEmail","loginMethod","existingDeviceLogs","findMany","not","distinct","take","otherUserIds","map","suspiciousActivity","activityType","severity","details","otherAccountsCount","warn","recentDate","existingIpLogs","createdAt","gte","timeWindow","error","Logger"],"mappings":"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"}