{"version":3,"sources":["../../../../src/modules/auth/services/auth.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    UnauthorizedException,\r\n    ConflictException,\r\n    BadRequestException,\r\n    Logger,\r\n} from '@nestjs/common';\r\nimport * as bcrypt from 'bcrypt';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../../prisma/prisma.service';\r\nimport { OtpService } from './otp.service';\r\nimport { TokenService, TokenPair, JwtPayload } from './token.service';\r\nimport { GoogleAuthService } from './google-auth.service';\r\nimport { EmailService } from '../../email';\r\nimport {\r\n    RegisterDto,\r\n    LoginDto,\r\n    SendOtpDto,\r\n    VerifyOtpDto,\r\n    RefreshTokenDto,\r\n    ResetPasswordDto,\r\n    ChangePasswordDto,\r\n    GoogleAuthDto,\r\n    ForgotPasswordDto,\r\n    ResetPasswordWithTokenDto,\r\n} from '../dto';\r\nimport { UserRole, UserStatus, AuditAction } from '../../../common/constants';\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n    private readonly logger = new Logger(AuthService.name);\r\n\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private otpService: OtpService,\r\n        private tokenService: TokenService,\r\n        private googleAuthService: GoogleAuthService,\r\n        private emailService: EmailService,\r\n    ) { }\r\n\r\n    // Register new user\r\n    async register(dto: RegisterDto, deviceInfo?: any): Promise<TokenPair> {\r\n        // Check if email already exists\r\n        const existingUser = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (existingUser) {\r\n            throw new ConflictException('Email already registered');\r\n        }\r\n\r\n        // Check phone if provided\r\n        if (dto.phone) {\r\n            const existingPhone = await this.prisma.user.findUnique({\r\n                where: { phone: dto.phone },\r\n            });\r\n            if (existingPhone) {\r\n                throw new ConflictException('Phone number already registered');\r\n            }\r\n        }\r\n\r\n        // Hash password\r\n        const passwordHash = await bcrypt.hash(dto.password, 12);\r\n\r\n        // Create user and profile in transaction\r\n        const result = await this.prisma.$transaction(async (tx) => {\r\n            const user = await tx.user.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    email: dto.email,\r\n                    phone: dto.phone,\r\n                    passwordHash,\r\n                    role: dto.role || UserRole.CANDIDATE,\r\n                    status: UserStatus.PENDING,\r\n                    updatedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Create candidate profile if role is CANDIDATE\r\n            if (user.role === UserRole.CANDIDATE) {\r\n                await tx.candidate.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        firstName: dto.firstName,\r\n                        lastName: dto.lastName,\r\n                        updatedAt: new Date(),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create employee profile if role is EMPLOYEE\r\n            if (user.role === UserRole.EMPLOYEE) {\r\n                await tx.employee.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        companyName: dto.companyName || 'Unknown Company',\r\n                        companyEmail: dto.email,\r\n                        designation: dto.designation,\r\n                        isVerified: false,\r\n                        updatedAt: new Date(),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create HR profile if role is HR\r\n            if (user.role === UserRole.HR) {\r\n                await tx.hR.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        companyName: dto.companyName || 'Unknown Company',\r\n                        companyEmail: dto.email,\r\n                        designation: dto.designation,\r\n                        updatedAt: new Date(),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n\r\n                // FRAUD DETECTION: Check for multi-account patterns\r\n                await this.checkMultiAccountFraud(tx, user.id, deviceInfo);\r\n            }\r\n\r\n            // Create audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user.id,\r\n                    action: AuditAction.CREATE,\r\n                    entityType: 'User',\r\n                    entityId: user.id,\r\n                    metadata: { registrationSource: 'email' },\r\n                },\r\n            });\r\n\r\n            return user;\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: result.id,\r\n            email: result.email,\r\n            role: result.role,\r\n        };\r\n\r\n        return this.tokenService.generateTokenPair(payload);\r\n    }\r\n\r\n    // Login with email/password\r\n    async login(dto: LoginDto, deviceInfo?: any): Promise<{ token: TokenPair; user: any }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!user || !user.passwordHash) {\r\n            throw new UnauthorizedException('Invalid credentials');\r\n        }\r\n\r\n        if (user.status === UserStatus.BLOCKED) {\r\n            throw new UnauthorizedException('Account is blocked');\r\n        }\r\n\r\n        // Verify password\r\n        const isValid = await bcrypt.compare(dto.password, user.passwordHash);\r\n        if (!isValid) {\r\n            throw new UnauthorizedException('Invalid credentials');\r\n        }\r\n\r\n        // Update last login\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: user.id },\r\n                data: { lastLoginAt: new Date() },\r\n            });\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user.id,\r\n                    action: AuditAction.LOGIN,\r\n                    entityType: 'User',\r\n                    entityId: user.id,\r\n                    metadata: { ip: deviceInfo?.ip },\r\n                },\r\n            });\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n        // Remove sensitive data from user\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n        return {\r\n            token,\r\n            user: userWithoutPassword,\r\n        };\r\n    }\r\n\r\n    // Send OTP\r\n    async sendOtp(dto: SendOtpDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        // For registration flow, user might not exist\r\n        if (dto.type !== 'email_verify' && !user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Generate and store OTP\r\n        const otp = this.otpService.generateOtp();\r\n        const userId = user?.id || dto.email;\r\n        await this.otpService.storeOtp(userId, dto.type, otp);\r\n\r\n        // Store in database as well for tracking\r\n        if (user) {\r\n            await this.prisma.oTPToken.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user.id,\r\n                    otp,\r\n                    type: dto.type,\r\n                    expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes\r\n                },\r\n            });\r\n        }\r\n\r\n        // TODO: Send OTP via email/SMS\r\n        // In development, log the OTP\r\n        if (process.env.NODE_ENV === 'development') {\r\n            console.log(`OTP for ${dto.email}: ${otp}`);\r\n        }\r\n\r\n        return { message: 'OTP sent successfully' };\r\n    }\r\n\r\n    // Verify OTP\r\n    async verifyOtp(dto: VerifyOtpDto): Promise<TokenPair | { message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify OTP\r\n        const isValid = await this.otpService.verifyOtp(user.id, dto.type, dto.otp);\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid or expired OTP');\r\n        }\r\n\r\n        // Mark OTP as used in database\r\n        await this.prisma.oTPToken.updateMany({\r\n            where: {\r\n                userId: user.id,\r\n                otp: dto.otp,\r\n                type: dto.type,\r\n                usedAt: null,\r\n            },\r\n            data: { usedAt: new Date() },\r\n        });\r\n\r\n        // Update user verification status\r\n        if (dto.type === 'email_verify') {\r\n            await this.prisma.user.update({\r\n                where: { id: user.id },\r\n                data: {\r\n                    emailVerified: true,\r\n                    status: UserStatus.ACTIVE,\r\n                },\r\n            });\r\n        } else if (dto.type === 'phone_verify') {\r\n            await this.prisma.user.update({\r\n                where: { id: user.id },\r\n                data: { phoneVerified: true },\r\n            });\r\n        }\r\n\r\n        // For login OTP, return tokens\r\n        if (dto.type === 'login') {\r\n            const payload: JwtPayload = {\r\n                sub: user.id,\r\n                email: user.email,\r\n                role: user.role,\r\n            };\r\n            return this.tokenService.generateTokenPair(payload);\r\n        }\r\n\r\n        return { message: 'OTP verified successfully' };\r\n    }\r\n\r\n    // Refresh token\r\n    async refreshToken(dto: RefreshTokenDto): Promise<TokenPair> {\r\n        // Extract user ID from refresh token\r\n        const parts = dto.refreshToken.split('.');\r\n        if (parts.length !== 3) {\r\n            throw new UnauthorizedException('Invalid refresh token format');\r\n        }\r\n\r\n        const userId = parts[0];\r\n\r\n        // Validate refresh token\r\n        const isValid = await this.tokenService.validateRefreshToken(\r\n            userId,\r\n            dto.refreshToken,\r\n        );\r\n\r\n        if (!isValid) {\r\n            throw new UnauthorizedException('Invalid or expired refresh token');\r\n        }\r\n\r\n        // Get user\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n        });\r\n\r\n        if (!user || user.status === UserStatus.BLOCKED) {\r\n            throw new UnauthorizedException('User not found or blocked');\r\n        }\r\n\r\n        // Generate new token pair\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        return this.tokenService.generateTokenPair(payload);\r\n    }\r\n\r\n    // Logout\r\n    async logout(userId: string): Promise<{ message: string }> {\r\n        await this.tokenService.revokeRefreshToken(userId);\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.LOGOUT,\r\n                entityType: 'User',\r\n                entityId: userId,\r\n            },\r\n        });\r\n\r\n        return { message: 'Logged out successfully' };\r\n    }\r\n\r\n    // Reset password\r\n    async resetPassword(dto: ResetPasswordDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify OTP\r\n        const isValid = await this.otpService.verifyOtp(\r\n            user.id,\r\n            'password_reset',\r\n            dto.otp,\r\n        );\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid or expired OTP');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.user.update({\r\n            where: { id: user.id },\r\n            data: { passwordHash },\r\n        });\r\n\r\n        // Revoke all tokens\r\n        await this.tokenService.revokeRefreshToken(user.id);\r\n\r\n        return { message: 'Password reset successfully' };\r\n    }\r\n\r\n    // Change password\r\n    async changePassword(\r\n        userId: string,\r\n        dto: ChangePasswordDto,\r\n    ): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n        });\r\n\r\n        if (!user || !user.passwordHash) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify current password\r\n        const isValid = await bcrypt.compare(\r\n            dto.currentPassword,\r\n            user.passwordHash,\r\n        );\r\n        if (!isValid) {\r\n            throw new BadRequestException('Current password is incorrect');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.user.update({\r\n            where: { id: userId },\r\n            data: { passwordHash },\r\n        });\r\n\r\n        return { message: 'Password changed successfully' };\r\n    }\r\n\r\n    // Get current user\r\n    async getCurrentUser(userId: string) {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Remove sensitive data\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n        return userWithoutPassword;\r\n    }\r\n\r\n    // ==========================================\r\n    // FORGOT PASSWORD / RESET WITH TOKEN\r\n    // ==========================================\r\n\r\n    // Request password reset (sends email with link)\r\n    async forgotPassword(dto: ForgotPasswordDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n            include: { Candidate: true },\r\n        });\r\n\r\n        // Always return success message to prevent email enumeration\r\n        if (!user) {\r\n            this.logger.log(`Password reset requested for non-existent email: ${dto.email}`);\r\n            return { message: 'If an account exists with this email, you will receive a password reset link.' };\r\n        }\r\n\r\n        // Generate secure reset token\r\n        const resetToken = crypto.randomBytes(32).toString('hex');\r\n        const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour\r\n\r\n        // Delete any existing reset tokens for this user\r\n        await this.prisma.passwordResetToken.deleteMany({\r\n            where: { userId: user.id },\r\n        });\r\n\r\n        // Create new reset token\r\n        await this.prisma.passwordResetToken.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId: user.id,\r\n                token: resetToken,\r\n                expiresAt,\r\n            },\r\n        });\r\n\r\n        // Get user name for email\r\n        const userName = user.Candidate?.firstName || 'User';\r\n\r\n        // Send reset email\r\n        await this.emailService.sendPasswordResetEmail(\r\n            user.email,\r\n            resetToken,\r\n            userName,\r\n        );\r\n\r\n        return { message: 'If an account exists with this email, you will receive a password reset link.' };\r\n    }\r\n\r\n    // Reset password with token (from email link)\r\n    async resetPasswordWithToken(dto: ResetPasswordWithTokenDto): Promise<{ message: string }> {\r\n        const resetToken = await this.prisma.passwordResetToken.findUnique({\r\n            where: { token: dto.token },\r\n            include: { User: true },\r\n        });\r\n\r\n        if (!resetToken) {\r\n            throw new BadRequestException('Invalid or expired reset link');\r\n        }\r\n\r\n        if (resetToken.usedAt) {\r\n            throw new BadRequestException('This reset link has already been used');\r\n        }\r\n\r\n        if (new Date() > resetToken.expiresAt) {\r\n            throw new BadRequestException('This reset link has expired');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: resetToken.userId },\r\n                data: { passwordHash },\r\n            });\r\n\r\n            // Mark token as used\r\n            await tx.passwordResetToken.update({\r\n                where: { id: resetToken.id },\r\n                data: { usedAt: new Date() },\r\n            });\r\n        });\r\n\r\n        // Revoke all refresh tokens for security\r\n        await this.tokenService.revokeRefreshToken(resetToken.userId);\r\n\r\n        return { message: 'Password reset successfully. Please login with your new password.' };\r\n    }\r\n\r\n    // ==========================================\r\n    // GOOGLE OAUTH LOGIN\r\n    // ==========================================\r\n\r\n    async googleLogin(dto: GoogleAuthDto, deviceInfo?: any): Promise<{ token: TokenPair; user: any; isNewUser: boolean }> {\r\n        // Verify Google token\r\n        const googlePayload = await this.googleAuthService.verifyIdToken(dto.idToken);\r\n\r\n        // Check if user exists by Google ID\r\n        let user = await this.prisma.user.findUnique({\r\n            where: { googleId: googlePayload.sub },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        let isNewUser = false;\r\n\r\n        if (!user) {\r\n            // Check if user exists by email (account linking)\r\n            const existingEmailUser = await this.prisma.user.findUnique({\r\n                where: { email: googlePayload.email },\r\n                include: {\r\n                    Candidate: true,\r\n                    HR: true,\r\n                    Employee: true,\r\n                },\r\n            });\r\n\r\n            if (existingEmailUser) {\r\n                // Link Google account to existing user\r\n                user = await this.prisma.user.update({\r\n                    where: { id: existingEmailUser.id },\r\n                    data: {\r\n                        googleId: googlePayload.sub,\r\n                        authProvider: existingEmailUser.authProvider === 'email' ? 'email,google' : existingEmailUser.authProvider,\r\n                        emailVerified: true, // Google verifies email\r\n                    },\r\n                    include: {\r\n                        Candidate: true,\r\n                        HR: true,\r\n                        Employee: true,\r\n                    },\r\n                });\r\n                this.logger.log(`Linked Google account to existing user: ${user.email}`);\r\n            } else {\r\n                // Create new user with Google\r\n                isNewUser = true;\r\n                const role = dto.role || UserRole.CANDIDATE;\r\n\r\n                user = await this.prisma.$transaction(async (tx) => {\r\n                    const newUser = await tx.user.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            email: googlePayload.email,\r\n                            googleId: googlePayload.sub,\r\n                            authProvider: 'google',\r\n                            role,\r\n                            status: UserStatus.ACTIVE, // Google users are auto-verified\r\n                            emailVerified: true,\r\n                            updatedAt: new Date(),\r\n                        },\r\n                    });\r\n\r\n                    // Create role-specific profile\r\n                    if (role === UserRole.CANDIDATE) {\r\n                        await tx.candidate.create({\r\n                            data: {\r\n                                id: crypto.randomUUID(),\r\n                                userId: newUser.id,\r\n                                firstName: googlePayload.given_name || googlePayload.name?.split(' ')[0] || 'User',\r\n                                lastName: googlePayload.family_name || googlePayload.name?.split(' ').slice(1).join(' ') || '',\r\n                                avatarUrl: googlePayload.picture,\r\n                                updatedAt: new Date(),\r\n                            },\r\n                        });\r\n                    } else if (role === UserRole.EMPLOYEE) {\r\n                        await tx.employee.create({\r\n                            data: {\r\n                                id: crypto.randomUUID(),\r\n                                userId: newUser.id,\r\n                                companyName: dto.companyName || 'Unknown Company',\r\n                                companyEmail: googlePayload.email,\r\n                                designation: dto.designation,\r\n                                updatedAt: new Date(),\r\n                            },\r\n                        });\r\n                    } else if (role === UserRole.HR) {\r\n                        await tx.hR.create({\r\n                            data: {\r\n                                id: crypto.randomUUID(),\r\n                                userId: newUser.id,\r\n                                companyName: dto.companyName || 'Unknown Company',\r\n                                companyEmail: googlePayload.email,\r\n                                designation: dto.designation,\r\n                                updatedAt: new Date(),\r\n                            },\r\n                        });\r\n                    }\r\n\r\n                    // Audit log\r\n                    await tx.auditLog.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            userId: newUser.id,\r\n                            action: AuditAction.CREATE,\r\n                            entityType: 'User',\r\n                            entityId: newUser.id,\r\n                            metadata: { registrationSource: 'google' },\r\n                        },\r\n                    });\r\n\r\n                    return tx.user.findUnique({\r\n                        where: { id: newUser.id },\r\n                        include: {\r\n                            Candidate: true,\r\n                            HR: true,\r\n                            Employee: true,\r\n                        },\r\n                    });\r\n                });\r\n\r\n                // Send welcome email for new users\r\n                const userName = googlePayload.given_name || googlePayload.name || 'there';\r\n                await this.emailService.sendWelcomeEmail(googlePayload.email, userName);\r\n            }\r\n        }\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('Failed to create or find user');\r\n        }\r\n\r\n        // Update last login\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: user!.id },\r\n                data: { lastLoginAt: new Date() },\r\n            });\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user!.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user!.id,\r\n                    action: AuditAction.LOGIN,\r\n                    entityType: 'User',\r\n                    entityId: user!.id,\r\n                    metadata: { loginMethod: 'google' },\r\n                },\r\n            });\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n        // Remove sensitive data\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n        return {\r\n            token,\r\n            user: userWithoutPassword,\r\n            isNewUser,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * FRAUD DETECTION: Check for multi-account patterns\r\n     * Flags when same device ID or IP address is used to register multiple accounts\r\n     */\r\n    private async checkMultiAccountFraud(tx: any, userId: string, deviceInfo: any): Promise<void> {\r\n        const deviceId = deviceInfo.deviceId || 'unknown';\r\n        const ipAddress = deviceInfo.ip || 'unknown';\r\n\r\n        // Skip checks for unknown values\r\n        if (deviceId === 'unknown' && ipAddress === 'unknown') {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Check for same device ID used by other accounts\r\n            if (deviceId !== 'unknown') {\r\n                const existingDeviceLogs = await tx.deviceLog.findMany({\r\n                    where: {\r\n                        deviceId,\r\n                        userId: { not: userId },\r\n                    },\r\n                    distinct: ['userId'],\r\n                    take: 5,\r\n                });\r\n\r\n                if (existingDeviceLogs.length > 0) {\r\n                    const otherUserIds = existingDeviceLogs.map((log: any) => log.userId);\r\n                    await tx.suspiciousActivity.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            userId,\r\n                            activityType: 'MULTI_ACCOUNT_DEVICE',\r\n                            severity: existingDeviceLogs.length >= 3 ? 'HIGH' : 'MEDIUM',\r\n                            deviceId,\r\n                            ipAddress,\r\n                            details: {\r\n                                otherAccountsCount: existingDeviceLogs.length,\r\n                                otherUserIds,\r\n                                message: `Device ${deviceId} was used to register ${existingDeviceLogs.length + 1} accounts`,\r\n                            },\r\n                        },\r\n                    });\r\n                    this.logger.warn(\r\n                        `FRAUD ALERT: Multi-account detected on device ${deviceId}. ` +\r\n                        `User ${userId} shares device with ${existingDeviceLogs.length} other accounts.`\r\n                    );\r\n                }\r\n            }\r\n\r\n            // Check for same IP used by multiple accounts recently (last 24h)\r\n            if (ipAddress !== 'unknown') {\r\n                const recentDate = new Date(Date.now() - 24 * 60 * 60 * 1000);\r\n                const existingIpLogs = await tx.deviceLog.findMany({\r\n                    where: {\r\n                        ipAddress,\r\n                        userId: { not: userId },\r\n                        createdAt: { gte: recentDate },\r\n                    },\r\n                    distinct: ['userId'],\r\n                    take: 5,\r\n                });\r\n\r\n                if (existingIpLogs.length >= 2) {\r\n                    const otherUserIds = existingIpLogs.map((log: any) => log.userId);\r\n                    await tx.suspiciousActivity.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            userId,\r\n                            activityType: 'MULTI_ACCOUNT_IP',\r\n                            severity: existingIpLogs.length >= 5 ? 'HIGH' : 'LOW',\r\n                            deviceId,\r\n                            ipAddress,\r\n                            details: {\r\n                                otherAccountsCount: existingIpLogs.length,\r\n                                otherUserIds,\r\n                                timeWindow: '24h',\r\n                                message: `IP ${ipAddress} registered ${existingIpLogs.length + 1} accounts in last 24 hours`,\r\n                            },\r\n                        },\r\n                    });\r\n                    this.logger.warn(\r\n                        `FRAUD ALERT: Rapid registrations from IP ${ipAddress}. ` +\r\n                        `${existingIpLogs.length + 1} accounts in 24h.`\r\n                    );\r\n                }\r\n            }\r\n        } catch (error) {\r\n            // Don't block registration if fraud check fails\r\n            this.logger.error('Fraud check failed', error);\r\n        }\r\n    }\r\n}\r\n"],"names":["AuthService","register","dto","deviceInfo","existingUser","prisma","user","findUnique","where","email","ConflictException","phone","existingPhone","passwordHash","bcrypt","hash","password","result","$transaction","tx","create","data","id","crypto","randomUUID","role","UserRole","CANDIDATE","status","UserStatus","PENDING","updatedAt","Date","candidate","userId","firstName","lastName","EMPLOYEE","employee","companyName","companyEmail","designation","isVerified","HR","hR","deviceLog","deviceId","ipAddress","ip","userAgent","checkMultiAccountFraud","auditLog","action","AuditAction","CREATE","entityType","entityId","metadata","registrationSource","payload","sub","tokenService","generateTokenPair","login","include","Candidate","Employee","UnauthorizedException","BLOCKED","isValid","compare","update","lastLoginAt","LOGIN","token","userWithoutPassword","sendOtp","type","BadRequestException","otp","otpService","generateOtp","storeOtp","oTPToken","expiresAt","now","process","env","NODE_ENV","console","log","message","verifyOtp","updateMany","usedAt","emailVerified","ACTIVE","phoneVerified","refreshToken","parts","split","length","validateRefreshToken","logout","revokeRefreshToken","LOGOUT","resetPassword","newPassword","changePassword","currentPassword","getCurrentUser","forgotPassword","logger","resetToken","randomBytes","toString","passwordResetToken","deleteMany","userName","emailService","sendPasswordResetEmail","resetPasswordWithToken","User","googleLogin","googlePayload","googleAuthService","verifyIdToken","idToken","googleId","isNewUser","existingEmailUser","authProvider","newUser","given_name","name","family_name","slice","join","avatarUrl","picture","sendWelcomeEmail","loginMethod","existingDeviceLogs","findMany","not","distinct","take","otherUserIds","map","suspiciousActivity","activityType","severity","details","otherAccountsCount","warn","recentDate","existingIpLogs","createdAt","gte","timeWindow","error","Logger"],"mappings":"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"}