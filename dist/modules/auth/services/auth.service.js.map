{"version":3,"sources":["../../../../src/modules/auth/services/auth.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    UnauthorizedException,\r\n    ConflictException,\r\n    BadRequestException,\r\n    Logger,\r\n} from '@nestjs/common';\r\nimport * as bcrypt from 'bcrypt';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../../prisma/prisma.service';\r\nimport { OtpService } from './otp.service';\r\nimport { TokenService, TokenPair, JwtPayload } from './token.service';\r\nimport { GoogleAuthService } from './google-auth.service';\r\nimport { EmailService } from '../../email';\r\nimport {\r\n    RegisterDto,\r\n    LoginDto,\r\n    SendOtpDto,\r\n    VerifyOtpDto,\r\n    RefreshTokenDto,\r\n    ResetPasswordDto,\r\n    ChangePasswordDto,\r\n    GoogleAuthDto,\r\n    ForgotPasswordDto,\r\n    ResetPasswordWithTokenDto,\r\n} from '../dto';\r\nimport { UserRole, UserStatus, AuditAction } from '../../../common/constants';\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n    private readonly logger = new Logger(AuthService.name);\r\n\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private otpService: OtpService,\r\n        private tokenService: TokenService,\r\n        private googleAuthService: GoogleAuthService,\r\n        private emailService: EmailService,\r\n    ) { }\r\n\r\n    // Register new user\r\n    async register(dto: RegisterDto, deviceInfo?: any): Promise<TokenPair> {\r\n        // Check if email already exists\r\n        const existingUser = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (existingUser) {\r\n            throw new ConflictException('Email already registered');\r\n        }\r\n\r\n        // Check phone if provided\r\n        if (dto.phone) {\r\n            const existingPhone = await this.prisma.user.findUnique({\r\n                where: { phone: dto.phone },\r\n            });\r\n            if (existingPhone) {\r\n                throw new ConflictException('Phone number already registered');\r\n            }\r\n        }\r\n\r\n        // Hash password\r\n        const passwordHash = await bcrypt.hash(dto.password, 12);\r\n\r\n        // Create user and profile in transaction\r\n        const result = await this.prisma.$transaction(async (tx) => {\r\n            const user = await tx.user.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    email: dto.email,\r\n                    phone: dto.phone,\r\n                    passwordHash,\r\n                    role: dto.role || UserRole.CANDIDATE,\r\n                    status: UserStatus.PENDING,\r\n                    updatedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Create candidate profile if role is CANDIDATE\r\n            if (user.role === UserRole.CANDIDATE) {\r\n                await tx.candidate.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        firstName: dto.firstName,\r\n                        lastName: dto.lastName,\r\n                        updatedAt: new Date(),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create employee profile if role is EMPLOYEE\r\n            if (user.role === UserRole.EMPLOYEE) {\r\n                await tx.employee.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        companyName: dto.companyName || 'Unknown Company',\r\n                        companyEmail: dto.email,\r\n                        designation: dto.designation,\r\n                        isVerified: false,\r\n                        updatedAt: new Date(),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create HR profile if role is HR\r\n            if (user.role === UserRole.HR) {\r\n                await tx.hR.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        companyName: dto.companyName || 'Unknown Company',\r\n                        companyEmail: dto.email,\r\n                        designation: dto.designation,\r\n                        updatedAt: new Date(),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user.id,\r\n                    action: AuditAction.CREATE,\r\n                    entityType: 'User',\r\n                    entityId: user.id,\r\n                    metadata: { registrationSource: 'email' },\r\n                },\r\n            });\r\n\r\n            return user;\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: result.id,\r\n            email: result.email,\r\n            role: result.role,\r\n        };\r\n\r\n        return this.tokenService.generateTokenPair(payload);\r\n    }\r\n\r\n    // Login with email/password\r\n    async login(dto: LoginDto, deviceInfo?: any): Promise<{ token: TokenPair; user: any }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!user || !user.passwordHash) {\r\n            throw new UnauthorizedException('Invalid credentials');\r\n        }\r\n\r\n        if (user.status === UserStatus.BLOCKED) {\r\n            throw new UnauthorizedException('Account is blocked');\r\n        }\r\n\r\n        // Verify password\r\n        const isValid = await bcrypt.compare(dto.password, user.passwordHash);\r\n        if (!isValid) {\r\n            throw new UnauthorizedException('Invalid credentials');\r\n        }\r\n\r\n        // Update last login\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: user.id },\r\n                data: { lastLoginAt: new Date() },\r\n            });\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user.id,\r\n                    action: AuditAction.LOGIN,\r\n                    entityType: 'User',\r\n                    entityId: user.id,\r\n                    metadata: { ip: deviceInfo?.ip },\r\n                },\r\n            });\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n        // Remove sensitive data from user\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n        return {\r\n            token,\r\n            user: userWithoutPassword,\r\n        };\r\n    }\r\n\r\n    // Send OTP\r\n    async sendOtp(dto: SendOtpDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        // For registration flow, user might not exist\r\n        if (dto.type !== 'email_verify' && !user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Generate and store OTP\r\n        const otp = this.otpService.generateOtp();\r\n        const userId = user?.id || dto.email;\r\n        await this.otpService.storeOtp(userId, dto.type, otp);\r\n\r\n        // Store in database as well for tracking\r\n        if (user) {\r\n            await this.prisma.oTPToken.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user.id,\r\n                    otp,\r\n                    type: dto.type,\r\n                    expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes\r\n                },\r\n            });\r\n        }\r\n\r\n        // TODO: Send OTP via email/SMS\r\n        // In development, log the OTP\r\n        if (process.env.NODE_ENV === 'development') {\r\n            console.log(`OTP for ${dto.email}: ${otp}`);\r\n        }\r\n\r\n        return { message: 'OTP sent successfully' };\r\n    }\r\n\r\n    // Verify OTP\r\n    async verifyOtp(dto: VerifyOtpDto): Promise<TokenPair | { message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify OTP\r\n        const isValid = await this.otpService.verifyOtp(user.id, dto.type, dto.otp);\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid or expired OTP');\r\n        }\r\n\r\n        // Mark OTP as used in database\r\n        await this.prisma.oTPToken.updateMany({\r\n            where: {\r\n                userId: user.id,\r\n                otp: dto.otp,\r\n                type: dto.type,\r\n                usedAt: null,\r\n            },\r\n            data: { usedAt: new Date() },\r\n        });\r\n\r\n        // Update user verification status\r\n        if (dto.type === 'email_verify') {\r\n            await this.prisma.user.update({\r\n                where: { id: user.id },\r\n                data: {\r\n                    emailVerified: true,\r\n                    status: UserStatus.ACTIVE,\r\n                },\r\n            });\r\n        } else if (dto.type === 'phone_verify') {\r\n            await this.prisma.user.update({\r\n                where: { id: user.id },\r\n                data: { phoneVerified: true },\r\n            });\r\n        }\r\n\r\n        // For login OTP, return tokens\r\n        if (dto.type === 'login') {\r\n            const payload: JwtPayload = {\r\n                sub: user.id,\r\n                email: user.email,\r\n                role: user.role,\r\n            };\r\n            return this.tokenService.generateTokenPair(payload);\r\n        }\r\n\r\n        return { message: 'OTP verified successfully' };\r\n    }\r\n\r\n    // Refresh token\r\n    async refreshToken(dto: RefreshTokenDto): Promise<TokenPair> {\r\n        // Extract user ID from refresh token\r\n        const parts = dto.refreshToken.split('.');\r\n        if (parts.length !== 3) {\r\n            throw new UnauthorizedException('Invalid refresh token format');\r\n        }\r\n\r\n        const userId = parts[0];\r\n\r\n        // Validate refresh token\r\n        const isValid = await this.tokenService.validateRefreshToken(\r\n            userId,\r\n            dto.refreshToken,\r\n        );\r\n\r\n        if (!isValid) {\r\n            throw new UnauthorizedException('Invalid or expired refresh token');\r\n        }\r\n\r\n        // Get user\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n        });\r\n\r\n        if (!user || user.status === UserStatus.BLOCKED) {\r\n            throw new UnauthorizedException('User not found or blocked');\r\n        }\r\n\r\n        // Generate new token pair\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        return this.tokenService.generateTokenPair(payload);\r\n    }\r\n\r\n    // Logout\r\n    async logout(userId: string): Promise<{ message: string }> {\r\n        await this.tokenService.revokeRefreshToken(userId);\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.LOGOUT,\r\n                entityType: 'User',\r\n                entityId: userId,\r\n            },\r\n        });\r\n\r\n        return { message: 'Logged out successfully' };\r\n    }\r\n\r\n    // Reset password\r\n    async resetPassword(dto: ResetPasswordDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify OTP\r\n        const isValid = await this.otpService.verifyOtp(\r\n            user.id,\r\n            'password_reset',\r\n            dto.otp,\r\n        );\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid or expired OTP');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.user.update({\r\n            where: { id: user.id },\r\n            data: { passwordHash },\r\n        });\r\n\r\n        // Revoke all tokens\r\n        await this.tokenService.revokeRefreshToken(user.id);\r\n\r\n        return { message: 'Password reset successfully' };\r\n    }\r\n\r\n    // Change password\r\n    async changePassword(\r\n        userId: string,\r\n        dto: ChangePasswordDto,\r\n    ): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n        });\r\n\r\n        if (!user || !user.passwordHash) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify current password\r\n        const isValid = await bcrypt.compare(\r\n            dto.currentPassword,\r\n            user.passwordHash,\r\n        );\r\n        if (!isValid) {\r\n            throw new BadRequestException('Current password is incorrect');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.user.update({\r\n            where: { id: userId },\r\n            data: { passwordHash },\r\n        });\r\n\r\n        return { message: 'Password changed successfully' };\r\n    }\r\n\r\n    // Get current user\r\n    async getCurrentUser(userId: string) {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Remove sensitive data\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n        return userWithoutPassword;\r\n    }\r\n\r\n    // ==========================================\r\n    // FORGOT PASSWORD / RESET WITH TOKEN\r\n    // ==========================================\r\n\r\n    // Request password reset (sends email with link)\r\n    async forgotPassword(dto: ForgotPasswordDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n            include: { Candidate: true },\r\n        });\r\n\r\n        // Always return success message to prevent email enumeration\r\n        if (!user) {\r\n            this.logger.log(`Password reset requested for non-existent email: ${dto.email}`);\r\n            return { message: 'If an account exists with this email, you will receive a password reset link.' };\r\n        }\r\n\r\n        // Generate secure reset token\r\n        const resetToken = crypto.randomBytes(32).toString('hex');\r\n        const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour\r\n\r\n        // Delete any existing reset tokens for this user\r\n        await this.prisma.passwordResetToken.deleteMany({\r\n            where: { userId: user.id },\r\n        });\r\n\r\n        // Create new reset token\r\n        await this.prisma.passwordResetToken.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId: user.id,\r\n                token: resetToken,\r\n                expiresAt,\r\n            },\r\n        });\r\n\r\n        // Get user name for email\r\n        const userName = user.Candidate?.firstName || 'User';\r\n\r\n        // Send reset email\r\n        await this.emailService.sendPasswordResetEmail(\r\n            user.email,\r\n            resetToken,\r\n            userName,\r\n        );\r\n\r\n        return { message: 'If an account exists with this email, you will receive a password reset link.' };\r\n    }\r\n\r\n    // Reset password with token (from email link)\r\n    async resetPasswordWithToken(dto: ResetPasswordWithTokenDto): Promise<{ message: string }> {\r\n        const resetToken = await this.prisma.passwordResetToken.findUnique({\r\n            where: { token: dto.token },\r\n            include: { User: true },\r\n        });\r\n\r\n        if (!resetToken) {\r\n            throw new BadRequestException('Invalid or expired reset link');\r\n        }\r\n\r\n        if (resetToken.usedAt) {\r\n            throw new BadRequestException('This reset link has already been used');\r\n        }\r\n\r\n        if (new Date() > resetToken.expiresAt) {\r\n            throw new BadRequestException('This reset link has expired');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: resetToken.userId },\r\n                data: { passwordHash },\r\n            });\r\n\r\n            // Mark token as used\r\n            await tx.passwordResetToken.update({\r\n                where: { id: resetToken.id },\r\n                data: { usedAt: new Date() },\r\n            });\r\n        });\r\n\r\n        // Revoke all refresh tokens for security\r\n        await this.tokenService.revokeRefreshToken(resetToken.userId);\r\n\r\n        return { message: 'Password reset successfully. Please login with your new password.' };\r\n    }\r\n\r\n    // ==========================================\r\n    // GOOGLE OAUTH LOGIN\r\n    // ==========================================\r\n\r\n    async googleLogin(dto: GoogleAuthDto, deviceInfo?: any): Promise<{ token: TokenPair; user: any; isNewUser: boolean }> {\r\n        // Verify Google token\r\n        const googlePayload = await this.googleAuthService.verifyIdToken(dto.idToken);\r\n\r\n        // Check if user exists by Google ID\r\n        let user = await this.prisma.user.findUnique({\r\n            where: { googleId: googlePayload.sub },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        let isNewUser = false;\r\n\r\n        if (!user) {\r\n            // Check if user exists by email (account linking)\r\n            const existingEmailUser = await this.prisma.user.findUnique({\r\n                where: { email: googlePayload.email },\r\n                include: {\r\n                    Candidate: true,\r\n                    HR: true,\r\n                    Employee: true,\r\n                },\r\n            });\r\n\r\n            if (existingEmailUser) {\r\n                // Link Google account to existing user\r\n                user = await this.prisma.user.update({\r\n                    where: { id: existingEmailUser.id },\r\n                    data: {\r\n                        googleId: googlePayload.sub,\r\n                        authProvider: existingEmailUser.authProvider === 'email' ? 'email,google' : existingEmailUser.authProvider,\r\n                        emailVerified: true, // Google verifies email\r\n                    },\r\n                    include: {\r\n                        Candidate: true,\r\n                        HR: true,\r\n                        Employee: true,\r\n                    },\r\n                });\r\n                this.logger.log(`Linked Google account to existing user: ${user.email}`);\r\n            } else {\r\n                // Create new user with Google\r\n                isNewUser = true;\r\n                const role = dto.role || UserRole.CANDIDATE;\r\n\r\n                user = await this.prisma.$transaction(async (tx) => {\r\n                    const newUser = await tx.user.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            email: googlePayload.email,\r\n                            googleId: googlePayload.sub,\r\n                            authProvider: 'google',\r\n                            role,\r\n                            status: UserStatus.ACTIVE, // Google users are auto-verified\r\n                            emailVerified: true,\r\n                            updatedAt: new Date(),\r\n                        },\r\n                    });\r\n\r\n                    // Create role-specific profile\r\n                    if (role === UserRole.CANDIDATE) {\r\n                        await tx.candidate.create({\r\n                            data: {\r\n                                id: crypto.randomUUID(),\r\n                                userId: newUser.id,\r\n                                firstName: googlePayload.given_name || googlePayload.name?.split(' ')[0] || 'User',\r\n                                lastName: googlePayload.family_name || googlePayload.name?.split(' ').slice(1).join(' ') || '',\r\n                                avatarUrl: googlePayload.picture,\r\n                                updatedAt: new Date(),\r\n                            },\r\n                        });\r\n                    } else if (role === UserRole.EMPLOYEE) {\r\n                        await tx.employee.create({\r\n                            data: {\r\n                                id: crypto.randomUUID(),\r\n                                userId: newUser.id,\r\n                                companyName: dto.companyName || 'Unknown Company',\r\n                                companyEmail: googlePayload.email,\r\n                                designation: dto.designation,\r\n                                updatedAt: new Date(),\r\n                            },\r\n                        });\r\n                    } else if (role === UserRole.HR) {\r\n                        await tx.hR.create({\r\n                            data: {\r\n                                id: crypto.randomUUID(),\r\n                                userId: newUser.id,\r\n                                companyName: dto.companyName || 'Unknown Company',\r\n                                companyEmail: googlePayload.email,\r\n                                designation: dto.designation,\r\n                                updatedAt: new Date(),\r\n                            },\r\n                        });\r\n                    }\r\n\r\n                    // Audit log\r\n                    await tx.auditLog.create({\r\n                        data: {\r\n                            id: crypto.randomUUID(),\r\n                            userId: newUser.id,\r\n                            action: AuditAction.CREATE,\r\n                            entityType: 'User',\r\n                            entityId: newUser.id,\r\n                            metadata: { registrationSource: 'google' },\r\n                        },\r\n                    });\r\n\r\n                    return tx.user.findUnique({\r\n                        where: { id: newUser.id },\r\n                        include: {\r\n                            Candidate: true,\r\n                            HR: true,\r\n                            Employee: true,\r\n                        },\r\n                    });\r\n                });\r\n\r\n                // Send welcome email for new users\r\n                const userName = googlePayload.given_name || googlePayload.name || 'there';\r\n                await this.emailService.sendWelcomeEmail(googlePayload.email, userName);\r\n            }\r\n        }\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('Failed to create or find user');\r\n        }\r\n\r\n        // Update last login\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: user!.id },\r\n                data: { lastLoginAt: new Date() },\r\n            });\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        id: crypto.randomUUID(),\r\n                        userId: user!.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: user!.id,\r\n                    action: AuditAction.LOGIN,\r\n                    entityType: 'User',\r\n                    entityId: user!.id,\r\n                    metadata: { loginMethod: 'google' },\r\n                },\r\n            });\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n        // Remove sensitive data\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n        return {\r\n            token,\r\n            user: userWithoutPassword,\r\n            isNewUser,\r\n        };\r\n    }\r\n}\r\n"],"names":["AuthService","register","dto","deviceInfo","existingUser","prisma","user","findUnique","where","email","ConflictException","phone","existingPhone","passwordHash","bcrypt","hash","password","result","$transaction","tx","create","data","id","crypto","randomUUID","role","UserRole","CANDIDATE","status","UserStatus","PENDING","updatedAt","Date","candidate","userId","firstName","lastName","EMPLOYEE","employee","companyName","companyEmail","designation","isVerified","HR","hR","deviceLog","deviceId","ipAddress","ip","userAgent","auditLog","action","AuditAction","CREATE","entityType","entityId","metadata","registrationSource","payload","sub","tokenService","generateTokenPair","login","include","Candidate","Employee","UnauthorizedException","BLOCKED","isValid","compare","update","lastLoginAt","LOGIN","token","userWithoutPassword","sendOtp","type","BadRequestException","otp","otpService","generateOtp","storeOtp","oTPToken","expiresAt","now","process","env","NODE_ENV","console","log","message","verifyOtp","updateMany","usedAt","emailVerified","ACTIVE","phoneVerified","refreshToken","parts","split","length","validateRefreshToken","logout","revokeRefreshToken","LOGOUT","resetPassword","newPassword","changePassword","currentPassword","getCurrentUser","forgotPassword","logger","resetToken","randomBytes","toString","passwordResetToken","deleteMany","userName","emailService","sendPasswordResetEmail","resetPasswordWithToken","User","googleLogin","googlePayload","googleAuthService","verifyIdToken","idToken","googleId","isNewUser","existingEmailUser","authProvider","newUser","given_name","name","family_name","slice","join","avatarUrl","picture","sendWelcomeEmail","loginMethod","Logger"],"mappings":"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"}