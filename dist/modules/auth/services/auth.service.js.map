{"version":3,"sources":["../../../../src/modules/auth/services/auth.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    UnauthorizedException,\r\n    ConflictException,\r\n    BadRequestException,\r\n    Logger,\r\n} from '@nestjs/common';\r\nimport * as bcrypt from 'bcrypt';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../../prisma/prisma.service';\r\nimport { OtpService } from './otp.service';\r\nimport { TokenService, TokenPair, JwtPayload } from './token.service';\r\nimport { GoogleAuthService } from './google-auth.service';\r\nimport { EmailService } from '../../email';\r\nimport {\r\n    RegisterDto,\r\n    LoginDto,\r\n    SendOtpDto,\r\n    VerifyOtpDto,\r\n    RefreshTokenDto,\r\n    ResetPasswordDto,\r\n    ChangePasswordDto,\r\n    GoogleAuthDto,\r\n    ForgotPasswordDto,\r\n    ResetPasswordWithTokenDto,\r\n} from '../dto';\r\nimport { UserRole, UserStatus, AuditAction } from '../../../common/constants';\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n    private readonly logger = new Logger(AuthService.name);\r\n\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private otpService: OtpService,\r\n        private tokenService: TokenService,\r\n        private googleAuthService: GoogleAuthService,\r\n        private emailService: EmailService,\r\n    ) { }\r\n\r\n    // Register new user\r\n    async register(dto: RegisterDto, deviceInfo?: any): Promise<TokenPair> {\r\n        // Check if email already exists\r\n        const existingUser = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (existingUser) {\r\n            throw new ConflictException('Email already registered');\r\n        }\r\n\r\n        // Check phone if provided\r\n        if (dto.phone) {\r\n            const existingPhone = await this.prisma.user.findUnique({\r\n                where: { phone: dto.phone },\r\n            });\r\n            if (existingPhone) {\r\n                throw new ConflictException('Phone number already registered');\r\n            }\r\n        }\r\n\r\n        // Hash password\r\n        const passwordHash = await bcrypt.hash(dto.password, 12);\r\n\r\n        // Create user and profile in transaction\r\n        const result = await this.prisma.$transaction(async (tx) => {\r\n            const user = await tx.user.create({\r\n                data: {\r\n                    email: dto.email,\r\n                    phone: dto.phone,\r\n                    passwordHash,\r\n                    role: dto.role || UserRole.CANDIDATE,\r\n                    status: UserStatus.PENDING,\r\n                },\r\n            });\r\n\r\n            // Create candidate profile if role is CANDIDATE\r\n            if (user.role === UserRole.CANDIDATE) {\r\n                await tx.candidate.create({\r\n                    data: {\r\n                        userId: user.id,\r\n                        firstName: dto.firstName,\r\n                        lastName: dto.lastName,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create employee profile if role is EMPLOYEE\r\n            if (user.role === UserRole.EMPLOYEE) {\r\n                await tx.employee.create({\r\n                    data: {\r\n                        userId: user.id,\r\n                        companyName: dto.companyName || 'Unknown Company',\r\n                        companyEmail: dto.email,\r\n                        designation: dto.designation,\r\n                        isVerified: false,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create HR profile if role is HR\r\n            if (user.role === UserRole.HR) {\r\n                await tx.hR.create({\r\n                    data: {\r\n                        userId: user.id,\r\n                        companyName: dto.companyName || 'Unknown Company',\r\n                        companyEmail: dto.email,\r\n                        designation: dto.designation,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        userId: user.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Create audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: user.id,\r\n                    action: AuditAction.CREATE,\r\n                    entityType: 'User',\r\n                    entityId: user.id,\r\n                    metadata: { registrationSource: 'email' },\r\n                },\r\n            });\r\n\r\n            return user;\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: result.id,\r\n            email: result.email,\r\n            role: result.role,\r\n        };\r\n\r\n        return this.tokenService.generateTokenPair(payload);\r\n    }\r\n\r\n    // Login with email/password\r\n    async login(dto: LoginDto, deviceInfo?: any): Promise<{ token: TokenPair; user: any }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!user || !user.passwordHash) {\r\n            throw new UnauthorizedException('Invalid credentials');\r\n        }\r\n\r\n        if (user.status === UserStatus.BLOCKED) {\r\n            throw new UnauthorizedException('Account is blocked');\r\n        }\r\n\r\n        // Verify password\r\n        const isValid = await bcrypt.compare(dto.password, user.passwordHash);\r\n        if (!isValid) {\r\n            throw new UnauthorizedException('Invalid credentials');\r\n        }\r\n\r\n        // Update last login\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: user.id },\r\n                data: { lastLoginAt: new Date() },\r\n            });\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        userId: user.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: user.id,\r\n                    action: AuditAction.LOGIN,\r\n                    entityType: 'User',\r\n                    entityId: user.id,\r\n                    metadata: { ip: deviceInfo?.ip },\r\n                },\r\n            });\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n        // Remove sensitive data from user\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n        return {\r\n            token,\r\n            user: userWithoutPassword,\r\n        };\r\n    }\r\n\r\n    // Send OTP\r\n    async sendOtp(dto: SendOtpDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        // For registration flow, user might not exist\r\n        if (dto.type !== 'email_verify' && !user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Generate and store OTP\r\n        const otp = this.otpService.generateOtp();\r\n        const userId = user?.id || dto.email;\r\n        await this.otpService.storeOtp(userId, dto.type, otp);\r\n\r\n        // Store in database as well for tracking\r\n        if (user) {\r\n            await this.prisma.oTPToken.create({\r\n                data: {\r\n                    userId: user.id,\r\n                    otp,\r\n                    type: dto.type,\r\n                    expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes\r\n                },\r\n            });\r\n        }\r\n\r\n        // TODO: Send OTP via email/SMS\r\n        // In development, log the OTP\r\n        if (process.env.NODE_ENV === 'development') {\r\n            console.log(`OTP for ${dto.email}: ${otp}`);\r\n        }\r\n\r\n        return { message: 'OTP sent successfully' };\r\n    }\r\n\r\n    // Verify OTP\r\n    async verifyOtp(dto: VerifyOtpDto): Promise<TokenPair | { message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify OTP\r\n        const isValid = await this.otpService.verifyOtp(user.id, dto.type, dto.otp);\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid or expired OTP');\r\n        }\r\n\r\n        // Mark OTP as used in database\r\n        await this.prisma.oTPToken.updateMany({\r\n            where: {\r\n                userId: user.id,\r\n                otp: dto.otp,\r\n                type: dto.type,\r\n                usedAt: null,\r\n            },\r\n            data: { usedAt: new Date() },\r\n        });\r\n\r\n        // Update user verification status\r\n        if (dto.type === 'email_verify') {\r\n            await this.prisma.user.update({\r\n                where: { id: user.id },\r\n                data: {\r\n                    emailVerified: true,\r\n                    status: UserStatus.ACTIVE,\r\n                },\r\n            });\r\n        } else if (dto.type === 'phone_verify') {\r\n            await this.prisma.user.update({\r\n                where: { id: user.id },\r\n                data: { phoneVerified: true },\r\n            });\r\n        }\r\n\r\n        // For login OTP, return tokens\r\n        if (dto.type === 'login') {\r\n            const payload: JwtPayload = {\r\n                sub: user.id,\r\n                email: user.email,\r\n                role: user.role,\r\n            };\r\n            return this.tokenService.generateTokenPair(payload);\r\n        }\r\n\r\n        return { message: 'OTP verified successfully' };\r\n    }\r\n\r\n    // Refresh token\r\n    async refreshToken(dto: RefreshTokenDto): Promise<TokenPair> {\r\n        // Extract user ID from refresh token\r\n        const parts = dto.refreshToken.split('.');\r\n        if (parts.length !== 3) {\r\n            throw new UnauthorizedException('Invalid refresh token format');\r\n        }\r\n\r\n        const userId = parts[0];\r\n\r\n        // Validate refresh token\r\n        const isValid = await this.tokenService.validateRefreshToken(\r\n            userId,\r\n            dto.refreshToken,\r\n        );\r\n\r\n        if (!isValid) {\r\n            throw new UnauthorizedException('Invalid or expired refresh token');\r\n        }\r\n\r\n        // Get user\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n        });\r\n\r\n        if (!user || user.status === UserStatus.BLOCKED) {\r\n            throw new UnauthorizedException('User not found or blocked');\r\n        }\r\n\r\n        // Generate new token pair\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        return this.tokenService.generateTokenPair(payload);\r\n    }\r\n\r\n    // Logout\r\n    async logout(userId: string): Promise<{ message: string }> {\r\n        await this.tokenService.revokeRefreshToken(userId);\r\n\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                userId,\r\n                action: AuditAction.LOGOUT,\r\n                entityType: 'User',\r\n                entityId: userId,\r\n            },\r\n        });\r\n\r\n        return { message: 'Logged out successfully' };\r\n    }\r\n\r\n    // Reset password\r\n    async resetPassword(dto: ResetPasswordDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify OTP\r\n        const isValid = await this.otpService.verifyOtp(\r\n            user.id,\r\n            'password_reset',\r\n            dto.otp,\r\n        );\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid or expired OTP');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.user.update({\r\n            where: { id: user.id },\r\n            data: { passwordHash },\r\n        });\r\n\r\n        // Revoke all tokens\r\n        await this.tokenService.revokeRefreshToken(user.id);\r\n\r\n        return { message: 'Password reset successfully' };\r\n    }\r\n\r\n    // Change password\r\n    async changePassword(\r\n        userId: string,\r\n        dto: ChangePasswordDto,\r\n    ): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n        });\r\n\r\n        if (!user || !user.passwordHash) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Verify current password\r\n        const isValid = await bcrypt.compare(\r\n            dto.currentPassword,\r\n            user.passwordHash,\r\n        );\r\n        if (!isValid) {\r\n            throw new BadRequestException('Current password is incorrect');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.user.update({\r\n            where: { id: userId },\r\n            data: { passwordHash },\r\n        });\r\n\r\n        return { message: 'Password changed successfully' };\r\n    }\r\n\r\n    // Get current user\r\n    async getCurrentUser(userId: string) {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { id: userId },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('User not found');\r\n        }\r\n\r\n        // Remove sensitive data\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n        return userWithoutPassword;\r\n    }\r\n\r\n    // ==========================================\r\n    // FORGOT PASSWORD / RESET WITH TOKEN\r\n    // ==========================================\r\n\r\n    // Request password reset (sends email with link)\r\n    async forgotPassword(dto: ForgotPasswordDto): Promise<{ message: string }> {\r\n        const user = await this.prisma.user.findUnique({\r\n            where: { email: dto.email },\r\n            include: { Candidate: true },\r\n        });\r\n\r\n        // Always return success message to prevent email enumeration\r\n        if (!user) {\r\n            this.logger.log(`Password reset requested for non-existent email: ${dto.email}`);\r\n            return { message: 'If an account exists with this email, you will receive a password reset link.' };\r\n        }\r\n\r\n        // Generate secure reset token\r\n        const resetToken = crypto.randomBytes(32).toString('hex');\r\n        const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour\r\n\r\n        // Delete any existing reset tokens for this user\r\n        await this.prisma.passwordResetToken.deleteMany({\r\n            where: { userId: user.id },\r\n        });\r\n\r\n        // Create new reset token\r\n        await this.prisma.passwordResetToken.create({\r\n            data: {\r\n                userId: user.id,\r\n                token: resetToken,\r\n                expiresAt,\r\n            },\r\n        });\r\n\r\n        // Get user name for email\r\n        const userName = user.candidate?.firstName || 'User';\r\n\r\n        // Send reset email\r\n        await this.emailService.sendPasswordResetEmail(\r\n            user.email,\r\n            resetToken,\r\n            userName,\r\n        );\r\n\r\n        return { message: 'If an account exists with this email, you will receive a password reset link.' };\r\n    }\r\n\r\n    // Reset password with token (from email link)\r\n    async resetPasswordWithToken(dto: ResetPasswordWithTokenDto): Promise<{ message: string }> {\r\n        const resetToken = await this.prisma.passwordResetToken.findUnique({\r\n            where: { token: dto.token },\r\n            include: { User: true },\r\n        });\r\n\r\n        if (!resetToken) {\r\n            throw new BadRequestException('Invalid or expired reset link');\r\n        }\r\n\r\n        if (resetToken.usedAt) {\r\n            throw new BadRequestException('This reset link has already been used');\r\n        }\r\n\r\n        if (new Date() > resetToken.expiresAt) {\r\n            throw new BadRequestException('This reset link has expired');\r\n        }\r\n\r\n        // Update password\r\n        const passwordHash = await bcrypt.hash(dto.newPassword, 12);\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: resetToken.userId },\r\n                data: { passwordHash },\r\n            });\r\n\r\n            // Mark token as used\r\n            await tx.passwordResetToken.update({\r\n                where: { id: resetToken.id },\r\n                data: { usedAt: new Date() },\r\n            });\r\n        });\r\n\r\n        // Revoke all refresh tokens for security\r\n        await this.tokenService.revokeRefreshToken(resetToken.userId);\r\n\r\n        return { message: 'Password reset successfully. Please login with your new password.' };\r\n    }\r\n\r\n    // ==========================================\r\n    // GOOGLE OAUTH LOGIN\r\n    // ==========================================\r\n\r\n    async googleLogin(dto: GoogleAuthDto, deviceInfo?: any): Promise<{ token: TokenPair; user: any; isNewUser: boolean }> {\r\n        // Verify Google token\r\n        const googlePayload = await this.googleAuthService.verifyIdToken(dto.idToken);\r\n\r\n        // Check if user exists by Google ID\r\n        let user = await this.prisma.user.findUnique({\r\n            where: { googleId: googlePayload.sub },\r\n            include: {\r\n                Candidate: true,\r\n                HR: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        let isNewUser = false;\r\n\r\n        if (!user) {\r\n            // Check if user exists by email (account linking)\r\n            const existingEmailUser = await this.prisma.user.findUnique({\r\n                where: { email: googlePayload.email },\r\n                include: {\r\n                    Candidate: true,\r\n                    HR: true,\r\n                    Employee: true,\r\n                },\r\n            });\r\n\r\n            if (existingEmailUser) {\r\n                // Link Google account to existing user\r\n                user = await this.prisma.user.update({\r\n                    where: { id: existingEmailUser.id },\r\n                    data: {\r\n                        googleId: googlePayload.sub,\r\n                        authProvider: existingEmailUser.authProvider === 'email' ? 'email,google' : existingEmailUser.authProvider,\r\n                        emailVerified: true, // Google verifies email\r\n                    },\r\n                    include: {\r\n                        Candidate: true,\r\n                        HR: true,\r\n                        Employee: true,\r\n                    },\r\n                });\r\n                this.logger.log(`Linked Google account to existing user: ${user.email}`);\r\n            } else {\r\n                // Create new user with Google\r\n                isNewUser = true;\r\n                const role = dto.role || UserRole.CANDIDATE;\r\n\r\n                user = await this.prisma.$transaction(async (tx) => {\r\n                    const newUser = await tx.user.create({\r\n                        data: {\r\n                            email: googlePayload.email,\r\n                            googleId: googlePayload.sub,\r\n                            authProvider: 'google',\r\n                            role,\r\n                            status: UserStatus.ACTIVE, // Google users are auto-verified\r\n                            emailVerified: true,\r\n                        },\r\n                    });\r\n\r\n                    // Create role-specific profile\r\n                    if (role === UserRole.CANDIDATE) {\r\n                        await tx.candidate.create({\r\n                            data: {\r\n                                userId: newUser.id,\r\n                                firstName: googlePayload.given_name || googlePayload.name?.split(' ')[0] || 'User',\r\n                                lastName: googlePayload.family_name || googlePayload.name?.split(' ').slice(1).join(' ') || '',\r\n                                avatarUrl: googlePayload.picture,\r\n                            },\r\n                        });\r\n                    } else if (role === UserRole.EMPLOYEE) {\r\n                        await tx.employee.create({\r\n                            data: {\r\n                                userId: newUser.id,\r\n                                companyName: dto.companyName || 'Unknown Company',\r\n                                companyEmail: googlePayload.email,\r\n                                designation: dto.designation,\r\n                            },\r\n                        });\r\n                    } else if (role === UserRole.HR) {\r\n                        await tx.hR.create({\r\n                            data: {\r\n                                userId: newUser.id,\r\n                                companyName: dto.companyName || 'Unknown Company',\r\n                                companyEmail: googlePayload.email,\r\n                                designation: dto.designation,\r\n                            },\r\n                        });\r\n                    }\r\n\r\n                    // Audit log\r\n                    await tx.auditLog.create({\r\n                        data: {\r\n                            userId: newUser.id,\r\n                            action: AuditAction.CREATE,\r\n                            entityType: 'User',\r\n                            entityId: newUser.id,\r\n                            metadata: { registrationSource: 'google' },\r\n                        },\r\n                    });\r\n\r\n                    return tx.user.findUnique({\r\n                        where: { id: newUser.id },\r\n                        include: {\r\n                            Candidate: true,\r\n                            HR: true,\r\n                            Employee: true,\r\n                        },\r\n                    });\r\n                });\r\n\r\n                // Send welcome email for new users\r\n                const userName = googlePayload.given_name || googlePayload.name || 'there';\r\n                await this.emailService.sendWelcomeEmail(googlePayload.email, userName);\r\n            }\r\n        }\r\n\r\n        if (!user) {\r\n            throw new BadRequestException('Failed to create or find user');\r\n        }\r\n\r\n        // Update last login\r\n        await this.prisma.$transaction(async (tx) => {\r\n            await tx.user.update({\r\n                where: { id: user!.id },\r\n                data: { lastLoginAt: new Date() },\r\n            });\r\n\r\n            // Log device\r\n            if (deviceInfo) {\r\n                await tx.deviceLog.create({\r\n                    data: {\r\n                        userId: user!.id,\r\n                        deviceId: deviceInfo.deviceId || 'unknown',\r\n                        ipAddress: deviceInfo.ip || 'unknown',\r\n                        userAgent: deviceInfo.userAgent,\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    userId: user!.id,\r\n                    action: AuditAction.LOGIN,\r\n                    entityType: 'User',\r\n                    entityId: user!.id,\r\n                    metadata: { loginMethod: 'google' },\r\n                },\r\n            });\r\n        });\r\n\r\n        // Generate tokens\r\n        const payload: JwtPayload = {\r\n            sub: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n        };\r\n\r\n        const token = await this.tokenService.generateTokenPair(payload);\r\n\r\n        // Remove sensitive data\r\n        const { passwordHash, ...userWithoutPassword } = user;\r\n\r\n        return {\r\n            token,\r\n            user: userWithoutPassword,\r\n            isNewUser,\r\n        };\r\n    }\r\n}\r\n"],"names":["AuthService","register","dto","deviceInfo","existingUser","prisma","user","findUnique","where","email","ConflictException","phone","existingPhone","passwordHash","bcrypt","hash","password","result","$transaction","tx","create","data","role","UserRole","CANDIDATE","status","UserStatus","PENDING","candidate","userId","id","firstName","lastName","EMPLOYEE","employee","companyName","companyEmail","designation","isVerified","HR","hR","deviceLog","deviceId","ipAddress","ip","userAgent","auditLog","action","AuditAction","CREATE","entityType","entityId","metadata","registrationSource","payload","sub","tokenService","generateTokenPair","login","include","Candidate","Employee","UnauthorizedException","BLOCKED","isValid","compare","update","lastLoginAt","Date","LOGIN","token","userWithoutPassword","sendOtp","type","BadRequestException","otp","otpService","generateOtp","storeOtp","oTPToken","expiresAt","now","process","env","NODE_ENV","console","log","message","verifyOtp","updateMany","usedAt","emailVerified","ACTIVE","phoneVerified","refreshToken","parts","split","length","validateRefreshToken","logout","revokeRefreshToken","LOGOUT","resetPassword","newPassword","changePassword","currentPassword","getCurrentUser","forgotPassword","logger","resetToken","crypto","randomBytes","toString","passwordResetToken","deleteMany","userName","emailService","sendPasswordResetEmail","resetPasswordWithToken","User","googleLogin","googlePayload","googleAuthService","verifyIdToken","idToken","googleId","isNewUser","existingEmailUser","authProvider","newUser","given_name","name","family_name","slice","join","avatarUrl","picture","sendWelcomeEmail","loginMethod","Logger"],"mappings":"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"}