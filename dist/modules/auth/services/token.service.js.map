{"version":3,"sources":["../../../../src/modules/auth/services/token.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport Redis from 'ioredis';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { REDIS_KEYS } from '../../../common/constants';\r\n\r\nexport interface JwtPayload {\r\n  sub: string;\r\n  email: string;\r\n  role: string;\r\n  iat?: number;\r\n  exp?: number;\r\n}\r\n\r\nexport interface TokenPair {\r\n  accessToken: string;\r\n  refreshToken: string;\r\n  expiresIn: number;\r\n}\r\n\r\n@Injectable()\r\nexport class TokenService {\r\n  private redis: Redis | null = null;\r\n  private readonly logger = new Logger(TokenService.name);\r\n  // In-memory fallback when Redis is unavailable\r\n  private tokenStore: Map<string, { token: string; expiry: number }> =\r\n    new Map();\r\n\r\n  constructor(\r\n    private jwtService: JwtService,\r\n    private configService: ConfigService,\r\n  ) {\r\n    this.initRedis();\r\n  }\r\n\r\n  private initRedis(): void {\r\n    const redisUrl = this.configService.get('REDIS_URL');\r\n    const redisHost = this.configService.get('REDIS_HOST');\r\n\r\n    // Only connect to Redis if explicitly configured\r\n    if (redisUrl || redisHost) {\r\n      try {\r\n        if (redisUrl) {\r\n          this.redis = new Redis(redisUrl);\r\n        } else {\r\n          this.redis = new Redis({\r\n            host: redisHost || 'localhost',\r\n            port: this.configService.get('REDIS_PORT', 6379),\r\n            password: this.configService.get('REDIS_PASSWORD'),\r\n          });\r\n        }\r\n\r\n        this.redis.on('connect', () => {\r\n          this.logger.log('Redis connected successfully');\r\n        });\r\n\r\n        this.redis.on('error', (err) => {\r\n          this.logger.warn(\r\n            `Redis connection error: ${err.message}. Using in-memory fallback.`,\r\n          );\r\n          this.redis = null;\r\n        });\r\n      } catch (error) {\r\n        this.logger.warn(\r\n          `Failed to initialize Redis: ${(error as Error).message}. Using in-memory fallback.`,\r\n        );\r\n        this.redis = null;\r\n      }\r\n    } else {\r\n      this.logger.log('Redis not configured. Using in-memory token storage.');\r\n    }\r\n  }\r\n\r\n  // Generate token pair (access + refresh)\r\n  async generateTokenPair(payload: JwtPayload): Promise<TokenPair> {\r\n    const [accessToken, refreshToken] = await Promise.all([\r\n      this.generateAccessToken(payload),\r\n      this.generateRefreshToken(payload.sub),\r\n    ]);\r\n\r\n    // Store refresh token\r\n    await this.storeRefreshToken(payload.sub, refreshToken);\r\n\r\n    return {\r\n      accessToken,\r\n      refreshToken,\r\n      expiresIn: this.getAccessTokenExpirySeconds(),\r\n    };\r\n  }\r\n\r\n  // Generate access token\r\n  private async generateAccessToken(payload: JwtPayload): Promise<string> {\r\n    return this.jwtService.signAsync(payload, {\r\n      secret: this.configService.get('JWT_SECRET'),\r\n      expiresIn: this.configService.get('JWT_ACCESS_EXPIRY', '7d'), // 7 days default for persistent login\r\n    });\r\n  }\r\n\r\n  // Generate refresh token\r\n  private generateRefreshToken(userId: string): string {\r\n    return `${userId}.${uuidv4()}.${Date.now()}`;\r\n  }\r\n\r\n  // Store refresh token (Redis or in-memory)\r\n  private async storeRefreshToken(\r\n    userId: string,\r\n    refreshToken: string,\r\n  ): Promise<void> {\r\n    const key = REDIS_KEYS.USER_SESSION(userId);\r\n    const expiry = this.getRefreshTokenExpirySeconds();\r\n\r\n    if (this.redis) {\r\n      try {\r\n        await this.redis.set(key, refreshToken, 'EX', expiry);\r\n      } catch (error) {\r\n        this.logger.warn(\r\n          `Redis store failed: ${(error as Error).message}. Using in-memory.`,\r\n        );\r\n        this.storeInMemory(key, refreshToken, expiry);\r\n      }\r\n    } else {\r\n      this.storeInMemory(key, refreshToken, expiry);\r\n    }\r\n  }\r\n\r\n  private storeInMemory(\r\n    key: string,\r\n    token: string,\r\n    expirySeconds: number,\r\n  ): void {\r\n    const expiry = Date.now() + expirySeconds * 1000;\r\n    this.tokenStore.set(key, { token, expiry });\r\n  }\r\n\r\n  // Validate refresh token\r\n  async validateRefreshToken(\r\n    userId: string,\r\n    refreshToken: string,\r\n  ): Promise<boolean> {\r\n    const key = REDIS_KEYS.USER_SESSION(userId);\r\n\r\n    if (this.redis) {\r\n      try {\r\n        const storedToken = await this.redis.get(key);\r\n        return storedToken === refreshToken;\r\n      } catch {\r\n        return this.validateInMemory(key, refreshToken);\r\n      }\r\n    }\r\n    return this.validateInMemory(key, refreshToken);\r\n  }\r\n\r\n  private validateInMemory(key: string, refreshToken: string): boolean {\r\n    const stored = this.tokenStore.get(key);\r\n    if (!stored) return false;\r\n    if (Date.now() > stored.expiry) {\r\n      this.tokenStore.delete(key);\r\n      return false;\r\n    }\r\n    return stored.token === refreshToken;\r\n  }\r\n\r\n  // Revoke refresh token\r\n  async revokeRefreshToken(userId: string): Promise<void> {\r\n    const key = REDIS_KEYS.USER_SESSION(userId);\r\n\r\n    if (this.redis) {\r\n      try {\r\n        await this.redis.del(key);\r\n      } catch {\r\n        this.tokenStore.delete(key);\r\n      }\r\n    } else {\r\n      this.tokenStore.delete(key);\r\n    }\r\n  }\r\n\r\n  // Verify access token\r\n  async verifyAccessToken(token: string): Promise<JwtPayload | null> {\r\n    try {\r\n      const payload = await this.jwtService.verifyAsync<JwtPayload>(token, {\r\n        secret: this.configService.get('JWT_SECRET'),\r\n      });\r\n      return payload;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Get access token expiry in seconds\r\n  private getAccessTokenExpirySeconds(): number {\r\n    const expiry = this.configService.get('JWT_ACCESS_EXPIRY', '7d');\r\n    const match = expiry.match(/(\\d+)([smhd])/);\r\n    if (!match) return 604800; // default 7 days\r\n\r\n    const value = parseInt(match[1]);\r\n    const unit = match[2];\r\n\r\n    switch (unit) {\r\n      case 's':\r\n        return value;\r\n      case 'm':\r\n        return value * 60;\r\n      case 'h':\r\n        return value * 3600;\r\n      case 'd':\r\n        return value * 86400;\r\n      default:\r\n        return 604800;\r\n    }\r\n  }\r\n\r\n  // Get refresh token expiry in seconds\r\n  private getRefreshTokenExpirySeconds(): number {\r\n    const expiry = this.configService.get('JWT_REFRESH_EXPIRY', '7d');\r\n    const match = expiry.match(/(\\d+)([smhd])/);\r\n    if (!match) return 604800; // default 7 days\r\n\r\n    const value = parseInt(match[1]);\r\n    const unit = match[2];\r\n\r\n    switch (unit) {\r\n      case 's':\r\n        return value;\r\n      case 'm':\r\n        return value * 60;\r\n      case 'h':\r\n        return value * 3600;\r\n      case 'd':\r\n        return value * 86400;\r\n      default:\r\n        return 604800;\r\n    }\r\n  }\r\n}\r\n"],"names":["TokenService","initRedis","redisUrl","configService","get","redisHost","redis","Redis","host","port","password","on","logger","log","err","warn","message","error","generateTokenPair","payload","accessToken","refreshToken","Promise","all","generateAccessToken","generateRefreshToken","sub","storeRefreshToken","expiresIn","getAccessTokenExpirySeconds","jwtService","signAsync","secret","userId","uuidv4","Date","now","key","REDIS_KEYS","USER_SESSION","expiry","getRefreshTokenExpirySeconds","set","storeInMemory","token","expirySeconds","tokenStore","validateRefreshToken","storedToken","validateInMemory","stored","delete","revokeRefreshToken","del","verifyAccessToken","verifyAsync","match","value","parseInt","unit","Logger","name","Map"],"mappings":"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"}