{"version":3,"sources":["../../../src/modules/employee/employee.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    NotFoundException,\r\n    BadRequestException,\r\n    ForbiddenException,\r\n} from '@nestjs/common';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport {\r\n    UpdateEmployeeProfileDto,\r\n    ReferralFiltersDto,\r\n    EarningsFiltersDto,\r\n} from './dto';\r\nimport {\r\n    ReferralStatus,\r\n    ReferralType,\r\n    ApplicationStatus,\r\n    EarningStatus,\r\n} from '../../common/constants';\r\n\r\n@Injectable()\r\nexport class EmployeeService {\r\n    constructor(private prisma: PrismaService) { }\r\n\r\n    // Helper to get or create employee profile\r\n    private async getOrCreateEmployee(userId: string) {\r\n        let employee = await this.prisma.employee.findUnique({\r\n            where: { userId },\r\n            include: {\r\n                User: {\r\n                    select: {\r\n                        email: true,\r\n                        phone: true,\r\n                        emailVerified: true,\r\n                        phoneVerified: true,\r\n                        lastLoginAt: true,\r\n                        role: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        // If employee doesn't exist but user has EMPLOYEE role, create one\r\n        if (!employee) {\r\n            const user = await this.prisma.user.findUnique({\r\n                where: { id: userId },\r\n            });\r\n\r\n            if (user && user.role === 'EMPLOYEE') {\r\n                // Auto-create employee profile\r\n                employee = await this.prisma.employee.create({\r\n                    data: {\r\n                        userId: user.id,\r\n                        companyName: user.email.split('@')[1]?.split('.')[0] || 'Unknown Company',\r\n                        companyEmail: user.email,\r\n                        isVerified: false,\r\n                    },\r\n                    include: {\r\n                        User: {\r\n                            select: {\r\n                                email: true,\r\n                                phone: true,\r\n                                emailVerified: true,\r\n                                phoneVerified: true,\r\n                                lastLoginAt: true,\r\n                                role: true,\r\n                            },\r\n                        },\r\n                    },\r\n                });\r\n            }\r\n        }\r\n\r\n        return employee;\r\n    }\r\n\r\n    // Get employee profile with stats\r\n    async getProfile(userId: string) {\r\n        const employee = await this.getOrCreateEmployee(userId);\r\n\r\n        if (!employee) {\r\n            throw new NotFoundException('Employee profile not found. Please ensure you registered as an Employee.');\r\n        }\r\n\r\n        // Get current tier\r\n        const tier = await this.getCurrentTier(userId);\r\n\r\n        return {\r\n            ...Employee,\r\n            currentTier: tier,\r\n        };\r\n    }\r\n\r\n    // Get dashboard statistics\r\n    async getDashboardStats(userId: string) {\r\n        const employee = await this.getOrCreateEmployee(userId);\r\n\r\n        if (!employee) {\r\n            throw new NotFoundException('Employee profile not found. Please ensure you registered as an Employee.');\r\n        }\r\n\r\n        // Get referral stats\r\n        const referralStats = await this.prisma.referral.groupBy({\r\n            by: ['status'],\r\n            where: { employeeId: employee.id },\r\n            _count: true,\r\n        });\r\n\r\n        // Get earnings summary\r\n        const earningsStats = await this.prisma.employeeEarning.aggregate({\r\n            where: { employeeId: employee.id },\r\n            _sum: {\r\n                amount: true,\r\n                bonusAmount: true,\r\n            },\r\n        });\r\n\r\n        const paidEarnings = await this.prisma.employeeEarning.aggregate({\r\n            where: {\r\n                employeeId: employee.id,\r\n                status: EarningStatus.PAID,\r\n            },\r\n            _sum: {\r\n                amount: true,\r\n                bonusAmount: true,\r\n            },\r\n        });\r\n\r\n        const pendingEarnings = await this.prisma.employeeEarning.aggregate({\r\n            where: {\r\n                employeeId: employee.id,\r\n                status: { in: [EarningStatus.PENDING, EarningStatus.ELIGIBLE] },\r\n            },\r\n            _sum: {\r\n                amount: true,\r\n                bonusAmount: true,\r\n            },\r\n        });\r\n\r\n        // Get available referrals count\r\n        const availableReferrals = await this.prisma.referral.count({\r\n            where: {\r\n                status: ReferralStatus.PENDING,\r\n                type: ReferralType.Employee,\r\n                employeeId: null,\r\n                JobApplication: {\r\n                    Job: {\r\n                        companyName: {\r\n                            equals: employee.companyName,\r\n                            mode: 'insensitive',\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        // Get this month's referrals\r\n        const startOfMonth = new Date();\r\n        startOfMonth.setDate(1);\r\n        startOfMonth.setHours(0, 0, 0, 0);\r\n\r\n        const thisMonthReferrals = await this.prisma.referral.count({\r\n            where: {\r\n                employeeId: employee.id,\r\n                createdAt: { gte: startOfMonth },\r\n            },\r\n        });\r\n\r\n        const currentTier = await this.getCurrentTier(userId);\r\n\r\n        return {\r\n            totalReferral: employee.referralCount,\r\n            successfulReferral: employee.successfulReferrals,\r\n            pendingReferral:\r\n                referralStats.find((s) => s.status === ReferralStatus.PENDING)?._count ||\r\n                0,\r\n            confirmedReferral:\r\n                referralStats.find((s) => s.status === ReferralStatus.CONFIRMED)?._count ||\r\n                0,\r\n            availableReferrals,\r\n            thisMonthReferrals,\r\n            totalEarnings:\r\n                (earningsStats._sum.amount || 0) +\r\n                (earningsStats._sum.bonusAmount || 0),\r\n            paidEarnings:\r\n                (paidEarnings._sum.amount || 0) + (paidEarnings._sum.bonusAmount || 0),\r\n            pendingEarnings:\r\n                (pendingEarnings._sum.amount || 0) +\r\n                (pendingEarnings._sum.bonusAmount || 0),\r\n            points: employee.points,\r\n            badges: employee.badges,\r\n            currentTier: currentTier,\r\n        };\r\n    }\r\n\r\n    // Get available referrals - candidates awaiting referral at employee's company\r\n    async getAvailableReferrals(userId: string, search?: string) {\r\n        const employee = await this.prisma.employee.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!employee) {\r\n            throw new NotFoundException('Employee profile not found');\r\n        }\r\n\r\n        if (!employee.isVerified) {\r\n            throw new ForbiddenException(\r\n                'Your employee account is not verified yet. Please wait for verification.'\r\n            );\r\n        }\r\n\r\n        const referrals = await this.prisma.referral.findMany({\r\n            where: {\r\n                status: ReferralStatus.PENDING,\r\n                type: ReferralType.Employee,\r\n                employeeId: null, // Not yet claimed by any employee\r\n                JobApplication: {\r\n                    Job: {\r\n                        companyName: {\r\n                            equals: employee.companyName,\r\n                            mode: 'insensitive',\r\n                        },\r\n                    },\r\n                    ...(search\r\n                        ? {\r\n                            OR: [\r\n                                {\r\n                                    Candidate: {\r\n                                        firstName: { contains: search, mode: 'insensitive' },\r\n                                    },\r\n                                },\r\n                                {\r\n                                    Candidate: {\r\n                                        lastName: { contains: search, mode: 'insensitive' },\r\n                                    },\r\n                                },\r\n                                {\r\n                                    Job: {\r\n                                        title: { contains: search, mode: 'insensitive' },\r\n                                    },\r\n                                },\r\n                            ],\r\n                        }\r\n                        : {}),\r\n                },\r\n            },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Candidate: {\r\n                            select: {\r\n                                id: true,\r\n                                firstName: true,\r\n                                lastName: true,\r\n                                headline: true,\r\n                                totalExperience: true,\r\n                                currentCompany: true,\r\n                                JobSkill: {\r\n                                    select: { name: true, level: true },\r\n                                },\r\n                            },\r\n                        },\r\n                        Job: {\r\n                            select: {\r\n                                id: true,\r\n                                title: true,\r\n                                companyName: true,\r\n                                location: true,\r\n                                referralFee: true,\r\n                            },\r\n                        },\r\n                        TestSession: {\r\n                            where: { isPassed: true },\r\n                            select: { score: true },\r\n                            take: 1,\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n            orderBy: { createdAt: 'desc' },\r\n        });\r\n\r\n        // Calculate potential earning for each\r\n        const tier = await this.getCurrentTier(userId);\r\n        const commissionRate = tier?.current?.commissionPercent || 10; // Default 10%\r\n        const bonusPerReferral = tier?.current?.bonusPerReferral || 0;\r\n\r\n        return referrals.map((ref) => ({\r\n            ...ref,\r\n            potentialEarning:\r\n                (ref.application.job.referralFee * commissionRate) / 100 +\r\n                bonusPerReferral,\r\n            candidateTestScore: ref.application.testSessions[0]?.score || null,\r\n        }));\r\n    }\r\n\r\n    // Get employee's referrals with filters\r\n    async getMyReferrals(userId: string, filters: ReferralFiltersDto) {\r\n        const employee = await this.prisma.employee.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!employee) {\r\n            throw new NotFoundException('Employee profile not found');\r\n        }\r\n\r\n        const { status, fromDate, toDate, page = 1, limit = 10 } = filters;\r\n\r\n        const where: any = {\r\n            employeeId: employee.id,\r\n        };\r\n\r\n        if (status && status !== 'ALL') {\r\n            where.status = status;\r\n        }\r\n\r\n        if (fromDate) {\r\n            where.createdAt = { ...(where.createdAt || {}), gte: new Date(fromDate) };\r\n        }\r\n\r\n        if (toDate) {\r\n            where.createdAt = { ...(where.createdAt || {}), lte: new Date(toDate) };\r\n        }\r\n\r\n        const [referrals, total] = await Promise.all([\r\n            this.prisma.referral.findMany({\r\n                where,\r\n                include: {\r\n                    JobApplication: {\r\n                        include: {\r\n                            Candidate: {\r\n                                select: {\r\n                                    firstName: true,\r\n                                    lastName: true,\r\n                                    headline: true,\r\n                                },\r\n                            },\r\n                            Job: {\r\n                                select: {\r\n                                    title: true,\r\n                                    companyName: true,\r\n                                    referralFee: true,\r\n                                },\r\n                            },\r\n                        },\r\n                    },\r\n                    earning: {\r\n                        select: {\r\n                            amount: true,\r\n                            status: true,\r\n                            paidAt: true,\r\n                        },\r\n                    },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n                skip: (page - 1) * limit,\r\n                take: limit,\r\n            }),\r\n            this.prisma.referral.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            data: referrals,\r\n            pagination: {\r\n                page,\r\n                limit,\r\n                total,\r\n                totalPages: Math.ceil(total / limit),\r\n            },\r\n        };\r\n    }\r\n\r\n    // Confirm/claim a referral\r\n    async confirmReferral(userId: string, applicationId: string) {\r\n        const employee = await this.prisma.employee.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!employee) {\r\n            throw new NotFoundException('Employee profile not found');\r\n        }\r\n\r\n        if (!employee.isVerified) {\r\n            throw new ForbiddenException('Your employee account is not verified');\r\n        }\r\n\r\n        // Find the referral for this application\r\n        const referral = await this.prisma.referral.findUnique({\r\n            where: { applicationId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Job: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!referral) {\r\n            throw new NotFoundException('Referral not found');\r\n        }\r\n\r\n        if (referral.status !== ReferralStatus.PENDING) {\r\n            throw new BadRequestException('Referral is not in pending state');\r\n        }\r\n\r\n        if (referral.employeeId) {\r\n            throw new BadRequestException('Referral already claimed by another employee');\r\n        }\r\n\r\n        // Verify company match\r\n        if (\r\n            employee.companyName.toLowerCase() !==\r\n            referral.application.job.companyName.toLowerCase()\r\n        ) {\r\n            throw new ForbiddenException('Cannot refer for a different company');\r\n        }\r\n\r\n        // Get current tier for commission calculation\r\n        const tier = await this.getCurrentTierInternal(employee.id);\r\n        const commissionRate = tier?.current?.commissionPercent || 10;\r\n        const bonusAmount = tier?.current?.bonusPerReferral || 0;\r\n        const earningAmount =\r\n            (referral.application.job.referralFee * commissionRate) / 100;\r\n\r\n        // Perform transaction\r\n        const result = await this.prisma.$transaction(async (tx) => {\r\n            // Update referral\r\n            const updatedReferral = await tx.referral.update({\r\n                where: { id: referral.id },\r\n                data: {\r\n                    employeeId: employee.id,\r\n                    status: ReferralStatus.CONFIRMED,\r\n                    confirmedAt: new Date(),\r\n                    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days expiry\r\n                },\r\n            });\r\n\r\n            // Update application status - keep as APPLIED (waiting for HR interview confirmation)\r\n            await tx.jobApplication.update({\r\n                where: { id: referral.applicationId },\r\n                data: { status: ApplicationStatus.APPLIED },\r\n            });\r\n\r\n            // Create earning record\r\n            const earning = await tx.employeeEarning.create({\r\n                data: {\r\n                    employeeId: employee.id,\r\n                    referralId: referral.id,\r\n                    amount: earningAmount,\r\n                    bonusAmount: bonusAmount,\r\n                    status: EarningStatus.PENDING,\r\n                    tierName: tier?.current?.name || 'Base',\r\n                    commissionRate: commissionRate,\r\n                },\r\n            });\r\n\r\n            // Update employee stats\r\n            await tx.employee.update({\r\n                where: { id: employee.id },\r\n                data: {\r\n                    referralCount: { increment: 1 },\r\n                    points: { increment: 10 }, // 10 points per referral\r\n                },\r\n            });\r\n\r\n            return { Referral: updatedReferral, earning };\r\n        });\r\n\r\n        // Check for badge achievements\r\n        await this.checkAndAwardBadges(employee.id);\r\n\r\n        return result;\r\n    }\r\n\r\n    // Get earnings history\r\n    async getEarnings(userId: string, filters: EarningsFiltersDto) {\r\n        const employee = await this.prisma.employee.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!employee) {\r\n            throw new NotFoundException('Employee profile not found');\r\n        }\r\n\r\n        const { status, fromDate, toDate, page = 1, limit = 10 } = filters;\r\n\r\n        const where: any = {\r\n            employeeId: employee.id,\r\n        };\r\n\r\n        if (status && status !== 'ALL') {\r\n            where.status = status;\r\n        }\r\n\r\n        if (fromDate) {\r\n            where.createdAt = { ...(where.createdAt || {}), gte: new Date(fromDate) };\r\n        }\r\n\r\n        if (toDate) {\r\n            where.createdAt = { ...(where.createdAt || {}), lte: new Date(toDate) };\r\n        }\r\n\r\n        const [earnings, total, summary] = await Promise.all([\r\n            this.prisma.employeeEarning.findMany({\r\n                where,\r\n                include: {\r\n                    Referral: {\r\n                        include: {\r\n                            JobApplication: {\r\n                                include: {\r\n                                    Candidate: {\r\n                                        select: { firstName: true, lastName: true },\r\n                                    },\r\n                                    Job: {\r\n                                        select: { title: true, companyName: true },\r\n                                    },\r\n                                },\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n                skip: (page - 1) * limit,\r\n                take: limit,\r\n            }),\r\n            this.prisma.employeeEarning.count({ where }),\r\n            this.prisma.employeeEarning.aggregate({\r\n                where: { employeeId: employee.id },\r\n                _sum: { amount: true, bonusAmount: true },\r\n            }),\r\n        ]);\r\n\r\n        // Group by status for summary\r\n        const statusSummary = await this.prisma.employeeEarning.groupBy({\r\n            by: ['status'],\r\n            where: { employeeId: employee.id },\r\n            _sum: { amount: true, bonusAmount: true },\r\n            _count: true,\r\n        });\r\n\r\n        return {\r\n            data: earnings,\r\n            pagination: {\r\n                page,\r\n                limit,\r\n                total,\r\n                totalPages: Math.ceil(total / limit),\r\n            },\r\n            summary: {\r\n                totalAmount:\r\n                    (summary._sum.amount || 0) + (summary._sum.bonusAmount || 0),\r\n                byStatus: statusSummary.reduce(\r\n                    (acc, item) => {\r\n                        acc[item.status] = {\r\n                            count: item._count,\r\n                            amount:\r\n                                (item._sum.amount || 0) + (item._sum.bonusAmount || 0),\r\n                        };\r\n                        return acc;\r\n                    },\r\n                    {} as Record<string, { count: number; amount: number }>\r\n                ),\r\n            },\r\n        };\r\n    }\r\n\r\n    // Get company leaderboard\r\n    async getLeaderboard(userId: string, period: 'month' | 'all' = 'all') {\r\n        const employee = await this.prisma.employee.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!employee) {\r\n            throw new NotFoundException('Employee profile not found');\r\n        }\r\n\r\n        let dateFilter = {};\r\n        if (period === 'month') {\r\n            const startOfMonth = new Date();\r\n            startOfMonth.setDate(1);\r\n            startOfMonth.setHours(0, 0, 0, 0);\r\n            dateFilter = { createdAt: { gte: startOfMonth } };\r\n        }\r\n\r\n        // Get all employees from same company with their referral count\r\n        const employees = await this.prisma.employee.findMany({\r\n            where: {\r\n                companyName: { equals: employee.companyName, mode: 'insensitive' },\r\n                isVerified: true,\r\n            },\r\n            select: {\r\n                id: true,\r\n                userId: true,\r\n                designation: true,\r\n                referralCount: true,\r\n                successfulReferral: true,\r\n                points: true,\r\n                badges: true,\r\n                User: {\r\n                    select: {\r\n                        email: true,\r\n                    },\r\n                },\r\n                Referral: period === 'month'\r\n                    ? {\r\n                        where: dateFilter,\r\n                        select: { id: true },\r\n                    }\r\n                    : undefined,\r\n            },\r\n            orderBy:\r\n                period === 'month'\r\n                    ? undefined\r\n                    : { successfulReferral: 'desc' },\r\n            take: 20,\r\n        });\r\n\r\n        // Sort by month count if monthly\r\n        let leaderboard = employees.map((emp, index) => ({\r\n            rank: index + 1,\r\n            employeeId: emp.id,\r\n            email: emp.user.email.replace(/(.{3}).*@/, '$1***@'), // Partial hide email\r\n            designation: emp.designation,\r\n            referralCount:\r\n                period === 'month'\r\n                    ? emp.referrals?.length || 0\r\n                    : emp.referralCount,\r\n            successfulReferral: emp.successfulReferrals,\r\n            points: emp.points,\r\n            badges: emp.badges,\r\n            isCurrentUser: emp.userId === userId,\r\n        }));\r\n\r\n        if (period === 'month') {\r\n            leaderboard = leaderboard\r\n                .sort((a, b) => (b.referralCount || 0) - (a.referralCount || 0))\r\n                .map((emp, index) => ({ ...emp, rank: index + 1 }));\r\n        }\r\n\r\n        // Find current user's rank if not in top 20\r\n        const currentUserInLeaderboard = leaderboard.find((e) => e.isCurrentUser);\r\n        let currentUserRank: number | null = null;\r\n\r\n        if (!currentUserInLeaderboard) {\r\n            // Calculate rank\r\n            const higherRanked = await this.prisma.employee.count({\r\n                where: {\r\n                    companyName: { equals: employee.companyName, mode: 'insensitive' },\r\n                    successfulReferral: { gt: employee.successfulReferrals },\r\n                },\r\n            });\r\n            currentUserRank = higherRanked + 1;\r\n        }\r\n\r\n        return {\r\n            leaderboard: leaderboard.slice(0, 10),\r\n            currentUserRank: currentUserInLeaderboard?.rank || currentUserRank,\r\n            currentUserStats: {\r\n                referralCount: employee.referralCount,\r\n                successfulReferral: employee.successfulReferrals,\r\n                points: employee.points,\r\n            },\r\n        };\r\n    }\r\n\r\n    // Get current tier\r\n    async getCurrentTier(userId: string) {\r\n        const employee = await this.prisma.employee.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!employee) {\r\n            return null;\r\n        }\r\n\r\n        return this.getCurrentTierInternal(employee.id);\r\n    }\r\n\r\n    private async getCurrentTierInternal(employeeId: string) {\r\n        const employee = await this.prisma.employee.findUnique({\r\n            where: { id: employeeId },\r\n        });\r\n\r\n        if (!employee) {\r\n            return null;\r\n        }\r\n\r\n        const tier = await this.prisma.commissionTier.findFirst({\r\n            where: {\r\n                minReferral: { lte: employee.successfulReferrals },\r\n                isActive: true,\r\n            },\r\n            orderBy: { minReferral: 'desc' },\r\n        });\r\n\r\n        // Get next tier\r\n        const nextTier = await this.prisma.commissionTier.findFirst({\r\n            where: {\r\n                minReferral: { gt: employee.successfulReferrals },\r\n                isActive: true,\r\n            },\r\n            orderBy: { minReferral: 'asc' },\r\n        });\r\n\r\n        return {\r\n            current: tier,\r\n            next: nextTier,\r\n            referralsToNextTier: nextTier\r\n                ? nextTier.minReferrals - employee.successfulReferrals\r\n                : null,\r\n        };\r\n    }\r\n\r\n    // Update employee profile\r\n    async updateProfile(userId: string, dto: UpdateEmployeeProfileDto) {\r\n        const employee = await this.prisma.employee.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!employee) {\r\n            throw new NotFoundException('Employee profile not found');\r\n        }\r\n\r\n        return this.prisma.employee.update({\r\n            where: { id: employee.id },\r\n            data: {\r\n                designation: dto.designation,\r\n                employeeId: dto.employeeId,\r\n                linkedinUrl: dto.linkedinUrl,\r\n            },\r\n        });\r\n    }\r\n\r\n    // Check and award badges\r\n    private async checkAndAwardBadges(employeeId: string) {\r\n        const employee = await this.prisma.employee.findUnique({\r\n            where: { id: employeeId },\r\n        });\r\n\r\n        if (!employee) return;\r\n\r\n        const badges = [...employee.badges];\r\n\r\n        // First referral badge\r\n        if (employee.referralCount === 1 && !badges.includes('first-referral')) {\r\n            badges.push('first-referral');\r\n        }\r\n\r\n        // 5 referrals badge\r\n        if (employee.referralCount >= 5 && !badges.includes('referral-pro')) {\r\n            badges.push('referral-pro');\r\n        }\r\n\r\n        // 10 referrals badge\r\n        if (employee.referralCount >= 10 && !badges.includes('super-referrer')) {\r\n            badges.push('super-referrer');\r\n        }\r\n\r\n        // 25 referrals badge\r\n        if (employee.referralCount >= 25 && !badges.includes('referral-champion')) {\r\n            badges.push('referral-champion');\r\n        }\r\n\r\n        // First successful hire badge\r\n        if (\r\n            employee.successfulReferrals >= 1 &&\r\n            !badges.includes('first-hire')\r\n        ) {\r\n            badges.push('first-hire');\r\n        }\r\n\r\n        // 5 successful hires badge\r\n        if (\r\n            employee.successfulReferrals >= 5 &&\r\n            !badges.includes('hiring-hero')\r\n        ) {\r\n            badges.push('hiring-hero');\r\n        }\r\n\r\n        if (badges.length !== employee.badges.length) {\r\n            await this.prisma.employee.update({\r\n                where: { id: employeeId },\r\n                data: { badges },\r\n            });\r\n        }\r\n    }\r\n\r\n    // Mark referral as hired (called by HR/Admin)\r\n    async markReferralAsHired(referralId: string) {\r\n        const referral = await this.prisma.referral.findUnique({\r\n            where: { id: referralId },\r\n            include: {\r\n                earning: true,\r\n                Employee: true,\r\n            },\r\n        });\r\n\r\n        if (!referral) {\r\n            throw new NotFoundException('Referral not found');\r\n        }\r\n\r\n        if (referral.status !== ReferralStatus.CONFIRMED) {\r\n            throw new BadRequestException('Referral must be confirmed first');\r\n        }\r\n\r\n        return this.prisma.$transaction(async (tx) => {\r\n            // Update referral status\r\n            await tx.referral.update({\r\n                where: { id: referralId },\r\n                data: {\r\n                    status: ReferralStatus.CLOSED,\r\n                    closedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Update earning to eligible\r\n            if (referral.EmployeeEarning) {\r\n                await tx.employeeEarning.update({\r\n                    where: { id: referral.employeeEarning.id },\r\n                    data: { status: EarningStatus.ELIGIBLE },\r\n                });\r\n            }\r\n\r\n            // Update employee stats\r\n            if (referral.employeeId) {\r\n                await tx.employee.update({\r\n                    where: { id: referral.employeeId },\r\n                    data: {\r\n                        successfulReferral: { increment: 1 },\r\n                        points: { increment: 50 }, // Bonus points for successful hire\r\n                    },\r\n                });\r\n\r\n                // Check for badges\r\n                await this.checkAndAwardBadges(referral.employeeId);\r\n            }\r\n\r\n            return { success: true };\r\n        });\r\n    }\r\n\r\n    // Get notifications for employee\r\n    async getNotifications(userId: string, limit = 10) {\r\n        return this.prisma.notification.findMany({\r\n            where: { userId },\r\n            orderBy: { createdAt: 'desc' },\r\n            take: limit,\r\n        });\r\n    }\r\n\r\n    // Mark notification as read\r\n    async markNotificationRead(userId: string, notificationId: string) {\r\n        const notification = await this.prisma.notification.findFirst({\r\n            where: { id: notificationId, userId },\r\n        });\r\n\r\n        if (!notification) {\r\n            throw new NotFoundException('Notification not found');\r\n        }\r\n\r\n        return this.prisma.notification.update({\r\n            where: { id: notificationId },\r\n            data: { isRead: true, readAt: new Date() },\r\n        });\r\n    }\r\n}\r\n"],"names":["EmployeeService","getOrCreateEmployee","userId","employee","prisma","findUnique","where","include","User","select","email","phone","emailVerified","phoneVerified","lastLoginAt","role","user","id","create","data","companyName","split","companyEmail","isVerified","getProfile","NotFoundException","tier","getCurrentTier","Employee","currentTier","getDashboardStats","referralStats","referral","groupBy","by","employeeId","_count","earningsStats","employeeEarning","aggregate","_sum","amount","bonusAmount","paidEarnings","status","EarningStatus","PAID","pendingEarnings","in","PENDING","ELIGIBLE","availableReferrals","count","ReferralStatus","type","ReferralType","JobApplication","Job","equals","mode","startOfMonth","Date","setDate","setHours","thisMonthReferrals","createdAt","gte","totalReferral","referralCount","successfulReferral","successfulReferrals","pendingReferral","find","s","confirmedReferral","CONFIRMED","totalEarnings","points","badges","getAvailableReferrals","search","ForbiddenException","referrals","findMany","OR","Candidate","firstName","contains","lastName","title","headline","totalExperience","currentCompany","JobSkill","name","level","location","referralFee","TestSession","isPassed","score","take","orderBy","commissionRate","current","commissionPercent","bonusPerReferral","map","ref","potentialEarning","application","job","candidateTestScore","testSessions","getMyReferrals","filters","fromDate","toDate","page","limit","lte","total","Promise","all","earning","paidAt","skip","pagination","totalPages","Math","ceil","confirmReferral","applicationId","BadRequestException","toLowerCase","getCurrentTierInternal","earningAmount","result","$transaction","tx","updatedReferral","update","confirmedAt","expiresAt","now","jobApplication","ApplicationStatus","APPLIED","referralId","tierName","increment","Referral","checkAndAwardBadges","getEarnings","earnings","summary","statusSummary","totalAmount","byStatus","reduce","acc","item","getLeaderboard","period","dateFilter","employees","designation","undefined","leaderboard","emp","index","rank","replace","length","isCurrentUser","sort","a","b","currentUserInLeaderboard","e","currentUserRank","higherRanked","gt","slice","currentUserStats","commissionTier","findFirst","minReferral","isActive","nextTier","next","referralsToNextTier","minReferrals","updateProfile","dto","linkedinUrl","includes","push","markReferralAsHired","CLOSED","closedAt","EmployeeEarning","success","getNotifications","notification","markNotificationRead","notificationId","isRead","readAt"],"mappings":"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"}