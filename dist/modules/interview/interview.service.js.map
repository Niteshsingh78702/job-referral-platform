{"version":3,"sources":["../../../src/modules/interview/interview.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    NotFoundException,\r\n    BadRequestException,\r\n    ForbiddenException,\r\n} from '@nestjs/common';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { EmailService } from '../email/email.service';\r\nimport { ConfirmInterviewDto } from './dto';\r\nimport {\r\n    InterviewStatus,\r\n    InterviewMode,\r\n    PaymentStatus,\r\n    AuditAction,\r\n    ApplicationStatus,\r\n} from '../../common/constants';\r\n\r\n@Injectable()\r\nexport class InterviewService {\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private emailService: EmailService,\r\n    ) { }\r\n\r\n    /**\r\n     * HR confirms an interview with scheduling details.\r\n     * NEW FLOW: HR sets date/time/mode upfront, then candidate pays to unlock.\r\n     * Creates Interview record with INTERVIEW_CONFIRMED status.\r\n     * Updates application status to INTERVIEW_CONFIRMED.\r\n     */\r\n    async confirmInterview(userId: string, applicationId: string, dto: ConfirmInterviewDto) {\r\n        // Verify HR owns the job for this application\r\n        const application = await this.prisma.jobApplication.findUnique({\r\n            where: { id: applicationId },\r\n            include: {\r\n                Job: { include: { HR: true } },\r\n                Candidate: { include: { User: true } },\r\n            },\r\n        });\r\n\r\n        if (!application) {\r\n            throw new NotFoundException('Application not found');\r\n        }\r\n\r\n        // Verify application is in APPLIED status (test passed)\r\n        if (application.status !== ApplicationStatus.APPLIED) {\r\n            throw new BadRequestException(\r\n                `Cannot confirm interview. Application status is ${application.status}. Expected APPLIED (test passed).`\r\n            );\r\n        }\r\n\r\n        // Check if HR owns this job\r\n        const hr = await this.prisma.hR.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!hr || application.Job.hrId !== hr.id) {\r\n            throw new ForbiddenException('You can only confirm interviews for your own job applications');\r\n        }\r\n\r\n        // Check if interview already exists\r\n        const existingInterview = await this.prisma.interview.findUnique({\r\n            where: { applicationId }\r\n        });\r\n\r\n        if (existingInterview) {\r\n            throw new BadRequestException('Interview already confirmed for this application. Contact admin to modify.');\r\n        }\r\n\r\n        // Create interview with scheduling details and update application status\r\n        const interview = await this.prisma.$transaction(async (tx) => {\r\n            // Create interview record - shortlisting action\r\n            // scheduledDate/Time will be set AFTER payment via scheduleInterview\r\n            const newInterview = await tx.interview.create({\r\n                data: {\r\n                    id: crypto.randomUUID(), // Generate unique id\r\n                    applicationId,\r\n                    mode: dto.mode as any,\r\n                    scheduledDate: dto.scheduledDate ? new Date(dto.scheduledDate) : null, // Optional - set after payment\r\n                    scheduledTime: dto.scheduledTime || null, // Optional - set after payment\r\n                    hrNotes: dto.hrNote,\r\n                    status: InterviewStatus.INTERVIEW_CONFIRMED as any,\r\n                    paymentStatus: PaymentStatus.ELIGIBLE as any,\r\n                    scheduledAt: null, // Will be set when HR schedules after payment\r\n                    updatedAt: new Date(), // Required field without default\r\n                },\r\n            });\r\n\r\n            // Update application status to INTERVIEW_CONFIRMED\r\n            await tx.jobApplication.update({\r\n                where: { id: applicationId },\r\n                data: { status: ApplicationStatus.INTERVIEW_CONFIRMED as any },\r\n            });\r\n\r\n            // Create audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId,\r\n                    action: AuditAction.CREATE,\r\n                    entityType: 'Interview',\r\n                    entityId: newInterview.id,\r\n                    newValue: {\r\n                        mode: dto.mode,\r\n                        scheduledDate: dto.scheduledDate,\r\n                        scheduledTime: dto.scheduledTime,\r\n                        applicationId,\r\n                        status: InterviewStatus.INTERVIEW_CONFIRMED,\r\n                    },\r\n                },\r\n            });\r\n\r\n            return newInterview;\r\n        });\r\n\r\n        // Send notification email to candidate - \"Pay ‚Çπ99 to unlock details\"\r\n        await this.sendInterviewConfirmedEmail(application, dto);\r\n\r\n        return {\r\n            message: 'Interview confirmed successfully. Candidate will be notified to make payment.',\r\n            interview: {\r\n                id: interview.id,\r\n                mode: interview.mode,\r\n                status: interview.status,\r\n                scheduledDate: interview.scheduledDate,\r\n                scheduledTime: interview.scheduledTime,\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * HR schedules interview after candidate has paid.\r\n     * Updates interview with date, time, meeting link, and details.\r\n     */\r\n    async scheduleInterview(\r\n        userId: string,\r\n        interviewId: string,\r\n        dto: { scheduledDate: string; scheduledTime: string; mode?: string; interviewLink?: string; callDetails?: string },\r\n    ) {\r\n        // Get HR record\r\n        const hr = await this.prisma.hR.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!hr) {\r\n            throw new NotFoundException('HR profile not found');\r\n        }\r\n\r\n        // Get interview and verify ownership\r\n        const interview = await this.prisma.interview.findUnique({\r\n            where: { id: interviewId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Job: true,\r\n                        Candidate: {\r\n                            include: {\r\n                                User: true,\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!interview) {\r\n            throw new NotFoundException('Interview not found');\r\n        }\r\n\r\n        // Verify HR owns this job\r\n        if (interview.JobApplication.Job.hrId !== hr.id) {\r\n            throw new ForbiddenException('You do not have permission to schedule this interview');\r\n        }\r\n\r\n        // Verify payment was successful\r\n        if (interview.paymentStatus !== 'SUCCESS' && interview.status !== 'PAYMENT_SUCCESS') {\r\n            throw new BadRequestException('Cannot schedule interview - payment not received');\r\n        }\r\n\r\n        // Update interview with schedule details\r\n        const updatedInterview = await this.prisma.interview.update({\r\n            where: { id: interviewId },\r\n            data: {\r\n                scheduledDate: new Date(dto.scheduledDate),\r\n                scheduledTime: dto.scheduledTime,\r\n                mode: dto.mode || interview.mode, // Update mode if provided\r\n                interviewLink: dto.interviewLink || null,\r\n                callDetails: dto.callDetails || null,\r\n                scheduledAt: new Date(),\r\n                updatedAt: new Date(),\r\n            },\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            message: 'Interview scheduled successfully. Candidate has been notified.',\r\n            interview: {\r\n                id: updatedInterview.id,\r\n                scheduledDate: updatedInterview.scheduledDate,\r\n                scheduledTime: updatedInterview.scheduledTime,\r\n                interviewLink: updatedInterview.interviewLink,\r\n                callDetails: updatedInterview.callDetails,\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Process successful payment - called by payment service.\r\n     * Transitions interview from INTERVIEW_CONFIRMED to PAYMENT_SUCCESS.\r\n     * Now candidate can see interview details.\r\n     */\r\n    async processPaymentSuccess(applicationId: string, paymentId: string) {\r\n        const interview = await this.prisma.interview.findUnique({\r\n            where: { applicationId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Job: { include: { HR: { include: { User: true } } } },\r\n                        Candidate: { include: { User: true } },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!interview) {\r\n            throw new NotFoundException('Interview not found for this application');\r\n        }\r\n\r\n        if (interview.status !== InterviewStatus.INTERVIEW_CONFIRMED) {\r\n            throw new BadRequestException(\r\n                `Interview is in ${interview.status} status. Expected INTERVIEW_CONFIRMED.`\r\n            );\r\n        }\r\n\r\n        // Update interview and application status\r\n        const updatedInterview = await this.prisma.$transaction(async (tx) => {\r\n            const updated = await tx.interview.update({\r\n                where: { id: interview.id },\r\n                data: {\r\n                    status: InterviewStatus.PAYMENT_SUCCESS as any,\r\n                    paymentStatus: PaymentStatus.SUCCESS as any,\r\n                    paidAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Update application status\r\n            await tx.jobApplication.update({\r\n                where: { id: applicationId },\r\n                data: { status: ApplicationStatus.PAYMENT_SUCCESS as any },\r\n            });\r\n\r\n            return updated;\r\n        });\r\n\r\n        // Send confirmation email to candidate with interview details\r\n        await this.sendPaymentSuccessEmail(interview);\r\n\r\n        // Notify HR that candidate has paid\r\n        await this.sendPaymentNotificationToHR(interview);\r\n\r\n        return updatedInterview;\r\n    }\r\n\r\n    /**\r\n     * Get interview details for candidate.\r\n     * CRITICAL: Only return interview details if payment is successful.\r\n     */\r\n    async getInterviewForCandidate(userId: string, interviewId: string) {\r\n        const candidate = await this.prisma.candidate.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!candidate) {\r\n            throw new NotFoundException('Candidate profile not found');\r\n        }\r\n\r\n        const interview = await this.prisma.interview.findUnique({\r\n            where: { id: interviewId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Job: {\r\n                            select: {\r\n                                id: true,\r\n                                title: true,\r\n                                companyName: true,\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!interview) {\r\n            throw new NotFoundException('Interview not found');\r\n        }\r\n\r\n        // Verify candidate owns this interview's application\r\n        if (interview.JobApplication.candidateId !== candidate.id) {\r\n            throw new ForbiddenException('You can only view your own interviews');\r\n        }\r\n\r\n        // Base response (always visible)\r\n        const baseResponse = {\r\n            id: interview.id,\r\n            mode: interview.mode,\r\n            status: interview.status,\r\n            paymentStatus: interview.paymentStatus,\r\n            job: interview.JobApplication.Job,\r\n            createdAt: interview.createdAt,\r\n        };\r\n\r\n        // Return filtered data based on status\r\n        switch (interview.status) {\r\n            case InterviewStatus.INTERVIEW_CONFIRMED:\r\n                // Interview confirmed but not paid - show payment CTA\r\n                return {\r\n                    ...baseResponse,\r\n                    message: 'HR has scheduled your interview. Pay ‚Çπ99 to unlock details.',\r\n                    requiresPayment: true,\r\n                };\r\n\r\n            case InterviewStatus.PAYMENT_SUCCESS:\r\n            case InterviewStatus.INTERVIEW_COMPLETED:\r\n                // Payment done - show full details\r\n                return {\r\n                    ...baseResponse,\r\n                    scheduledDate: interview.scheduledDate,\r\n                    scheduledTime: interview.scheduledTime,\r\n                    hrNote: interview.hrNotes,\r\n                    paidAt: interview.paidAt,\r\n                    message: interview.status === InterviewStatus.PAYMENT_SUCCESS\r\n                        ? 'Interview details unlocked. Best of luck!'\r\n                        : 'Interview completed.',\r\n                };\r\n\r\n            case InterviewStatus.CANDIDATE_NO_SHOW:\r\n                return {\r\n                    ...baseResponse,\r\n                    message: 'You missed this interview. Contact support for assistance.',\r\n                };\r\n\r\n            case InterviewStatus.HR_NO_SHOW:\r\n                return {\r\n                    ...baseResponse,\r\n                    message: 'HR did not conduct this interview. A refund has been initiated.',\r\n                };\r\n\r\n            case InterviewStatus.CANCELLED:\r\n                return {\r\n                    ...baseResponse,\r\n                    message: 'This interview was cancelled.',\r\n                };\r\n\r\n            default:\r\n                return baseResponse;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all interviews for candidate\r\n     */\r\n    async getCandidateInterviews(userId: string) {\r\n        const candidate = await this.prisma.candidate.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!candidate) {\r\n            throw new NotFoundException('Candidate profile not found');\r\n        }\r\n\r\n        const interviews = await this.prisma.interview.findMany({\r\n            where: {\r\n                JobApplication: {\r\n                    candidateId: candidate.id,\r\n                },\r\n            },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Job: {\r\n                            select: {\r\n                                id: true,\r\n                                title: true,\r\n                                companyName: true,\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n            orderBy: { createdAt: 'desc' },\r\n        });\r\n\r\n        // Filter sensitive data based on payment status\r\n        return interviews.map((interview) => {\r\n            const base = {\r\n                id: interview.id,\r\n                mode: interview.mode,\r\n                status: interview.status,\r\n                paymentStatus: interview.paymentStatus,\r\n                job: interview.JobApplication.Job,\r\n                createdAt: interview.createdAt,\r\n                paidAt: interview.paidAt,\r\n            };\r\n\r\n            // Only show interview details if payment successful\r\n            if (interview.status === InterviewStatus.PAYMENT_SUCCESS ||\r\n                interview.status === InterviewStatus.INTERVIEW_COMPLETED) {\r\n                return {\r\n                    ...base,\r\n                    scheduledDate: interview.scheduledDate,\r\n                    scheduledTime: interview.scheduledTime,\r\n                    hrNote: interview.hrNotes,\r\n                };\r\n            }\r\n\r\n            return {\r\n                ...base,\r\n                requiresPayment: interview.status === InterviewStatus.INTERVIEW_CONFIRMED,\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get interviews for HR's jobs (shows all details to HR)\r\n     */\r\n    async getHRInterviews(userId: string, filters?: { status?: string; jobId?: string }) {\r\n        const hr = await this.prisma.hR.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!hr) {\r\n            throw new NotFoundException('HR profile not found');\r\n        }\r\n\r\n        const where: any = {\r\n            JobApplication: {\r\n                Job: {\r\n                    hrId: hr.id,\r\n                },\r\n            },\r\n        };\r\n\r\n        if (filters?.status) {\r\n            where.status = filters.status;\r\n        }\r\n\r\n        if (filters?.jobId) {\r\n            where.JobApplication = {\r\n                ...where.JobApplication,\r\n                jobId: filters.jobId,\r\n            };\r\n        }\r\n\r\n        const interviews = await this.prisma.interview.findMany({\r\n            where,\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Candidate: {\r\n                            select: {\r\n                                id: true,\r\n                                firstName: true,\r\n                                lastName: true,\r\n                                User: {\r\n                                    select: {\r\n                                        email: true,\r\n                                    },\r\n                                },\r\n                            },\r\n                        },\r\n                        Job: {\r\n                            select: {\r\n                                id: true,\r\n                                title: true,\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n            orderBy: { createdAt: 'desc' },\r\n        });\r\n\r\n        return interviews;\r\n    }\r\n\r\n    // ===========================================\r\n    // ADMIN METHODS\r\n    // ===========================================\r\n\r\n    /**\r\n     * Get interview statistics for admin\r\n     */\r\n    async getAdminInterviewStats() {\r\n        const [total, confirmed, paymentSuccess, completed, candidateNoShow, hrNoShow] = await Promise.all([\r\n            this.prisma.interview.count(),\r\n            this.prisma.interview.count({ where: { status: InterviewStatus.INTERVIEW_CONFIRMED as any } }),\r\n            this.prisma.interview.count({ where: { status: InterviewStatus.PAYMENT_SUCCESS as any } }),\r\n            this.prisma.interview.count({ where: { status: InterviewStatus.INTERVIEW_COMPLETED as any } }),\r\n            this.prisma.interview.count({ where: { status: InterviewStatus.CANDIDATE_NO_SHOW as any } }),\r\n            this.prisma.interview.count({ where: { status: InterviewStatus.HR_NO_SHOW as any } }),\r\n        ]);\r\n\r\n        // Get HRs with repeated confirmations without candidate payments (potential flag)\r\n        const flaggedHRs = await this.prisma.$queryRaw`\r\n            SELECT h.\"companyName\", h.\"userId\", COUNT(*) as pending_count\r\n            FROM \"Interview\" i\r\n            JOIN \"JobApplication\" ja ON ja.id = i.\"applicationId\"\r\n            JOIN \"Job\" j ON j.id = ja.\"jobId\"\r\n            JOIN \"HR\" h ON h.id = j.\"hrId\"\r\n            WHERE i.status = 'INTERVIEW_CONFIRMED'\r\n            AND i.\"scheduledAt\" < NOW() - INTERVAL '48 hours'\r\n            GROUP BY h.id\r\n            HAVING COUNT(*) > 2\r\n        `;\r\n\r\n        return {\r\n            total,\r\n            byStatus: {\r\n                confirmed,\r\n                paymentSuccess,\r\n                completed,\r\n                candidateNoShow,\r\n                hrNoShow,\r\n            },\r\n            flaggedHRs,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get all interviews for admin with pagination\r\n     */\r\n    async getAdminInterviews(page: number = 1, limit: number = 20, status?: string) {\r\n        const skip = (page - 1) * limit;\r\n        const where: any = {};\r\n\r\n        if (status) {\r\n            where.status = status;\r\n        }\r\n\r\n        const [interviews, total] = await Promise.all([\r\n            this.prisma.interview.findMany({\r\n                where,\r\n                skip,\r\n                take: limit,\r\n                include: {\r\n                    JobApplication: {\r\n                        include: {\r\n                            Candidate: {\r\n                                select: {\r\n                                    firstName: true,\r\n                                    lastName: true,\r\n                                },\r\n                            },\r\n                            Job: {\r\n                                select: {\r\n                                    title: true,\r\n                                    companyName: true,\r\n                                    HR: {\r\n                                        select: {\r\n                                            companyName: true,\r\n                                        },\r\n                                    },\r\n                                },\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n            }),\r\n            this.prisma.interview.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            interviews,\r\n            pagination: {\r\n                page,\r\n                limit,\r\n                total,\r\n                totalPages: Math.ceil(total / limit),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Admin marks an interview as no-show\r\n     */\r\n    async markNoShow(interviewId: string, type: 'CANDIDATE' | 'HR', adminUserId: string) {\r\n        const interview = await this.prisma.interview.findUnique({\r\n            where: { id: interviewId },\r\n        });\r\n\r\n        if (!interview) {\r\n            throw new NotFoundException('Interview not found');\r\n        }\r\n\r\n        const newStatus = type === 'CANDIDATE'\r\n            ? InterviewStatus.CANDIDATE_NO_SHOW\r\n            : InterviewStatus.HR_NO_SHOW;\r\n\r\n        const updatedInterview = await this.prisma.$transaction(async (tx) => {\r\n            const updated = await tx.interview.update({\r\n                where: { id: interviewId },\r\n                data: {\r\n                    status: newStatus as any,\r\n                    completedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Update application status\r\n            await tx.jobApplication.update({\r\n                where: { id: interview.applicationId },\r\n                data: {\r\n                    status: (type === 'CANDIDATE'\r\n                        ? ApplicationStatus.CANDIDATE_NO_SHOW\r\n                        : ApplicationStatus.HR_NO_SHOW) as any\r\n                },\r\n            });\r\n\r\n            // Create audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: adminUserId,\r\n                    action: AuditAction.ADMIN_OVERRIDE,\r\n                    entityType: 'Interview',\r\n                    entityId: interviewId,\r\n                    oldValue: { status: interview.status },\r\n                    newValue: { status: newStatus, reason: `${type}_NO_SHOW` },\r\n                },\r\n            });\r\n\r\n            return updated;\r\n        });\r\n\r\n        return {\r\n            message: `Interview marked as ${type} no-show`,\r\n            interview: updatedInterview,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Admin marks interview as completed\r\n     */\r\n    async markCompleted(interviewId: string, adminUserId: string) {\r\n        const interview = await this.prisma.interview.findUnique({\r\n            where: { id: interviewId },\r\n        });\r\n\r\n        if (!interview) {\r\n            throw new NotFoundException('Interview not found');\r\n        }\r\n\r\n        if (interview.status !== InterviewStatus.PAYMENT_SUCCESS) {\r\n            throw new BadRequestException('Can only mark PAYMENT_SUCCESS interviews as completed');\r\n        }\r\n\r\n        const updatedInterview = await this.prisma.$transaction(async (tx) => {\r\n            const updated = await tx.interview.update({\r\n                where: { id: interviewId },\r\n                data: {\r\n                    status: InterviewStatus.INTERVIEW_COMPLETED as any,\r\n                    completedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Update application status\r\n            await tx.jobApplication.update({\r\n                where: { id: interview.applicationId },\r\n                data: { status: ApplicationStatus.INTERVIEW_COMPLETED as any },\r\n            });\r\n\r\n            // Create audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId: adminUserId,\r\n                    action: AuditAction.UPDATE,\r\n                    entityType: 'Interview',\r\n                    entityId: interviewId,\r\n                    oldValue: { status: interview.status },\r\n                    newValue: { status: InterviewStatus.INTERVIEW_COMPLETED },\r\n                },\r\n            });\r\n\r\n            return updated;\r\n        });\r\n\r\n        return {\r\n            message: 'Interview marked as completed',\r\n            interview: updatedInterview,\r\n        };\r\n    }\r\n\r\n    // HR marks interview outcome (Selected/Not Selected/No Show)\r\n    async markInterviewOutcome(\r\n        userId: string,\r\n        interviewId: string,\r\n        dto: { outcome: 'SELECTED' | 'NOT_SELECTED' | 'CANDIDATE_NO_SHOW'; notes?: string; applicationId?: string }\r\n    ) {\r\n        // Verify HR owns this interview\r\n        const hr = await this.prisma.hR.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!hr) {\r\n            throw new NotFoundException('HR profile not found');\r\n        }\r\n\r\n        const interview = await this.prisma.interview.findUnique({\r\n            where: { id: interviewId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Job: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!interview) {\r\n            throw new NotFoundException('Interview not found');\r\n        }\r\n\r\n        if (interview.JobApplication.Job.hrId !== hr.id) {\r\n            throw new ForbiddenException('You do not have access to this interview');\r\n        }\r\n\r\n        // Map outcome to interview status (must be valid InterviewStatus enum values)\r\n        // SELECTED and NOT_SELECTED both mean the interview is completed\r\n        const statusMap: Record<string, string> = {\r\n            'SELECTED': 'INTERVIEW_COMPLETED',\r\n            'NOT_SELECTED': 'INTERVIEW_COMPLETED',\r\n            'CANDIDATE_NO_SHOW': 'CANDIDATE_NO_SHOW',\r\n        };\r\n\r\n        // Map outcome to application status\r\n        const applicationStatusMap: Record<string, string> = {\r\n            'SELECTED': 'INTERVIEW_COMPLETED',  // or could add SELECTED to ApplicationStatus enum\r\n            'NOT_SELECTED': 'REJECTED',\r\n            'CANDIDATE_NO_SHOW': 'CANDIDATE_NO_SHOW',\r\n        };\r\n\r\n        const newStatus = statusMap[dto.outcome] || 'INTERVIEW_COMPLETED';\r\n        const newAppStatus = applicationStatusMap[dto.outcome] || 'INTERVIEW_COMPLETED';\r\n\r\n        // Update interview and application in transaction\r\n        const updatedInterview = await this.prisma.$transaction(async (tx) => {\r\n            // Update interview status\r\n            const updated = await tx.interview.update({\r\n                where: { id: interviewId },\r\n                data: {\r\n                    status: newStatus as any,\r\n                    updatedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Update application status\r\n            await tx.jobApplication.update({\r\n                where: { id: interview.applicationId },\r\n                data: {\r\n                    status: newAppStatus as any,\r\n                    updatedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            return updated;\r\n        });\r\n\r\n        return {\r\n            message: `Interview marked as ${dto.outcome.replace(/_/g, ' ')}`,\r\n            interview: updatedInterview,\r\n            applicationStatus: newAppStatus,\r\n        };\r\n    }\r\n\r\n    // ===========================================\r\n    // Email Helper Methods\r\n    // ============================================\r\n\r\n    private async sendInterviewConfirmedEmail(application: any, dto: ConfirmInterviewDto) {\r\n        const candidateEmail = application.candidate.user.email;\r\n        const candidateName = `${application.candidate.firstName} ${application.candidate.lastName}`;\r\n        const companyName = application.job.companyName;\r\n        const jobTitle = application.job.title;\r\n\r\n        const html = `\r\n            <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n                <h2 style=\"color: #2563eb;\">üéâ Great News, ${candidateName}!</h2>\r\n                <p>The HR team at <strong>${companyName}</strong> has scheduled an interview for you!</p>\r\n                <div style=\"background: #f3f4f6; padding: 16px; border-radius: 8px; margin: 16px 0;\">\r\n                    <h3 style=\"margin: 0 0 8px 0;\">${jobTitle}</h3>\r\n                    <p style=\"margin: 0; color: #6b7280;\">${companyName}</p>\r\n                </div>\r\n                <div style=\"background: #fef3c7; padding: 16px; border-radius: 8px; margin: 16px 0; border-left: 4px solid #f59e0b;\">\r\n                    <p style=\"margin: 0; font-weight: 500;\">\r\n                        <strong>Next Step:</strong> Pay ‚Çπ99 to unlock your interview details.\r\n                    </p>\r\n                </div>\r\n                <p style=\"color: #6b7280; font-size: 14px;\">\r\n                    This small fee ensures quality connections and shows your commitment to the opportunity.\r\n                    Your interview details will be revealed immediately after payment.\r\n                </p>\r\n                <a href=\"${process.env.FRONTEND_URL || 'http://localhost:3000'}#my-applications\" \r\n                   style=\"display: inline-block; background: #2563eb; color: white; padding: 12px 24px; \r\n                          border-radius: 6px; text-decoration: none; margin-top: 16px;\">\r\n                    Pay ‚Çπ99 & Unlock Details\r\n                </a>\r\n            </div>\r\n        `;\r\n\r\n        await this.emailService.sendEmail({\r\n            to: candidateEmail,\r\n            subject: `üéâ Interview Scheduled by ${companyName} - Pay ‚Çπ99 to Unlock Details`,\r\n            html,\r\n        });\r\n    }\r\n\r\n    private async sendPaymentSuccessEmail(interview: any) {\r\n        const candidateEmail = interview.application.candidate.user.email;\r\n        const candidateName = `${interview.application.candidate.firstName} ${interview.application.candidate.lastName}`;\r\n        const companyName = interview.application.job.companyName;\r\n        const jobTitle = interview.application.job.title;\r\n\r\n        const modeText = {\r\n            CALL: 'üìû Phone Call',\r\n            VIDEO: 'üíª Video Call',\r\n            ONSITE: 'üè¢ On-site',\r\n        }[interview.mode] || interview.mode;\r\n\r\n        const html = `\r\n            <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n                <h2 style=\"color: #059669;\">‚úÖ Interview Details Unlocked!</h2>\r\n                <p>Hi ${candidateName},</p>\r\n                <p>Your payment is confirmed. Here are your interview details:</p>\r\n                <div style=\"background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 16px 0;\">\r\n                    <h3 style=\"margin: 0 0 12px 0;\">${jobTitle}</h3>\r\n                    <p style=\"margin: 4px 0;\"><strong>Company:</strong> ${companyName}</p>\r\n                    <p style=\"margin: 4px 0;\"><strong>Date:</strong> ${new Date(interview.scheduledDate).toLocaleDateString('en-IN', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</p>\r\n                    <p style=\"margin: 4px 0;\"><strong>Time:</strong> ${interview.scheduledTime}</p>\r\n                    <p style=\"margin: 4px 0;\"><strong>Mode:</strong> ${modeText}</p>\r\n                    ${interview.hrNotes ? `<p style=\"margin: 12px 0 0 0; padding-top: 12px; border-top: 1px solid #ddd;\"><strong>Note from HR:</strong> ${interview.hrNotes}</p>` : ''}\r\n                </div>\r\n                <p style=\"color: #059669; font-weight: 500;\">Best of luck with your interview! üçÄ</p>\r\n            </div>\r\n        `;\r\n\r\n        await this.emailService.sendEmail({\r\n            to: candidateEmail,\r\n            subject: `‚úÖ Interview Details Unlocked - ${jobTitle} at ${companyName}`,\r\n            html,\r\n        });\r\n    }\r\n\r\n    private async sendPaymentNotificationToHR(interview: any) {\r\n        const hrEmail = interview.application.job.hr.user.email;\r\n        const candidateName = `${interview.application.candidate.firstName} ${interview.application.candidate.lastName}`;\r\n        const jobTitle = interview.application.job.title;\r\n\r\n        const html = `\r\n            <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n                <h2 style=\"color: #059669;\">‚úÖ Candidate Has Confirmed</h2>\r\n                <p><strong>${candidateName}</strong> has paid and confirmed their interview for:</p>\r\n                <div style=\"background: #f3f4f6; padding: 16px; border-radius: 8px; margin: 16px 0;\">\r\n                    <h3 style=\"margin: 0 0 8px 0;\">${jobTitle}</h3>\r\n                    <p style=\"margin: 4px 0;\"><strong>Date:</strong> ${new Date(interview.scheduledDate).toLocaleDateString()}</p>\r\n                    <p style=\"margin: 4px 0;\"><strong>Time:</strong> ${interview.scheduledTime}</p>\r\n                    <p style=\"margin: 4px 0;\"><strong>Mode:</strong> ${interview.mode}</p>\r\n                </div>\r\n                <p>The candidate has been sent the interview details. Please be prepared for the interview.</p>\r\n            </div>\r\n        `;\r\n\r\n        await this.emailService.sendEmail({\r\n            to: hrEmail,\r\n            subject: `‚úÖ ${candidateName} Confirmed Interview for ${jobTitle}`,\r\n            html,\r\n        });\r\n    }\r\n}\r\n\r\n\r\n"],"names":["InterviewService","confirmInterview","userId","applicationId","dto","application","prisma","jobApplication","findUnique","where","id","include","Job","HR","Candidate","User","NotFoundException","status","ApplicationStatus","APPLIED","BadRequestException","hr","hR","hrId","ForbiddenException","existingInterview","interview","$transaction","tx","newInterview","create","data","crypto","randomUUID","mode","scheduledDate","Date","scheduledTime","hrNotes","hrNote","InterviewStatus","INTERVIEW_CONFIRMED","paymentStatus","PaymentStatus","ELIGIBLE","scheduledAt","updatedAt","update","auditLog","action","AuditAction","CREATE","entityType","entityId","newValue","sendInterviewConfirmedEmail","message","scheduleInterview","interviewId","JobApplication","updatedInterview","interviewLink","callDetails","success","processPaymentSuccess","paymentId","updated","PAYMENT_SUCCESS","SUCCESS","paidAt","sendPaymentSuccessEmail","sendPaymentNotificationToHR","getInterviewForCandidate","candidate","select","title","companyName","candidateId","baseResponse","job","createdAt","requiresPayment","INTERVIEW_COMPLETED","CANDIDATE_NO_SHOW","HR_NO_SHOW","CANCELLED","getCandidateInterviews","interviews","findMany","orderBy","map","base","getHRInterviews","filters","jobId","firstName","lastName","email","getAdminInterviewStats","total","confirmed","paymentSuccess","completed","candidateNoShow","hrNoShow","Promise","all","count","flaggedHRs","$queryRaw","byStatus","getAdminInterviews","page","limit","skip","take","pagination","totalPages","Math","ceil","markNoShow","type","adminUserId","newStatus","completedAt","ADMIN_OVERRIDE","oldValue","reason","markCompleted","UPDATE","markInterviewOutcome","statusMap","applicationStatusMap","outcome","newAppStatus","replace","applicationStatus","candidateEmail","user","candidateName","jobTitle","html","process","env","FRONTEND_URL","emailService","sendEmail","to","subject","modeText","CALL","VIDEO","ONSITE","toLocaleDateString","weekday","year","month","day","hrEmail"],"mappings":"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"}