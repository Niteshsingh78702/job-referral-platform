{"version":3,"sources":["../../../src/modules/job/job.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    NotFoundException,\r\n    BadRequestException,\r\n    ForbiddenException,\r\n} from '@nestjs/common';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { CreateJobDto, UpdateJobDto, ApplyJobDto, JobQueryDto } from './dto';\r\nimport {\r\n    JobStatus,\r\n    ApplicationStatus,\r\n    UserRole,\r\n} from '../../common/constants';\r\nimport { SkillBucketService } from '../skill-bucket/skill-bucket.service';\r\nimport { SkillTestStatusDto } from '../skill-bucket/dto';\r\n\r\n@Injectable()\r\nexport class JobService {\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private skillBucketService: SkillBucketService,\r\n    ) { }\r\n\r\n    // Create job\r\n    async createJob(hrId: string, dto: CreateJobDto) {\r\n        // Verify HR exists and is approved\r\n        const hr = await this.prisma.hR.findUnique({\r\n            where: { userId: hrId },\r\n        });\r\n\r\n        if (!hr) {\r\n            throw new NotFoundException('HR profile not found');\r\n        }\r\n\r\n        if (hr.approvalStatus !== 'APPROVED') {\r\n            throw new ForbiddenException('HR account not yet approved');\r\n        }\r\n\r\n        // Generate SEO-friendly slug\r\n        const slug = this.generateSlug(dto.title, dto.companyName);\r\n\r\n        // Create job with skills\r\n        const job = await this.prisma.$transaction(async (tx) => {\r\n            const newJob = await tx.job.create({\r\n                data: {\r\n                    slug,\r\n                    title: dto.title,\r\n                    description: dto.description,\r\n                    requirements: dto.requirements,\r\n                    responsibilities: dto.responsibilities,\r\n                    companyName: dto.companyName,\r\n                    companyLogo: dto.companyLogo,\r\n                    location: dto.location,\r\n                    isRemote: dto.isRemote || false,\r\n                    salaryMin: dto.salaryMin,\r\n                    salaryMax: dto.salaryMax,\r\n                    salaryCurrency: dto.salaryCurrency || 'INR',\r\n                    experienceMin: dto.experienceMin,\r\n                    experienceMax: dto.experienceMax,\r\n                    educationLevel: dto.educationLevel,\r\n                    maxApplications: dto.maxApplications || 100, // Ensure field name matches schema\r\n                    referralFee: dto.referralFee || 499,\r\n                    testId: dto.testId,\r\n                    hrId: hr.id,\r\n                    status: JobStatus.PENDING_APPROVAL,\r\n                },\r\n            });\r\n\r\n            // Add skills if provided\r\n            if (dto.JobSkill && dto.jobSkill.length > 0) {\r\n                await tx.jobSkill.createMany({\r\n                    data: dto.jobSkill.map((skill) => ({\r\n                        jobId: newJob.id,\r\n                        name: skill.name,\r\n                        isRequired: skill.isRequired ?? true,\r\n                    })),\r\n                });\r\n            }\r\n\r\n            // Update HR stats\r\n            await tx.hR.update({\r\n                where: { id: hr.id },\r\n                data: { totalJobsPosted: { increment: 1 } },\r\n            });\r\n\r\n            return newJob;\r\n        });\r\n\r\n        return this.getJobById(job.id);\r\n    }\r\n\r\n    // Get all active jobs (public)\r\n    async getActiveJobs(query: JobQueryDto) {\r\n        const { search, location, company, experienceMin, experienceMax, isRemote, page, limit } =\r\n            query;\r\n\r\n        const where: any = {\r\n            status: JobStatus.ACTIVE,\r\n        };\r\n\r\n        if (search) {\r\n            where.OR = [\r\n                { title: { contains: search, mode: 'insensitive' } },\r\n                { description: { contains: search, mode: 'insensitive' } },\r\n                { companyName: { contains: search, mode: 'insensitive' } },\r\n            ];\r\n        }\r\n\r\n        if (location) {\r\n            where.location = { contains: location, mode: 'insensitive' };\r\n        }\r\n\r\n        if (company) {\r\n            where.companyName = { contains: company, mode: 'insensitive' };\r\n        }\r\n\r\n        if (typeof isRemote === 'boolean') {\r\n            where.isRemote = isRemote;\r\n        }\r\n\r\n        if (experienceMin !== undefined) {\r\n            where.experienceMin = { gte: experienceMin };\r\n        }\r\n\r\n        if (experienceMax !== undefined) {\r\n            where.experienceMax = { lte: experienceMax };\r\n        }\r\n\r\n        const skip = ((page || 1) - 1) * (limit || 10);\r\n        const take = limit || 10;\r\n\r\n        const [jobs, total] = await Promise.all([\r\n            this.prisma.job.findMany({\r\n                where,\r\n                skip,\r\n                take,\r\n                include: {\r\n                    JobSkill: true,\r\n                    HR: {\r\n                        select: {\r\n                            companyName: true,\r\n                        },\r\n                    },\r\n                },\r\n                orderBy: { createdAt: 'desc' },\r\n            }),\r\n            this.prisma.job.count({ where }),\r\n        ]);\r\n\r\n        return {\r\n            data: jobs,\r\n            meta: {\r\n                page: page || 1,\r\n                limit: limit || 10,\r\n                total,\r\n                totalPages: Math.ceil(total / (limit || 10)),\r\n            },\r\n        };\r\n    }\r\n\r\n    // Get job by ID or slug\r\n    async getJobById(idOrSlug: string) {\r\n        const job = await this.prisma.job.findFirst({\r\n            where: {\r\n                OR: [{ id: idOrSlug }, { slug: idOrSlug }],\r\n            },\r\n            include: {\r\n                JobSkill: true,\r\n                Test: {\r\n                    select: {\r\n                        id: true,\r\n                        title: true,\r\n                        duration: true,\r\n                        totalQuestionBank: true,\r\n                    },\r\n                },\r\n                HR: {\r\n                    select: {\r\n                        companyName: true,\r\n                        companyWebsite: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        return job;\r\n    }\r\n\r\n    // Update job\r\n    async updateJob(jobId: string, hrId: string, dto: UpdateJobDto) {\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            include: { HR: true },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        // Check if HR owns this job (skip for admin-created jobs with no HR)\r\n        if (job.HR && job.hr.userId !== hrId) {\r\n            throw new ForbiddenException('Not authorized to update this job');\r\n        }\r\n\r\n        // If job has no HR and user is not the creator, deny access\r\n        if (!job.HR) {\r\n            throw new ForbiddenException('Only admin can update admin-created jobs');\r\n        }\r\n\r\n        return this.prisma.job.update({\r\n            where: { id: jobId },\r\n            data: dto,\r\n            include: { JobSkill: true },\r\n        });\r\n    }\r\n\r\n    // Apply for job\r\n    async applyForJob(\r\n        jobId: string,\r\n        userId: string,\r\n        dto: ApplyJobDto,\r\n    ) {\r\n        // Get candidate\r\n        const candidate = await this.prisma.candidate.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!candidate) {\r\n            throw new NotFoundException('Candidate profile not found');\r\n        }\r\n\r\n        // Get job with skillBucket\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            include: {\r\n                SkillBucket: {\r\n                    include: {\r\n                        Test: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        if (job.status !== JobStatus.ACTIVE) {\r\n            throw new BadRequestException('Job is not accepting applications');\r\n        }\r\n\r\n        if (job.applicationCount >= job.maxApplications) {\r\n            throw new BadRequestException('Job has reached maximum applications');\r\n        }\r\n\r\n        // Check if already applied\r\n        const existingApplication = await this.prisma.jobApplication.findUnique({\r\n            where: {\r\n                candidateId_jobId: {\r\n                    candidateId: candidate.id,\r\n                    jobId: job.id,\r\n                },\r\n            },\r\n        });\r\n\r\n        if (existingApplication) {\r\n            throw new BadRequestException('Already applied for this job');\r\n        }\r\n\r\n        // Skill-based test logic - now supports composite requirements (Full Stack etc.)\r\n        let applicationStatus = ApplicationStatus.APPLIED;\r\n        let skillCheckResult: {\r\n            canApply: boolean;\r\n            missingTests: SkillTestStatusDto[];\r\n            passedTests: SkillTestStatusDto[];\r\n            hasRequirements: boolean;\r\n        } | null = null;\r\n\r\n        // Check ALL required skills for this job (supports multiple skill requirements)\r\n        skillCheckResult = await this.skillBucketService.checkAllRequiredSkillsForJob(\r\n            candidate.id,\r\n            job.id,\r\n        );\r\n\r\n        if (skillCheckResult.hasRequirements) {\r\n            if (skillCheckResult.canApply) {\r\n                // All required skills are passed and valid - allow instant application\r\n                applicationStatus = ApplicationStatus.APPLIED;\r\n            } else {\r\n                // Some skills are missing - show detailed error\r\n                const missingSkillNames = skillCheckResult.missingTests\r\n                    .map(t => t.displayName || t.skillBucketName)\r\n                    .join(', ');\r\n\r\n                // Check if any are in cooldown (failed recently)\r\n                const inCooldown = skillCheckResult.missingTests.filter(t => t.isFailed && !t.canRetest);\r\n                if (inCooldown.length > 0) {\r\n                    const cooldownInfo = inCooldown\r\n                        .map(t => `${t.skillBucketName} (${t.retestInHours}h remaining)`)\r\n                        .join(', ');\r\n                    throw new BadRequestException(\r\n                        `You are in cooldown for: ${cooldownInfo}. Please wait before retrying.`\r\n                    );\r\n                }\r\n\r\n                // Check if any are expired\r\n                const expired = skillCheckResult.missingTests.filter(t => t.isPassed && !t.isValid);\r\n                if (expired.length > 0) {\r\n                    throw new BadRequestException(\r\n                        `Your verification has expired for: ${missingSkillNames}. Please retake the HR Shortlisting Check.`\r\n                    );\r\n                }\r\n\r\n                // Need to take tests for missing skills\r\n                throw new BadRequestException(\r\n                    `You need to pass the following skill tests before applying: ${missingSkillNames}`\r\n                );\r\n            }\r\n        } else if (job.testId) {\r\n            // Fallback to old per-job test logic (for backwards compatibility)\r\n            applicationStatus = ApplicationStatus.TEST_REQUIRED;\r\n        }\r\n\r\n        // Create application\r\n        const application = await this.prisma.$transaction(async (tx) => {\r\n            // Get the first passed test score if any (for backward compatibility)\r\n            const firstPassedTest = skillCheckResult?.passedTests[0];\r\n\r\n            const app = await tx.jobApplication.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    candidateId: candidate.id,\r\n                    jobId: job.id,\r\n                    status: applicationStatus,\r\n                    coverLetter: dto.coverLetter,\r\n                    updatedAt: new Date(),\r\n                    // If valid skill pass, mark test as passed\r\n                    ...(firstPassedTest && {\r\n                        testScore: firstPassedTest.score,\r\n                        testPassedAt: new Date(),\r\n                    }),\r\n                },\r\n            });\r\n\r\n            // Increment application count\r\n            await tx.job.update({\r\n                where: { id: job.id },\r\n                data: { applicationCount: { increment: 1 } },\r\n            });\r\n\r\n            return app;\r\n        });\r\n\r\n        // Return with skill status info\r\n        return {\r\n            ...application,\r\n            skillTestInfo: skillCheckResult?.hasRequirements ? {\r\n                passedJobSkill: skillCheckResult.passedTests.map(t => ({\r\n                    skillBucketName: t.skillBucketName,\r\n                    displayName: t.displayName,\r\n                    score: t.score,\r\n                    validTill: t.validTill,\r\n                    validDaysRemaining: t.validDaysRemaining,\r\n                })),\r\n                canApply: skillCheckResult.canApply,\r\n            } : null,\r\n        };\r\n    }\r\n\r\n    // Get HR's jobs\r\n    async getHRJobs(hrId: string, status?: JobStatus) {\r\n        const hr = await this.prisma.hR.findUnique({\r\n            where: { userId: hrId },\r\n        });\r\n\r\n        if (!hr) {\r\n            throw new NotFoundException('HR profile not found');\r\n        }\r\n\r\n        return this.prisma.job.findMany({\r\n            where: {\r\n                hrId: hr.id,\r\n                ...(status && { status }),\r\n            },\r\n            include: {\r\n                JobSkill: true,\r\n                _count: {\r\n                    select: { JobApplication: true },\r\n                },\r\n            },\r\n            orderBy: { createdAt: 'desc' },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if a candidate can apply for a job (for frontend pre-check)\r\n     * This allows the frontend to show appropriate UI before the user clicks Apply\r\n     */\r\n    async getApplyEligibility(jobId: string, userId: string) {\r\n        // Get candidate\r\n        const candidate = await this.prisma.candidate.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!candidate) {\r\n            return {\r\n                canApply: false,\r\n                reason: 'Candidate profile not found',\r\n                requiresProfile: true,\r\n            };\r\n        }\r\n\r\n        // Get job\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n        });\r\n\r\n        if (!job) {\r\n            return {\r\n                canApply: false,\r\n                reason: 'Job not found',\r\n            };\r\n        }\r\n\r\n        if (job.status !== JobStatus.ACTIVE) {\r\n            return {\r\n                canApply: false,\r\n                reason: 'Job is not accepting applications',\r\n            };\r\n        }\r\n\r\n        if (job.applicationCount >= job.maxApplications) {\r\n            return {\r\n                canApply: false,\r\n                reason: 'Job has reached maximum applications',\r\n            };\r\n        }\r\n\r\n        // Check if already applied\r\n        const existingApplication = await this.prisma.jobApplication.findUnique({\r\n            where: {\r\n                candidateId_jobId: {\r\n                    candidateId: candidate.id,\r\n                    jobId: job.id,\r\n                },\r\n            },\r\n        });\r\n\r\n        if (existingApplication) {\r\n            return {\r\n                canApply: false,\r\n                reason: 'Already applied for this job',\r\n                applicationId: existingApplication.id,\r\n                applicationStatus: existingApplication.status,\r\n            };\r\n        }\r\n\r\n        // Check skill requirements\r\n        const skillCheckResult = await this.skillBucketService.checkAllRequiredSkillsForJob(\r\n            candidate.id,\r\n            job.id,\r\n        );\r\n\r\n        if (skillCheckResult.hasRequirements && !skillCheckResult.canApply) {\r\n            // Check if any are in cooldown\r\n            const inCooldown = skillCheckResult.missingTests.filter(t => t.isFailed && !t.canRetest);\r\n            if (inCooldown.length > 0) {\r\n                return {\r\n                    canApply: false,\r\n                    reason: 'In retest cooldown',\r\n                    cooldownTests: inCooldown.map(t => ({\r\n                        skillName: t.skillBucketName,\r\n                        displayName: t.displayName,\r\n                        retestInHours: t.retestInHours,\r\n                    })),\r\n                };\r\n            }\r\n\r\n            // Check if any are expired\r\n            const expired = skillCheckResult.missingTests.filter(t => t.isPassed && !t.isValid);\r\n            if (expired.length > 0) {\r\n                return {\r\n                    canApply: false,\r\n                    reason: 'Skill test expired',\r\n                    expiredTests: expired.map(t => ({\r\n                        skillName: t.skillBucketName,\r\n                        displayName: t.displayName,\r\n                    })),\r\n                    requiresRetest: true,\r\n                };\r\n            }\r\n\r\n            // Need to take tests\r\n            return {\r\n                canApply: false,\r\n                reason: 'Skill tests required',\r\n                missingTests: skillCheckResult.missingTests.map(t => ({\r\n                    skillBucketId: t.skillBucketId,\r\n                    skillName: t.skillBucketName,\r\n                    displayName: t.displayName,\r\n                    neverTaken: t.neverTaken,\r\n                })),\r\n                requiresTest: true,\r\n            };\r\n        }\r\n\r\n        // All checks passed\r\n        return {\r\n            canApply: true,\r\n            skillTestInfo: skillCheckResult.hasRequirements ? {\r\n                passedSkills: skillCheckResult.passedTests.map(t => ({\r\n                    skillName: t.skillBucketName,\r\n                    displayName: t.displayName,\r\n                    validDaysRemaining: t.validDaysRemaining,\r\n                })),\r\n            } : null,\r\n        };\r\n    }\r\n\r\n    // Helper: Generate slug\r\n    private generateSlug(title: string, company: string): string {\r\n        const base = `${title}-at-${company}`\r\n            .toLowerCase()\r\n            .replace(/[^a-z0-9]+/g, '-')\r\n            .replace(/(^-|-$)/g, '');\r\n        const timestamp = Date.now().toString(36);\r\n        return `${base}-${timestamp}`;\r\n    }\r\n}\r\n\r\n"],"names":["JobService","createJob","hrId","dto","hr","prisma","hR","findUnique","where","userId","NotFoundException","approvalStatus","ForbiddenException","slug","generateSlug","title","companyName","job","$transaction","tx","newJob","create","data","description","requirements","responsibilities","companyLogo","location","isRemote","salaryMin","salaryMax","salaryCurrency","experienceMin","experienceMax","educationLevel","maxApplications","referralFee","testId","id","status","JobStatus","PENDING_APPROVAL","JobSkill","jobSkill","length","createMany","map","skill","jobId","name","isRequired","update","totalJobsPosted","increment","getJobById","getActiveJobs","query","search","company","page","limit","ACTIVE","OR","contains","mode","undefined","gte","lte","skip","take","jobs","total","Promise","all","findMany","include","HR","select","orderBy","createdAt","count","meta","totalPages","Math","ceil","idOrSlug","findFirst","Test","duration","totalQuestionBank","companyWebsite","updateJob","applyForJob","candidate","SkillBucket","BadRequestException","applicationCount","existingApplication","jobApplication","candidateId_jobId","candidateId","applicationStatus","ApplicationStatus","APPLIED","skillCheckResult","skillBucketService","checkAllRequiredSkillsForJob","hasRequirements","canApply","missingSkillNames","missingTests","t","displayName","skillBucketName","join","inCooldown","filter","isFailed","canRetest","cooldownInfo","retestInHours","expired","isPassed","isValid","TEST_REQUIRED","application","firstPassedTest","passedTests","app","crypto","randomUUID","coverLetter","updatedAt","Date","testScore","score","testPassedAt","skillTestInfo","passedJobSkill","validTill","validDaysRemaining","getHRJobs","_count","JobApplication","getApplyEligibility","reason","requiresProfile","applicationId","cooldownTests","skillName","expiredTests","requiresRetest","skillBucketId","neverTaken","requiresTest","passedSkills","base","toLowerCase","replace","timestamp","now","toString"],"mappings":"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"}