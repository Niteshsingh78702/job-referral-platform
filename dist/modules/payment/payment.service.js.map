{"version":3,"sources":["../../../src/modules/payment/payment.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    NotFoundException,\r\n    BadRequestException,\r\n    ForbiddenException,\r\n} from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport * as crypto from 'crypto';\r\nimport Razorpay from 'razorpay';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport {\r\n    CreatePaymentOrderDto,\r\n    VerifyPaymentDto,\r\n    RequestRefundDto,\r\n    ProcessRefundDto,\r\n} from './dto';\r\nimport {\r\n    PaymentStatus,\r\n    RefundStatus,\r\n    ApplicationStatus,\r\n    ReferralStatus,\r\n    AuditAction,\r\n} from '../../common/constants';\r\n\r\n@Injectable()\r\nexport class PaymentService {\r\n    private razorpay: Razorpay | null = null;\r\n\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private configService: ConfigService,\r\n    ) {\r\n        const keyId = this.configService.get('RAZORPAY_KEY_ID');\r\n        const keySecret = this.configService.get('RAZORPAY_KEY_SECRET');\r\n\r\n        if (keyId && keySecret && keyId !== 'rzp_test_your_key_id') {\r\n            this.razorpay = new Razorpay({\r\n                key_id: keyId,\r\n                key_secret: keySecret,\r\n            });\r\n        } else {\r\n            console.warn('⚠️ Razorpay credentials not configured. Payment features will be disabled.');\r\n        }\r\n    }\r\n\r\n    private ensureRazorpay(): Razorpay {\r\n        if (!this.razorpay) {\r\n            throw new BadRequestException('Payment service is not configured. Please set RAZORPAY_KEY_ID and RAZORPAY_KEY_SECRET.');\r\n        }\r\n        return this.razorpay;\r\n    }\r\n\r\n    // Create payment order\r\n    async createOrder(userId: string, dto: CreatePaymentOrderDto) {\r\n        // Get application\r\n        const application = await this.prisma.jobApplication.findUnique({\r\n            where: { id: dto.applicationId },\r\n            include: {\r\n                Candidate: true,\r\n                Job: true,\r\n                Referral: true,\r\n                Payment: true,\r\n            },\r\n        });\r\n\r\n        if (!application) {\r\n            throw new NotFoundException('Application not found');\r\n        }\r\n\r\n        if (application.Candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        // Verify eligibility - now uses INTERVIEW_CONFIRMED for interview payments\r\n        // or APPLIED for old referral payments\r\n        if (application.status !== ApplicationStatus.APPLIED &&\r\n            application.status !== ApplicationStatus.INTERVIEW_CONFIRMED) {\r\n            throw new BadRequestException(\r\n                'Payment not available for this application status.',\r\n            );\r\n        }\r\n\r\n        if (!application.Referral || application.Referral.status !== ReferralStatus.CONFIRMED) {\r\n            throw new BadRequestException('Referral not confirmed');\r\n        }\r\n\r\n        // Check if already paid\r\n        const successfulPayment = application.Payment.find(\r\n            (p) => p.status === PaymentStatus.SUCCESS,\r\n        );\r\n\r\n        if (successfulPayment) {\r\n            throw new BadRequestException('Payment already completed');\r\n        }\r\n\r\n        // Check for pending payment\r\n        const pendingPayment = application.Payment.find(\r\n            (p) => p.status === PaymentStatus.ORDER_CREATED || p.status === PaymentStatus.PENDING,\r\n        );\r\n\r\n        if (pendingPayment && pendingPayment.razorpayOrderId) {\r\n            // Return existing order\r\n            return {\r\n                orderId: pendingPayment.razorpayOrderId,\r\n                amount: pendingPayment.amount,\r\n                currency: pendingPayment.currency,\r\n                paymentId: pendingPayment.id,\r\n            };\r\n        }\r\n\r\n        const amount = application.job.referralFee * 100; // Razorpay expects paise\r\n\r\n        // Create Razorpay order\r\n        const razorpay = this.ensureRazorpay();\r\n        const order = await razorpay.orders.create({\r\n            amount,\r\n            currency: 'INR',\r\n            receipt: `app_${application.id.slice(0, 20)}`,\r\n            notes: {\r\n                applicationId: application.id,\r\n                candidateId: application.candidateId,\r\n                jobId: application.jobId,\r\n            },\r\n        });\r\n\r\n        // Create payment record\r\n        const payment = await this.prisma.payment.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                applicationId: application.id,\r\n                razorpayOrderId: order.id,\r\n                amount: application.job.referralFee,\r\n                currency: 'INR',\r\n                status: PaymentStatus.ORDER_CREATED,\r\n                orderCreatedAt: new Date(),\r\n            },\r\n        });\r\n\r\n        // Update application status\r\n        await this.prisma.jobApplication.update({\r\n            where: { id: application.id },\r\n            data: { status: ApplicationStatus.PAYMENT_PENDING },\r\n        });\r\n\r\n        // Update referral status\r\n        await this.prisma.referral.update({\r\n            where: { applicationId: application.id },\r\n            data: { status: ReferralStatus.PAYMENT_PENDING },\r\n        });\r\n\r\n        // Audit log\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.PAYMENT_INITIATED,\r\n                entityType: 'Payment',\r\n                entityId: payment.id,\r\n                metadata: { orderId: order.id, amount: application.job.referralFee },\r\n            },\r\n        });\r\n\r\n        return {\r\n            orderId: order.id,\r\n            amount: application.job.referralFee,\r\n            currency: 'INR',\r\n            paymentId: payment.id,\r\n            keyId: this.configService.get('RAZORPAY_KEY_ID'),\r\n        };\r\n    }\r\n\r\n    // Verify payment (client-side callback)\r\n    async verifyPayment(userId: string, dto: VerifyPaymentDto) {\r\n        // Verify signature\r\n        const isValid = this.verifySignature(\r\n            dto.razorpayOrderId,\r\n            dto.razorpayPaymentId,\r\n            dto.razorpaySignature,\r\n        );\r\n\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid payment signature');\r\n        }\r\n\r\n        // Get payment\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { razorpayOrderId: dto.razorpayOrderId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: { Candidate: true },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!payment) {\r\n            throw new NotFoundException('Payment not found');\r\n        }\r\n\r\n        if (payment.JobApplication.Candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (payment.status === PaymentStatus.SUCCESS) {\r\n            return { success: true, message: 'Payment already verified' };\r\n        }\r\n\r\n        // Update payment\r\n        await this.prisma.payment.update({\r\n            where: { id: payment.id },\r\n            data: {\r\n                razorpayPaymentId: dto.razorpayPaymentId,\r\n                razorpaySignature: dto.razorpaySignature,\r\n                status: PaymentStatus.PENDING,\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Payment verification initiated' };\r\n    }\r\n\r\n    // Webhook handler (source of truth)\r\n    async handleWebhook(payload: any, signature: string) {\r\n        // Verify webhook signature\r\n        const isValid = this.verifyWebhookSignature(payload, signature);\r\n\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid webhook signature');\r\n        }\r\n\r\n        const event = payload.event;\r\n        const paymentData = payload.payload?.Payment?.entity;\r\n\r\n        if (!paymentData) {\r\n            return { success: true };\r\n        }\r\n\r\n        const orderId = paymentData.order_id;\r\n\r\n        // Idempotency check\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { razorpayOrderId: orderId },\r\n            include: { JobApplication: true },\r\n        });\r\n\r\n        if (!payment) {\r\n            return { success: true, message: 'Payment not found' };\r\n        }\r\n\r\n        // Already processed\r\n        if (payment.status === PaymentStatus.SUCCESS || payment.status === PaymentStatus.REFUNDED) {\r\n            return { success: true, message: 'Already processed' };\r\n        }\r\n\r\n        if (event === 'payment.captured' || event === 'payment.authorized') {\r\n            await this.processSuccessfulPayment(payment, paymentData);\r\n        } else if (event === 'payment.failed') {\r\n            await this.processFailedPayment(payment, paymentData);\r\n        }\r\n\r\n        return { success: true };\r\n    }\r\n\r\n    private async processSuccessfulPayment(payment: any, paymentData: any) {\r\n        await this.prisma.$transaction(async (tx) => {\r\n            // Update payment\r\n            await tx.payment.update({\r\n                where: { id: payment.id },\r\n                data: {\r\n                    razorpayPaymentId: paymentData.id,\r\n                    status: PaymentStatus.SUCCESS,\r\n                    paidAt: new Date(),\r\n                    webhookPayload: paymentData,\r\n                },\r\n            });\r\n\r\n            // Check if this payment is for an interview\r\n            const interview = await tx.interview.findUnique({\r\n                where: { applicationId: payment.applicationId },\r\n            });\r\n\r\n            if (interview && interview.status === 'INTERVIEW_CONFIRMED') {\r\n                // This is an interview payment - update interview status\r\n                await tx.interview.update({\r\n                    where: { id: interview.id },\r\n                    data: {\r\n                        status: 'PAYMENT_SUCCESS' as any,\r\n                        paymentStatus: PaymentStatus.SUCCESS as any,\r\n                        paidAt: new Date(),\r\n                    },\r\n                });\r\n\r\n                // Note: Interview payment confirmation email will be sent separately\r\n            } else {\r\n                // This is a referral/legacy payment - update to PAYMENT_SUCCESS\r\n                await tx.jobApplication.update({\r\n                    where: { id: payment.applicationId },\r\n                    data: {\r\n                        status: ApplicationStatus.PAYMENT_SUCCESS as any,\r\n                        contactUnlockedAt: new Date(),\r\n                    },\r\n                });\r\n\r\n                // Update referral\r\n                await tx.referral.update({\r\n                    where: { applicationId: payment.applicationId },\r\n                    data: { status: ReferralStatus.CONTACTED },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    action: AuditAction.PAYMENT_SUCCESS,\r\n                    entityType: 'Payment',\r\n                    entityId: payment.id,\r\n                    metadata: { razorpayPaymentId: paymentData.id },\r\n                },\r\n            });\r\n        });\r\n    }\r\n\r\n    private async processFailedPayment(payment: any, paymentData: any) {\r\n        await this.prisma.payment.update({\r\n            where: { id: payment.id },\r\n            data: {\r\n                status: PaymentStatus.FAILED,\r\n                failureReason: paymentData.error_description || 'Payment failed',\r\n                webhookPayload: paymentData,\r\n            },\r\n        });\r\n\r\n        // Audit log\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                action: AuditAction.PAYMENT_FAILED,\r\n                entityType: 'Payment',\r\n                entityId: payment.id,\r\n                metadata: { error: paymentData.error_description },\r\n            },\r\n        });\r\n    }\r\n\r\n    // Get payment history\r\n    async getPaymentHistory(userId: string) {\r\n        const candidate = await this.prisma.candidate.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!candidate) {\r\n            throw new NotFoundException('Candidate not found');\r\n        }\r\n\r\n        return this.prisma.payment.findMany({\r\n            where: {\r\n                JobApplication: {\r\n                    candidateId: candidate.id,\r\n                },\r\n            },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Job: {\r\n                            select: {\r\n                                title: true,\r\n                                companyName: true,\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n                Refund: true,\r\n            },\r\n            orderBy: { createdAt: 'desc' },\r\n        });\r\n    }\r\n\r\n    // Get payment by ID\r\n    async getPaymentById(userId: string, paymentId: string) {\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { id: paymentId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Candidate: true,\r\n                        Job: true,\r\n                    },\r\n                },\r\n                Refund: true,\r\n            },\r\n        });\r\n\r\n        if (!payment) {\r\n            throw new NotFoundException('Payment not found');\r\n        }\r\n\r\n        if (payment.JobApplication.Candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        return payment;\r\n    }\r\n\r\n    // Request refund\r\n    async requestRefund(userId: string, dto: RequestRefundDto) {\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { id: dto.paymentId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Candidate: true,\r\n                        Referral: true,\r\n                    },\r\n                },\r\n                Refund: true,\r\n            },\r\n        });\r\n\r\n        if (!payment) {\r\n            throw new NotFoundException('Payment not found');\r\n        }\r\n\r\n        if (payment.JobApplication.Candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (payment.status !== PaymentStatus.SUCCESS) {\r\n            throw new BadRequestException('Only successful payments can be refunded');\r\n        }\r\n\r\n        if (payment.Refund) {\r\n            throw new BadRequestException('Refund already requested');\r\n        }\r\n\r\n        // Check if interview details were already unlocked\r\n        if (\r\n            payment.JobApplication.status === ApplicationStatus.PAYMENT_SUCCESS ||\r\n            payment.JobApplication.Referral?.status === ReferralStatus.CONTACTED\r\n        ) {\r\n            throw new BadRequestException(\r\n                'Refund not available after details have been shared',\r\n            );\r\n        }\r\n\r\n        // Create refund request\r\n        const refund = await this.prisma.refund.create({\r\n            data: {\r\n                paymentId: payment.id,\r\n                amount: payment.amount,\r\n                reason: dto.reason,\r\n                status: RefundStatus.REQUESTED,\r\n            },\r\n        });\r\n\r\n        // Audit log\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.REFUND_REQUESTED,\r\n                entityType: 'Refund',\r\n                entityId: refund.id,\r\n                metadata: { paymentId: payment.id, reason: dto.reason },\r\n            },\r\n        });\r\n\r\n        return refund;\r\n    }\r\n\r\n    // =============================================\r\n    // INTERVIEW PAYMENT METHODS (₹99)\r\n    // =============================================\r\n\r\n    /**\r\n     * Create payment order for interview (₹99)\r\n     */\r\n    async createInterviewOrder(userId: string, applicationId: string) {\r\n        // Get application with interview\r\n        const application = await this.prisma.jobApplication.findUnique({\r\n            where: { id: applicationId },\r\n            include: {\r\n                Candidate: true,\r\n                Job: true,\r\n                Interview: true,\r\n            },\r\n        });\r\n\r\n        if (!application) {\r\n            throw new NotFoundException('Application not found');\r\n        }\r\n\r\n        if (application.Candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        // Verify interview exists and is pending payment\r\n        if (!application.Interview) {\r\n            throw new BadRequestException('No interview request found for this application');\r\n        }\r\n\r\n        // Allow payment when interview is INTERVIEW_CONFIRMED (HR confirmed, awaiting payment)\r\n        // or PAYMENT_PENDING (legacy flow)\r\n        const allowedStatuses = ['INTERVIEW_CONFIRMED', 'PAYMENT_PENDING'];\r\n        if (!allowedStatuses.includes(application.Interview.status)) {\r\n            throw new BadRequestException(\r\n                `Interview is in ${application.Interview.status} status. Payment not available.`,\r\n            );\r\n        }\r\n\r\n        // Check for existing successful payment for this interview\r\n        const existingPayment = await this.prisma.payment.findFirst({\r\n            where: {\r\n                applicationId,\r\n                status: PaymentStatus.SUCCESS,\r\n                amount: 99, // Interview fee\r\n            },\r\n        });\r\n\r\n        if (existingPayment) {\r\n            throw new BadRequestException('Interview payment already completed');\r\n        }\r\n\r\n        // Check for pending order\r\n        const pendingPayment = await this.prisma.payment.findFirst({\r\n            where: {\r\n                applicationId,\r\n                status: { in: [PaymentStatus.ORDER_CREATED, PaymentStatus.PENDING] },\r\n                amount: 99,\r\n            },\r\n        });\r\n\r\n        if (pendingPayment && pendingPayment.razorpayOrderId) {\r\n            return {\r\n                orderId: pendingPayment.razorpayOrderId,\r\n                amount: 99,\r\n                currency: 'INR',\r\n                paymentId: pendingPayment.id,\r\n                keyId: this.configService.get('RAZORPAY_KEY_ID'),\r\n            };\r\n        }\r\n\r\n        const amount = 9900; // ₹99 in paise\r\n\r\n        // Check for test mode - bypasses Razorpay and directly creates successful payment\r\n        const testMode = this.configService.get('PAYMENT_TEST_MODE') === 'true';\r\n\r\n        if (testMode) {\r\n            // TEST MODE: Directly create successful payment and update interview\r\n            const paymentId = crypto.randomUUID();\r\n            const testOrderId = `test_order_${Date.now()}`;\r\n\r\n            await this.prisma.$transaction(async (tx) => {\r\n                // Create payment record as SUCCESS\r\n                await tx.payment.create({\r\n                    data: {\r\n                        id: paymentId,\r\n                        applicationId: application.id,\r\n                        razorpayOrderId: testOrderId,\r\n                        razorpayPaymentId: `test_pay_${Date.now()}`,\r\n                        amount: 99,\r\n                        currency: 'INR',\r\n                        status: PaymentStatus.SUCCESS,\r\n                        orderCreatedAt: new Date(),\r\n                        paidAt: new Date(),\r\n                    },\r\n                });\r\n\r\n                // Update interview status\r\n                await tx.interview.update({\r\n                    where: { id: application.Interview.id },\r\n                    data: {\r\n                        status: 'PAYMENT_SUCCESS' as any,\r\n                        paymentStatus: PaymentStatus.SUCCESS as any,\r\n                        paidAt: new Date(),\r\n                    },\r\n                });\r\n\r\n                // Update application status\r\n                await tx.jobApplication.update({\r\n                    where: { id: application.id },\r\n                    data: {\r\n                        status: 'PAYMENT_SUCCESS' as any,\r\n                        contactUnlockedAt: new Date(),\r\n                    },\r\n                });\r\n            });\r\n\r\n            // Return test mode response - frontend will show success directly\r\n            return {\r\n                testMode: true,\r\n                success: true,\r\n                message: 'TEST MODE: Payment completed successfully',\r\n                orderId: testOrderId,\r\n                paymentId: paymentId,\r\n            };\r\n        }\r\n\r\n        // PRODUCTION MODE: Create Razorpay order\r\n        const razorpay = this.ensureRazorpay();\r\n        const order = await razorpay.orders.create({\r\n            amount,\r\n            currency: 'INR',\r\n            receipt: `int_${application.id.slice(0, 18)}`,\r\n            notes: {\r\n                applicationId: application.id,\r\n                interviewId: application.Interview.id,\r\n                candidateId: application.candidateId,\r\n                type: 'INTERVIEW',\r\n            },\r\n        });\r\n\r\n        // Create payment record\r\n        const payment = await this.prisma.payment.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                applicationId: application.id,\r\n                razorpayOrderId: order.id,\r\n                amount: 99,\r\n                currency: 'INR',\r\n                status: PaymentStatus.ORDER_CREATED,\r\n                orderCreatedAt: new Date(),\r\n            },\r\n        });\r\n\r\n        // Audit log\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.PAYMENT_INITIATED,\r\n                entityType: 'InterviewPayment',\r\n                entityId: payment.id,\r\n                metadata: { orderId: order.id, amount: 99, interviewId: application.Interview.id },\r\n            },\r\n        });\r\n\r\n        return {\r\n            orderId: order.id,\r\n            amount: 99,\r\n            currency: 'INR',\r\n            paymentId: payment.id,\r\n            keyId: this.configService.get('RAZORPAY_KEY_ID'),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Verify interview payment and update interview status\r\n     */\r\n    async verifyInterviewPayment(userId: string, dto: VerifyPaymentDto) {\r\n        // Verify signature\r\n        const isValid = this.verifySignature(\r\n            dto.razorpayOrderId,\r\n            dto.razorpayPaymentId,\r\n            dto.razorpaySignature,\r\n        );\r\n\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid payment signature');\r\n        }\r\n\r\n        // Get payment\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { razorpayOrderId: dto.razorpayOrderId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Candidate: { include: { User: true } },\r\n                        Interview: true,\r\n                        Job: { include: { HR: { include: { User: true } } } },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!payment) {\r\n            throw new NotFoundException('Payment not found');\r\n        }\r\n\r\n        if (payment.JobApplication.Candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (payment.status === PaymentStatus.SUCCESS) {\r\n            return { success: true, message: 'Payment already verified' };\r\n        }\r\n\r\n        const interview = payment.JobApplication.Interview;\r\n        if (!interview) {\r\n            throw new BadRequestException('Interview not found');\r\n        }\r\n\r\n        // Update payment and interview in transaction\r\n        await this.prisma.$transaction(async (tx) => {\r\n            // Update payment status\r\n            await tx.payment.update({\r\n                where: { id: payment.id },\r\n                data: {\r\n                    razorpayPaymentId: dto.razorpayPaymentId,\r\n                    status: PaymentStatus.SUCCESS,\r\n                    paidAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Update interview status to PAYMENT_SUCCESS\r\n            await tx.interview.update({\r\n                where: { id: interview.id },\r\n                data: {\r\n                    status: 'PAYMENT_SUCCESS' as any,\r\n                    paymentStatus: PaymentStatus.SUCCESS as any,\r\n                    paidAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // CRITICAL: Also update application status to PAYMENT_SUCCESS\r\n            await tx.jobApplication.update({\r\n                where: { id: payment.applicationId },\r\n                data: {\r\n                    status: ApplicationStatus.PAYMENT_SUCCESS as any,\r\n                    contactUnlockedAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId,\r\n                    action: AuditAction.PAYMENT_SUCCESS,\r\n                    entityType: 'InterviewPayment',\r\n                    entityId: payment.id,\r\n                    metadata: {\r\n                        razorpayPaymentId: dto.razorpayPaymentId,\r\n                        interviewId: interview.id,\r\n                    },\r\n                },\r\n            });\r\n        });\r\n\r\n        // TODO: Send email notification to HR that payment is complete\r\n        // this.emailService.sendInterviewPaymentConfirmation(...)\r\n\r\n        return {\r\n            success: true,\r\n            message: 'Interview payment verified. HR will schedule your interview soon.',\r\n        };\r\n    }\r\n\r\n    // Signature verification helpers\r\n    private verifySignature(\r\n        orderId: string,\r\n        paymentId: string,\r\n        signature: string,\r\n    ): boolean {\r\n        const secret = this.configService.get('RAZORPAY_KEY_SECRET');\r\n        const body = `${orderId}|${paymentId}`;\r\n        const expectedSignature = crypto\r\n            .createHmac('sha256', secret)\r\n            .update(body)\r\n            .digest('hex');\r\n        return expectedSignature === signature;\r\n    }\r\n\r\n    private verifyWebhookSignature(payload: any, signature: string): boolean {\r\n        const secret = this.configService.get('RAZORPAY_WEBHOOK_SECRET');\r\n        const body = JSON.stringify(payload);\r\n        const expectedSignature = crypto\r\n            .createHmac('sha256', secret)\r\n            .update(body)\r\n            .digest('hex');\r\n        return expectedSignature === signature;\r\n    }\r\n}\r\n\r\n\r\n"],"names":["PaymentService","ensureRazorpay","razorpay","BadRequestException","createOrder","userId","dto","application","prisma","jobApplication","findUnique","where","id","applicationId","include","Candidate","Job","Referral","Payment","NotFoundException","ForbiddenException","status","ApplicationStatus","APPLIED","INTERVIEW_CONFIRMED","ReferralStatus","CONFIRMED","successfulPayment","find","p","PaymentStatus","SUCCESS","pendingPayment","ORDER_CREATED","PENDING","razorpayOrderId","orderId","amount","currency","paymentId","job","referralFee","order","orders","create","receipt","slice","notes","candidateId","jobId","payment","data","crypto","randomUUID","orderCreatedAt","Date","update","PAYMENT_PENDING","referral","auditLog","action","AuditAction","PAYMENT_INITIATED","entityType","entityId","metadata","keyId","configService","get","verifyPayment","isValid","verifySignature","razorpayPaymentId","razorpaySignature","JobApplication","success","message","handleWebhook","payload","signature","verifyWebhookSignature","event","paymentData","entity","order_id","REFUNDED","processSuccessfulPayment","processFailedPayment","$transaction","tx","paidAt","webhookPayload","interview","paymentStatus","PAYMENT_SUCCESS","contactUnlockedAt","CONTACTED","FAILED","failureReason","error_description","PAYMENT_FAILED","error","getPaymentHistory","candidate","findMany","select","title","companyName","Refund","orderBy","createdAt","getPaymentById","requestRefund","refund","reason","RefundStatus","REQUESTED","REFUND_REQUESTED","createInterviewOrder","Interview","allowedStatuses","includes","existingPayment","findFirst","in","testMode","testOrderId","now","interviewId","type","verifyInterviewPayment","User","HR","secret","body","expectedSignature","createHmac","digest","JSON","stringify","keySecret","Razorpay","key_id","key_secret","console","warn"],"mappings":"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"}