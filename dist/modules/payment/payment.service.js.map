{"version":3,"sources":["../../../src/modules/payment/payment.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    NotFoundException,\r\n    BadRequestException,\r\n    ForbiddenException,\r\n} from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport * as crypto from 'crypto';\r\nimport Razorpay from 'razorpay';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport {\r\n    CreatePaymentOrderDto,\r\n    VerifyPaymentDto,\r\n    RequestRefundDto,\r\n    ProcessRefundDto,\r\n} from './dto';\r\nimport {\r\n    PaymentStatus,\r\n    RefundStatus,\r\n    ApplicationStatus,\r\n    ReferralStatus,\r\n    AuditAction,\r\n} from '../../common/constants';\r\n\r\n@Injectable()\r\nexport class PaymentService {\r\n    private razorpay: Razorpay | null = null;\r\n\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private configService: ConfigService,\r\n    ) {\r\n        const keyId = this.configService.get('RAZORPAY_KEY_ID');\r\n        const keySecret = this.configService.get('RAZORPAY_KEY_SECRET');\r\n\r\n        if (keyId && keySecret && keyId !== 'rzp_test_your_key_id') {\r\n            this.razorpay = new Razorpay({\r\n                key_id: keyId,\r\n                key_secret: keySecret,\r\n            });\r\n        } else {\r\n            console.warn('⚠️ Razorpay credentials not configured. Payment features will be disabled.');\r\n        }\r\n    }\r\n\r\n    private ensureRazorpay(): Razorpay {\r\n        if (!this.razorpay) {\r\n            throw new BadRequestException('Payment service is not configured. Please set RAZORPAY_KEY_ID and RAZORPAY_KEY_SECRET.');\r\n        }\r\n        return this.razorpay;\r\n    }\r\n\r\n    // Create payment order\r\n    async createOrder(userId: string, dto: CreatePaymentOrderDto) {\r\n        // Get application\r\n        const application = await this.prisma.jobApplication.findUnique({\r\n            where: { id: dto.applicationId },\r\n            include: {\r\n                Candidate: true,\r\n                Job: true,\r\n                Referral: true,\r\n                Payment: true,\r\n            },\r\n        });\r\n\r\n        if (!application) {\r\n            throw new NotFoundException('Application not found');\r\n        }\r\n\r\n        if (application.candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        // Verify eligibility - now uses INTERVIEW_CONFIRMED for interview payments\r\n        // or APPLIED for old referral payments\r\n        if (application.status !== ApplicationStatus.APPLIED &&\r\n            application.status !== ApplicationStatus.INTERVIEW_CONFIRMED) {\r\n            throw new BadRequestException(\r\n                'Payment not available for this application status.',\r\n            );\r\n        }\r\n\r\n        if (!application.Referral || application.referral.status !== ReferralStatus.CONFIRMED) {\r\n            throw new BadRequestException('Referral not confirmed');\r\n        }\r\n\r\n        // Check if already paid\r\n        const successfulPayment = application.payments.find(\r\n            (p) => p.status === PaymentStatus.SUCCESS,\r\n        );\r\n\r\n        if (successfulPayment) {\r\n            throw new BadRequestException('Payment already completed');\r\n        }\r\n\r\n        // Check for pending payment\r\n        const pendingPayment = application.payments.find(\r\n            (p) => p.status === PaymentStatus.ORDER_CREATED || p.status === PaymentStatus.PENDING,\r\n        );\r\n\r\n        if (pendingPayment && pendingPayment.razorpayOrderId) {\r\n            // Return existing order\r\n            return {\r\n                orderId: pendingPayment.razorpayOrderId,\r\n                amount: pendingPayment.amount,\r\n                currency: pendingPayment.currency,\r\n                paymentId: pendingPayment.id,\r\n            };\r\n        }\r\n\r\n        const amount = application.job.referralFee * 100; // Razorpay expects paise\r\n\r\n        // Create Razorpay order\r\n        const razorpay = this.ensureRazorpay();\r\n        const order = await razorpay.orders.create({\r\n            amount,\r\n            currency: 'INR',\r\n            receipt: `app_${application.id.slice(0, 20)}`,\r\n            notes: {\r\n                applicationId: application.id,\r\n                candidateId: application.candidateId,\r\n                jobId: application.jobId,\r\n            },\r\n        });\r\n\r\n        // Create payment record\r\n        const payment = await this.prisma.payment.create({\r\n            data: {\r\n                applicationId: application.id,\r\n                razorpayOrderId: order.id,\r\n                amount: application.job.referralFee,\r\n                currency: 'INR',\r\n                status: PaymentStatus.ORDER_CREATED,\r\n                orderCreatedAt: new Date(),\r\n            },\r\n        });\r\n\r\n        // Update application status\r\n        await this.prisma.jobApplication.update({\r\n            where: { id: application.id },\r\n            data: { status: ApplicationStatus.PAYMENT_PENDING },\r\n        });\r\n\r\n        // Update referral status\r\n        await this.prisma.referral.update({\r\n            where: { applicationId: application.id },\r\n            data: { status: ReferralStatus.PAYMENT_PENDING },\r\n        });\r\n\r\n        // Audit log\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.PAYMENT_INITIATED,\r\n                entityType: 'Payment',\r\n                entityId: payment.id,\r\n                metadata: { orderId: order.id, amount: application.job.referralFee },\r\n            },\r\n        });\r\n\r\n        return {\r\n            orderId: order.id,\r\n            amount: application.job.referralFee,\r\n            currency: 'INR',\r\n            paymentId: payment.id,\r\n            keyId: this.configService.get('RAZORPAY_KEY_ID'),\r\n        };\r\n    }\r\n\r\n    // Verify payment (client-side callback)\r\n    async verifyPayment(userId: string, dto: VerifyPaymentDto) {\r\n        // Verify signature\r\n        const isValid = this.verifySignature(\r\n            dto.razorpayOrderId,\r\n            dto.razorpayPaymentId,\r\n            dto.razorpaySignature,\r\n        );\r\n\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid payment signature');\r\n        }\r\n\r\n        // Get payment\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { razorpayOrderId: dto.razorpayOrderId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: { Candidate: true },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!payment) {\r\n            throw new NotFoundException('Payment not found');\r\n        }\r\n\r\n        if (payment.application.candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (payment.status === PaymentStatus.SUCCESS) {\r\n            return { success: true, message: 'Payment already verified' };\r\n        }\r\n\r\n        // Update payment\r\n        await this.prisma.payment.update({\r\n            where: { id: payment.id },\r\n            data: {\r\n                razorpayPaymentId: dto.razorpayPaymentId,\r\n                razorpaySignature: dto.razorpaySignature,\r\n                status: PaymentStatus.PENDING,\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Payment verification initiated' };\r\n    }\r\n\r\n    // Webhook handler (source of truth)\r\n    async handleWebhook(payload: any, signature: string) {\r\n        // Verify webhook signature\r\n        const isValid = this.verifyWebhookSignature(payload, signature);\r\n\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid webhook signature');\r\n        }\r\n\r\n        const event = payload.event;\r\n        const paymentData = payload.payload?.Payment?.entity;\r\n\r\n        if (!paymentData) {\r\n            return { success: true };\r\n        }\r\n\r\n        const orderId = paymentData.order_id;\r\n\r\n        // Idempotency check\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { razorpayOrderId: orderId },\r\n            include: { application: true },\r\n        });\r\n\r\n        if (!payment) {\r\n            return { success: true, message: 'Payment not found' };\r\n        }\r\n\r\n        // Already processed\r\n        if (payment.status === PaymentStatus.SUCCESS || payment.status === PaymentStatus.REFUNDED) {\r\n            return { success: true, message: 'Already processed' };\r\n        }\r\n\r\n        if (event === 'payment.captured' || event === 'payment.authorized') {\r\n            await this.processSuccessfulPayment(payment, paymentData);\r\n        } else if (event === 'payment.failed') {\r\n            await this.processFailedPayment(payment, paymentData);\r\n        }\r\n\r\n        return { success: true };\r\n    }\r\n\r\n    private async processSuccessfulPayment(Payment: any, paymentData: any) {\r\n        await this.prisma.$transaction(async (tx) => {\r\n            // Update payment\r\n            await tx.payment.update({\r\n                where: { id: payment.id },\r\n                data: {\r\n                    razorpayPaymentId: paymentData.id,\r\n                    status: PaymentStatus.SUCCESS,\r\n                    paidAt: new Date(),\r\n                    webhookPayload: paymentData,\r\n                },\r\n            });\r\n\r\n            // Check if this payment is for an interview\r\n            const interview = await tx.interview.findUnique({\r\n                where: { applicationId: payment.applicationId },\r\n            });\r\n\r\n            if (interview && interview.status === 'INTERVIEW_CONFIRMED') {\r\n                // This is an interview payment - update interview status\r\n                await tx.interview.update({\r\n                    where: { id: interview.id },\r\n                    data: {\r\n                        status: 'PAYMENT_SUCCESS' as any,\r\n                        paymentStatus: PaymentStatus.SUCCESS as any,\r\n                        paidAt: new Date(),\r\n                    },\r\n                });\r\n\r\n                // Note: Interview payment confirmation email will be sent separately\r\n            } else {\r\n                // This is a referral/legacy payment - update to PAYMENT_SUCCESS\r\n                await tx.jobApplication.update({\r\n                    where: { id: payment.applicationId },\r\n                    data: {\r\n                        status: ApplicationStatus.PAYMENT_SUCCESS as any,\r\n                        contactUnlockedAt: new Date(),\r\n                    },\r\n                });\r\n\r\n                // Update referral\r\n                await tx.referral.update({\r\n                    where: { applicationId: payment.applicationId },\r\n                    data: { status: ReferralStatus.CONTACTED },\r\n                });\r\n            }\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    action: AuditAction.PAYMENT_SUCCESS,\r\n                    entityType: 'Payment',\r\n                    entityId: payment.id,\r\n                    metadata: { razorpayPaymentId: paymentData.id },\r\n                },\r\n            });\r\n        });\r\n    }\r\n\r\n    private async processFailedPayment(Payment: any, paymentData: any) {\r\n        await this.prisma.payment.update({\r\n            where: { id: payment.id },\r\n            data: {\r\n                status: PaymentStatus.FAILED,\r\n                failureReason: paymentData.error_description || 'Payment failed',\r\n                webhookPayload: paymentData,\r\n            },\r\n        });\r\n\r\n        // Audit log\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                action: AuditAction.PAYMENT_FAILED,\r\n                entityType: 'Payment',\r\n                entityId: payment.id,\r\n                metadata: { error: paymentData.error_description },\r\n            },\r\n        });\r\n    }\r\n\r\n    // Get payment history\r\n    async getPaymentHistory(userId: string) {\r\n        const candidate = await this.prisma.candidate.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!candidate) {\r\n            throw new NotFoundException('Candidate not found');\r\n        }\r\n\r\n        return this.prisma.payment.findMany({\r\n            where: {\r\n                JobApplication: {\r\n                    candidateId: candidate.id,\r\n                },\r\n            },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Job: {\r\n                            select: {\r\n                                title: true,\r\n                                companyName: true,\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n                Refund: true,\r\n            },\r\n            orderBy: { createdAt: 'desc' },\r\n        });\r\n    }\r\n\r\n    // Get payment by ID\r\n    async getPaymentById(userId: string, paymentId: string) {\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { id: paymentId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Candidate: true,\r\n                        Job: true,\r\n                    },\r\n                },\r\n                Refund: true,\r\n            },\r\n        });\r\n\r\n        if (!payment) {\r\n            throw new NotFoundException('Payment not found');\r\n        }\r\n\r\n        if (payment.application.candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        return payment;\r\n    }\r\n\r\n    // Request refund\r\n    async requestRefund(userId: string, dto: RequestRefundDto) {\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { id: dto.paymentId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Candidate: true,\r\n                        Referral: true,\r\n                    },\r\n                },\r\n                Refund: true,\r\n            },\r\n        });\r\n\r\n        if (!payment) {\r\n            throw new NotFoundException('Payment not found');\r\n        }\r\n\r\n        if (payment.application.candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (payment.status !== PaymentStatus.SUCCESS) {\r\n            throw new BadRequestException('Only successful payments can be refunded');\r\n        }\r\n\r\n        if (payment.Refund) {\r\n            throw new BadRequestException('Refund already requested');\r\n        }\r\n\r\n        // Check if interview details were already unlocked\r\n        if (\r\n            payment.application.status === ApplicationStatus.PAYMENT_SUCCESS ||\r\n            payment.application.Referral?.status === ReferralStatus.CONTACTED\r\n        ) {\r\n            throw new BadRequestException(\r\n                'Refund not available after details have been shared',\r\n            );\r\n        }\r\n\r\n        // Create refund request\r\n        const refund = await this.prisma.refund.create({\r\n            data: {\r\n                paymentId: payment.id,\r\n                amount: payment.amount,\r\n                reason: dto.reason,\r\n                status: RefundStatus.REQUESTED,\r\n            },\r\n        });\r\n\r\n        // Audit log\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.REFUND_REQUESTED,\r\n                entityType: 'Refund',\r\n                entityId: refund.id,\r\n                metadata: { paymentId: payment.id, reason: dto.reason },\r\n            },\r\n        });\r\n\r\n        return refund;\r\n    }\r\n\r\n    // =============================================\r\n    // INTERVIEW PAYMENT METHODS (₹99)\r\n    // =============================================\r\n\r\n    /**\r\n     * Create payment order for interview (₹99)\r\n     */\r\n    async createInterviewOrder(userId: string, applicationId: string) {\r\n        // Get application with interview\r\n        const application = await this.prisma.jobApplication.findUnique({\r\n            where: { id: applicationId },\r\n            include: {\r\n                Candidate: true,\r\n                Job: true,\r\n                Interview: true,\r\n            },\r\n        });\r\n\r\n        if (!application) {\r\n            throw new NotFoundException('Application not found');\r\n        }\r\n\r\n        if (application.candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        // Verify interview exists and is pending payment\r\n        if (!application.Interview) {\r\n            throw new BadRequestException('No interview request found for this application');\r\n        }\r\n\r\n        if (application.interview.status !== 'PAYMENT_PENDING') {\r\n            throw new BadRequestException(\r\n                `Interview is in ${application.interview.status} status. Payment not required.`,\r\n            );\r\n        }\r\n\r\n        // Check for existing successful payment for this interview\r\n        const existingPayment = await this.prisma.payment.findFirst({\r\n            where: {\r\n                applicationId,\r\n                status: PaymentStatus.SUCCESS,\r\n                amount: 99, // Interview fee\r\n            },\r\n        });\r\n\r\n        if (existingPayment) {\r\n            throw new BadRequestException('Interview payment already completed');\r\n        }\r\n\r\n        // Check for pending order\r\n        const pendingPayment = await this.prisma.payment.findFirst({\r\n            where: {\r\n                applicationId,\r\n                status: { in: [PaymentStatus.ORDER_CREATED, PaymentStatus.PENDING] },\r\n                amount: 99,\r\n            },\r\n        });\r\n\r\n        if (pendingPayment && pendingPayment.razorpayOrderId) {\r\n            return {\r\n                orderId: pendingPayment.razorpayOrderId,\r\n                amount: 99,\r\n                currency: 'INR',\r\n                paymentId: pendingPayment.id,\r\n                keyId: this.configService.get('RAZORPAY_KEY_ID'),\r\n            };\r\n        }\r\n\r\n        const amount = 9900; // ₹99 in paise\r\n\r\n        // Create Razorpay order\r\n        const razorpay = this.ensureRazorpay();\r\n        const order = await razorpay.orders.create({\r\n            amount,\r\n            currency: 'INR',\r\n            receipt: `int_${application.id.slice(0, 18)}`,\r\n            notes: {\r\n                applicationId: application.id,\r\n                interviewId: application.interview.id,\r\n                candidateId: application.candidateId,\r\n                type: 'INTERVIEW',\r\n            },\r\n        });\r\n\r\n        // Create payment record\r\n        const payment = await this.prisma.payment.create({\r\n            data: {\r\n                applicationId: application.id,\r\n                razorpayOrderId: order.id,\r\n                amount: 99,\r\n                currency: 'INR',\r\n                status: PaymentStatus.ORDER_CREATED,\r\n                orderCreatedAt: new Date(),\r\n            },\r\n        });\r\n\r\n        // Audit log\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.PAYMENT_INITIATED,\r\n                entityType: 'InterviewPayment',\r\n                entityId: payment.id,\r\n                metadata: { orderId: order.id, amount: 99, interviewId: application.interview.id },\r\n            },\r\n        });\r\n\r\n        return {\r\n            orderId: order.id,\r\n            amount: 99,\r\n            currency: 'INR',\r\n            paymentId: payment.id,\r\n            keyId: this.configService.get('RAZORPAY_KEY_ID'),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Verify interview payment and update interview status\r\n     */\r\n    async verifyInterviewPayment(userId: string, dto: VerifyPaymentDto) {\r\n        // Verify signature\r\n        const isValid = this.verifySignature(\r\n            dto.razorpayOrderId,\r\n            dto.razorpayPaymentId,\r\n            dto.razorpaySignature,\r\n        );\r\n\r\n        if (!isValid) {\r\n            throw new BadRequestException('Invalid payment signature');\r\n        }\r\n\r\n        // Get payment\r\n        const payment = await this.prisma.payment.findUnique({\r\n            where: { razorpayOrderId: dto.razorpayOrderId },\r\n            include: {\r\n                JobApplication: {\r\n                    include: {\r\n                        Candidate: { include: { User: true } },\r\n                        Interview: true,\r\n                        Job: { include: { HR: { include: { User: true } } } },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!payment) {\r\n            throw new NotFoundException('Payment not found');\r\n        }\r\n\r\n        if (payment.application.candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (payment.status === PaymentStatus.SUCCESS) {\r\n            return { success: true, message: 'Payment already verified' };\r\n        }\r\n\r\n        const interview = payment.application.Interview;\r\n        if (!interview) {\r\n            throw new BadRequestException('Interview not found');\r\n        }\r\n\r\n        // Update payment and interview in transaction\r\n        await this.prisma.$transaction(async (tx) => {\r\n            // Update payment status\r\n            await tx.payment.update({\r\n                where: { id: payment.id },\r\n                data: {\r\n                    razorpayPaymentId: dto.razorpayPaymentId,\r\n                    status: PaymentStatus.SUCCESS,\r\n                    paidAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Update interview status to READY_TO_SCHEDULE\r\n            await tx.interview.update({\r\n                where: { id: interview.id },\r\n                data: {\r\n                    status: 'READY_TO_SCHEDULE' as any,\r\n                    paymentStatus: PaymentStatus.SUCCESS as any,\r\n                    paidAt: new Date(),\r\n                },\r\n            });\r\n\r\n            // Audit log\r\n            await tx.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId,\r\n                    action: AuditAction.PAYMENT_SUCCESS,\r\n                    entityType: 'InterviewPayment',\r\n                    entityId: payment.id,\r\n                    metadata: {\r\n                        razorpayPaymentId: dto.razorpayPaymentId,\r\n                        interviewId: interview.id,\r\n                    },\r\n                },\r\n            });\r\n        });\r\n\r\n        // TODO: Send email notification to HR that payment is complete\r\n        // this.emailService.sendInterviewPaymentConfirmation(...)\r\n\r\n        return {\r\n            success: true,\r\n            message: 'Interview payment verified. HR will schedule your interview soon.',\r\n        };\r\n    }\r\n\r\n    // Signature verification helpers\r\n    private verifySignature(\r\n        orderId: string,\r\n        paymentId: string,\r\n        signature: string,\r\n    ): boolean {\r\n        const secret = this.configService.get('RAZORPAY_KEY_SECRET');\r\n        const body = `${orderId}|${paymentId}`;\r\n        const expectedSignature = crypto\r\n            .createHmac('sha256', secret)\r\n            .update(body)\r\n            .digest('hex');\r\n        return expectedSignature === signature;\r\n    }\r\n\r\n    private verifyWebhookSignature(payload: any, signature: string): boolean {\r\n        const secret = this.configService.get('RAZORPAY_WEBHOOK_SECRET');\r\n        const body = JSON.stringify(payload);\r\n        const expectedSignature = crypto\r\n            .createHmac('sha256', secret)\r\n            .update(body)\r\n            .digest('hex');\r\n        return expectedSignature === signature;\r\n    }\r\n}\r\n\r\n\r\n"],"names":["PaymentService","ensureRazorpay","razorpay","BadRequestException","createOrder","userId","dto","application","prisma","jobApplication","findUnique","where","id","applicationId","include","Candidate","Job","Referral","Payment","NotFoundException","candidate","ForbiddenException","status","ApplicationStatus","APPLIED","INTERVIEW_CONFIRMED","referral","ReferralStatus","CONFIRMED","successfulPayment","payments","find","p","PaymentStatus","SUCCESS","pendingPayment","ORDER_CREATED","PENDING","razorpayOrderId","orderId","amount","currency","paymentId","job","referralFee","order","orders","create","receipt","slice","notes","candidateId","jobId","payment","data","orderCreatedAt","Date","update","PAYMENT_PENDING","auditLog","crypto","randomUUID","action","AuditAction","PAYMENT_INITIATED","entityType","entityId","metadata","keyId","configService","get","verifyPayment","isValid","verifySignature","razorpayPaymentId","razorpaySignature","JobApplication","success","message","handleWebhook","payload","signature","verifyWebhookSignature","event","paymentData","entity","order_id","REFUNDED","processSuccessfulPayment","processFailedPayment","$transaction","tx","paidAt","webhookPayload","interview","paymentStatus","PAYMENT_SUCCESS","contactUnlockedAt","CONTACTED","FAILED","failureReason","error_description","PAYMENT_FAILED","error","getPaymentHistory","findMany","select","title","companyName","Refund","orderBy","createdAt","getPaymentById","requestRefund","refund","reason","RefundStatus","REQUESTED","REFUND_REQUESTED","createInterviewOrder","Interview","existingPayment","findFirst","in","interviewId","type","verifyInterviewPayment","User","HR","secret","body","expectedSignature","createHmac","digest","JSON","stringify","keySecret","Razorpay","key_id","key_secret","console","warn"],"mappings":"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"}