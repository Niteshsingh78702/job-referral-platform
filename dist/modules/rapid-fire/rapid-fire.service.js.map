{"version":3,"sources":["../../../src/modules/rapid-fire/rapid-fire.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  BadRequestException,\r\n  NotFoundException,\r\n  ForbiddenException,\r\n} from '@nestjs/common';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { QuestionBankService } from '../question-bank/question-bank.service';\r\n\r\ninterface SessionData {\r\n  userId: string;\r\n  candidateId: string;\r\n  skillBucketId: string;\r\n  testTemplateId: string;\r\n  questionIds: string[];\r\n  answers: Record<string, number>; // questionId -> selectedAnswer\r\n  startedAt: number;\r\n  endsAt: number;\r\n  status: 'ACTIVE' | 'SUBMITTED' | 'EXPIRED' | 'EXITED';\r\n}\r\n\r\n// In-memory session storage (in production, use Redis)\r\nconst activeSessions = new Map<string, SessionData>();\r\n\r\n@Injectable()\r\nexport class RapidFireTestService {\r\n  private readonly TEST_DURATION_MS = 20 * 60 * 1000; // 20 minutes\r\n\r\n  constructor(\r\n    private prisma: PrismaService,\r\n    private questionBankService: QuestionBankService,\r\n  ) { }\r\n\r\n  /**\r\n   * Check if candidate can take a test for a skill bucket\r\n   * Returns status with cooldown info\r\n   */\r\n  async canTakeTest(candidateId: string, skillBucketId: string) {\r\n    // Get skill bucket with test template\r\n    const skillBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n      include: { TestTemplate: true },\r\n    });\r\n\r\n    if (!skillBucket) {\r\n      throw new NotFoundException('Skill bucket not found');\r\n    }\r\n\r\n    if (!skillBucket.TestTemplate) {\r\n      throw new BadRequestException('No test configured for this skill');\r\n    }\r\n\r\n    // Check for valid passed test (within 7 days)\r\n    const validPassedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n      where: {\r\n        candidateId,\r\n        skillBucketId,\r\n        isPassed: true,\r\n        validTill: { gt: new Date() },\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n    });\r\n\r\n    if (validPassedAttempt) {\r\n      return {\r\n        canTake: false,\r\n        status: 'ALREADY_PASSED',\r\n        validTill: validPassedAttempt.validTill,\r\n        message: 'You have already passed this test',\r\n      };\r\n    }\r\n\r\n    // Check for recent failed test (24-hour cooldown)\r\n    const recentFailedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n      where: {\r\n        candidateId,\r\n        skillBucketId,\r\n        isPassed: false,\r\n        retestAllowedAt: { gt: new Date() },\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n    });\r\n\r\n    if (recentFailedAttempt) {\r\n      return {\r\n        canTake: false,\r\n        status: 'COOLDOWN',\r\n        retestAllowedAt: recentFailedAttempt.retestAllowedAt,\r\n        message: 'Please wait 24 hours before retaking the test',\r\n      };\r\n    }\r\n\r\n    // Check for active session (also clean up expired sessions)\r\n    for (const [sessionId, data] of activeSessions.entries()) {\r\n      // Skip sessions that have expired\r\n      if (Date.now() > data.endsAt) {\r\n        activeSessions.delete(sessionId);\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        data.candidateId === candidateId &&\r\n        data.skillBucketId === skillBucketId &&\r\n        data.status === 'ACTIVE'\r\n      ) {\r\n        return {\r\n          canTake: false,\r\n          status: 'IN_PROGRESS',\r\n          sessionId,\r\n          message: 'You have an active test session',\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      canTake: true,\r\n      status: 'AVAILABLE',\r\n      testTemplate: skillBucket.TestTemplate,\r\n      SkillBucket: {\r\n        id: skillBucket.id,\r\n        name: skillBucket.name,\r\n        displayName: skillBucket.displayName,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Start a rapid fire test\r\n   */\r\n  async startTest(userId: string, candidateId: string, skillBucketId: string) {\r\n    // Check if can take test\r\n    const eligibility = await this.canTakeTest(candidateId, skillBucketId);\r\n\r\n    if (!eligibility.canTake) {\r\n      // If there's an active session, include the sessionId in the error response\r\n      if (eligibility.sessionId) {\r\n        throw new BadRequestException({\r\n          message: eligibility.message,\r\n          sessionId: eligibility.sessionId,\r\n          status: eligibility.status,\r\n        });\r\n      }\r\n      throw new BadRequestException(eligibility.message);\r\n    }\r\n\r\n    const skillBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n      include: { TestTemplate: true },\r\n    });\r\n\r\n    const template = skillBucket!.TestTemplate!;\r\n\r\n    // Get random questions for this role\r\n    const questions = await this.questionBankService.getRandomQuestions({\r\n      count: template.questionPoolSize,\r\n      roleType: template.selectionRoleType || skillBucket!.code,\r\n      tags: template.selectionTags,\r\n    });\r\n\r\n    if (questions.length === 0) {\r\n      throw new BadRequestException('No questions available for this test');\r\n    }\r\n\r\n    // Create session ID\r\n    const sessionId = `rf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    const now = Date.now();\r\n\r\n    // Store session data\r\n    const sessionData: SessionData = {\r\n      userId,\r\n      candidateId,\r\n      skillBucketId,\r\n      testTemplateId: template.id,\r\n      questionIds: questions.map((q) => q.id),\r\n      answers: {},\r\n      startedAt: now,\r\n      endsAt: now + this.TEST_DURATION_MS,\r\n      status: 'ACTIVE',\r\n    };\r\n\r\n    activeSessions.set(sessionId, sessionData);\r\n\r\n    // Create database record (no applicationId needed for rapid fire tests)\r\n    await this.prisma.testSession.create({\r\n      data: {\r\n        id: sessionId,\r\n        testTemplateId: template.id,\r\n        status: 'ACTIVE',\r\n        startedAt: new Date(now),\r\n        endsAt: new Date(now + this.TEST_DURATION_MS),\r\n        totalQuestions: questions.length,\r\n        selectedQuestionIds: questions.map((q) => q.id),\r\n      },\r\n    });\r\n\r\n    return {\r\n      sessionId,\r\n      testName: template.name,\r\n      duration: template.duration,\r\n      totalQuestionBank: questions.length,\r\n      remainingTime: Math.floor(this.TEST_DURATION_MS / 1000),\r\n      startedAt: new Date(now).toISOString(),\r\n      endsAt: new Date(now + this.TEST_DURATION_MS).toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get test state with all questions\r\n   */\r\n  async getTestState(sessionId: string, userId: string) {\r\n    const session = await this.validateSession(sessionId, userId);\r\n\r\n    // Get all questions\r\n    const questions = await this.prisma.questionBank.findMany({\r\n      where: { id: { in: session.questionIds } },\r\n      select: {\r\n        id: true,\r\n        question: true,\r\n        options: true,\r\n        difficulty: true,\r\n        // Don't include correctAnswer!\r\n      },\r\n    });\r\n\r\n    // Map to include answer status\r\n    const questionsWithStatus = session.questionIds.map((qId, index) => {\r\n      const question = questions.find((q) => q.id === qId);\r\n      return {\r\n        index: index + 1,\r\n        id: qId,\r\n        question: question?.question,\r\n        options: question?.options,\r\n        difficulty: question?.difficulty,\r\n        answered: session.answers[qId] !== undefined,\r\n        selectedAnswer: session.answers[qId],\r\n      };\r\n    });\r\n\r\n    const now = Date.now();\r\n    const remainingTime = Math.max(\r\n      0,\r\n      Math.floor((session.endsAt - now) / 1000),\r\n    );\r\n\r\n    // Auto-submit if time expired\r\n    if (remainingTime <= 0 && session.status === 'ACTIVE') {\r\n      await this.submitTest(sessionId, userId, true);\r\n      throw new BadRequestException(\r\n        'Test time has expired. Your answers have been auto-submitted.',\r\n      );\r\n    }\r\n\r\n    return {\r\n      sessionId,\r\n      status: session.status,\r\n      totalQuestionBank: session.questionIds.length,\r\n      answeredCount: Object.keys(session.answers).length,\r\n      remainingTime,\r\n      QuestionBank: questionsWithStatus,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Submit answer for a question\r\n   */\r\n  async submitAnswer(\r\n    sessionId: string,\r\n    userId: string,\r\n    questionId: string,\r\n    selectedAnswer: number,\r\n  ) {\r\n    const session = await this.validateSession(sessionId, userId);\r\n\r\n    // Check if question belongs to this session\r\n    if (!session.questionIds.includes(questionId)) {\r\n      throw new BadRequestException('Question not part of this test');\r\n    }\r\n\r\n    // Validate answer range\r\n    if (selectedAnswer < 0 || selectedAnswer > 3) {\r\n      throw new BadRequestException('Invalid answer selection');\r\n    }\r\n\r\n    // Save answer (allows changing - going back)\r\n    session.answers[questionId] = selectedAnswer;\r\n\r\n    return {\r\n      success: true,\r\n      answeredCount: Object.keys(session.answers).length,\r\n      totalQuestionBank: session.questionIds.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Submit the entire test\r\n   */\r\n  async submitTest(sessionId: string, userId: string, isAutoSubmit = false) {\r\n    const session = activeSessions.get(sessionId);\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Test session not found');\r\n    }\r\n\r\n    if (session.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized');\r\n    }\r\n\r\n    if (session.status !== 'ACTIVE') {\r\n      throw new BadRequestException('Test already submitted');\r\n    }\r\n\r\n    // Calculate score\r\n    const questions = await this.prisma.questionBank.findMany({\r\n      where: { id: { in: session.questionIds } },\r\n      select: { id: true, correctAnswer: true, explanation: true },\r\n    });\r\n\r\n    let correctCount = 0;\r\n    const results: any[] = [];\r\n\r\n    questions.forEach((q) => {\r\n      const userAnswer = session.answers[q.id];\r\n      const isCorrect = userAnswer === q.correctAnswer;\r\n      if (isCorrect) correctCount++;\r\n\r\n      results.push({\r\n        questionId: q.id,\r\n        userAnswer,\r\n        correctAnswer: q.correctAnswer,\r\n        isCorrect,\r\n        explanation: q.explanation,\r\n      });\r\n    });\r\n\r\n    const totalQuestions = session.questionIds.length;\r\n    const score =\r\n      totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;\r\n\r\n    // Get passing criteria from template\r\n    const template = await this.prisma.testTemplate.findUnique({\r\n      where: { id: session.testTemplateId },\r\n    });\r\n\r\n    const passingScore = template?.passingCriteria || 70;\r\n    const isPassed = score >= passingScore;\r\n\r\n    // Update session status\r\n    session.status = 'SUBMITTED';\r\n\r\n    // Create skill test attempt record\r\n    const attemptedAt = new Date();\r\n    await this.prisma.skillTestAttempt.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        candidateId: session.candidateId,\r\n        skillBucketId: session.skillBucketId,\r\n        isPassed,\r\n        score,\r\n        attemptedAt,\r\n        validTill: isPassed\r\n          ? new Date(attemptedAt.getTime() + 7 * 24 * 60 * 60 * 1000)\r\n          : null,\r\n        retestAllowedAt: isPassed\r\n          ? null\r\n          : new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n        testSessionId: sessionId,\r\n      },\r\n    });\r\n\r\n    // Update test session in DB\r\n    await this.prisma.testSession.update({\r\n      where: { id: sessionId },\r\n      data: {\r\n        status: isAutoSubmit ? 'AUTO_SUBMITTED' : 'SUBMITTED',\r\n        submittedAt: new Date(),\r\n        score,\r\n        correctAnswers: correctCount,\r\n        isPassed,\r\n      },\r\n    });\r\n\r\n    // Clean up session from memory\r\n    activeSessions.delete(sessionId);\r\n\r\n    return {\r\n      success: true,\r\n      isAutoSubmit,\r\n      score: Math.round(score * 10) / 10,\r\n      correctCount,\r\n      totalQuestions,\r\n      isPassed,\r\n      passingScore,\r\n      message: isPassed\r\n        ? 'ðŸŽ‰ Congratulations! You passed the test!'\r\n        : `You scored ${score.toFixed(1)}%. You need ${passingScore}% to pass. You can retry after 24 hours.`,\r\n      results: isPassed ? undefined : results, // Only show details if failed\r\n      retestAllowedAt: isPassed\r\n        ? null\r\n        : new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Exit test (marks as failed)\r\n   */\r\n  async exitTest(sessionId: string, userId: string) {\r\n    const session = activeSessions.get(sessionId);\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Test session not found');\r\n    }\r\n\r\n    if (session.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized');\r\n    }\r\n\r\n    if (session.status !== 'ACTIVE') {\r\n      throw new BadRequestException('Test already completed');\r\n    }\r\n\r\n    // Mark as failed with 0 score\r\n    session.status = 'EXITED';\r\n\r\n    // Create failed attempt\r\n    const attemptedAt = new Date();\r\n    await this.prisma.skillTestAttempt.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        candidateId: session.candidateId,\r\n        skillBucketId: session.skillBucketId,\r\n        isPassed: false,\r\n        score: 0,\r\n        attemptedAt,\r\n        validTill: null,\r\n        retestAllowedAt: new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n        testSessionId: sessionId,\r\n      },\r\n    });\r\n\r\n    // Update test session in DB\r\n    await this.prisma.testSession.update({\r\n      where: { id: sessionId },\r\n      data: {\r\n        status: 'EXPIRED', // Using EXPIRED for exited tests\r\n        submittedAt: new Date(),\r\n        score: 0,\r\n        correctAnswers: 0,\r\n        isPassed: false,\r\n      },\r\n    });\r\n\r\n    // Clean up\r\n    activeSessions.delete(sessionId);\r\n\r\n    return {\r\n      success: true,\r\n      message:\r\n        'Test exited. This counts as a failed attempt. You can retry after 24 hours.',\r\n      retestAllowedAt: new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate session and check authorization\r\n   * Returns session data or throws appropriate error\r\n   */\r\n  private async validateSession(sessionId: string, userId: string): Promise<SessionData> {\r\n    let session = activeSessions.get(sessionId);\r\n\r\n    // If not in memory, try to restore from database\r\n    if (!session) {\r\n      session = await this.restoreSessionFromDb(sessionId, userId);\r\n    }\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Test session not found or expired');\r\n    }\r\n\r\n    if (session.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized to access this test');\r\n    }\r\n\r\n    if (session.status !== 'ACTIVE') {\r\n      throw new BadRequestException('Test is no longer active');\r\n    }\r\n\r\n    // Check time expiry\r\n    if (Date.now() > session.endsAt) {\r\n      session.status = 'EXPIRED';\r\n      throw new BadRequestException('Test time has expired');\r\n    }\r\n\r\n    return session;\r\n  }\r\n\r\n  /**\r\n   * Restore session from database if server restarted\r\n   */\r\n  private async restoreSessionFromDb(sessionId: string, userId: string): Promise<SessionData | null> {\r\n    try {\r\n      const dbSession = await this.prisma.testSession.findUnique({\r\n        where: { id: sessionId },\r\n        include: { TestTemplate: { include: { SkillBucket: true } } },\r\n      });\r\n\r\n      if (!dbSession) {\r\n        console.log(`Session ${sessionId} not found in database`);\r\n        return null;\r\n      }\r\n\r\n      // Check if session is active and not expired\r\n      if (dbSession.status !== 'ACTIVE' || !dbSession.endsAt || new Date() > dbSession.endsAt) {\r\n        console.log(`Session ${sessionId} is not active or expired`);\r\n        return null;\r\n      }\r\n\r\n      // Get the user's candidate record\r\n      const user = await this.prisma.user.findUnique({\r\n        where: { id: userId },\r\n        select: { id: true, Candidate: { select: { id: true } } },\r\n      });\r\n\r\n      if (!user?.Candidate?.id) {\r\n        console.log(`User ${userId} has no candidate record`);\r\n        return null;\r\n      }\r\n\r\n      // Get skillBucketId from the first SkillBucket in the array\r\n      // TestTemplate has SkillBucket as an array relation\r\n      const skillBuckets = dbSession.TestTemplate?.SkillBucket || [];\r\n      const skillBucketId = skillBuckets.length > 0 ? skillBuckets[0].id : '';\r\n\r\n      // Restore session data\r\n      const sessionData: SessionData = {\r\n        userId: userId,\r\n        candidateId: user.Candidate.id,\r\n        skillBucketId: skillBucketId,\r\n        testTemplateId: dbSession.testTemplateId || '',\r\n        questionIds: dbSession.selectedQuestionIds || [],\r\n        answers: {}, // Answers are lost after restart - user needs to re-answer\r\n        startedAt: dbSession.startedAt?.getTime() || Date.now(),\r\n        endsAt: dbSession.endsAt.getTime(),\r\n        status: 'ACTIVE',\r\n      };\r\n\r\n      // Store back in memory\r\n      activeSessions.set(sessionId, sessionData);\r\n\r\n      console.log(`Session ${sessionId} restored from database for user ${userId}, candidateId: ${user.Candidate.id}`);\r\n      return sessionData;\r\n    } catch (error) {\r\n      console.error('Error restoring session from DB:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get test history for a candidate\r\n   */\r\n\r\n  async getTestHistory(candidateId: string) {\r\n    const attempts = await this.prisma.skillTestAttempt.findMany({\r\n      where: { candidateId },\r\n      include: {\r\n        SkillBucket: {\r\n          select: { id: true, name: true, displayName: true },\r\n        },\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n      take: 20,\r\n    });\r\n\r\n    return attempts.map((a) => ({\r\n      id: a.id,\r\n      SkillBucket: a.SkillBucket,\r\n      score: a.score,\r\n      isPassed: a.isPassed,\r\n      attemptedAt: a.attemptedAt,\r\n      validTill: a.validTill,\r\n      retestAllowedAt: a.retestAllowedAt,\r\n    }));\r\n  }\r\n}\r\n"],"names":["RapidFireTestService","activeSessions","Map","canTakeTest","candidateId","skillBucketId","skillBucket","prisma","findUnique","where","id","include","TestTemplate","NotFoundException","BadRequestException","validPassedAttempt","skillTestAttempt","findFirst","isPassed","validTill","gt","Date","orderBy","attemptedAt","canTake","status","message","recentFailedAttempt","retestAllowedAt","sessionId","data","entries","now","endsAt","delete","testTemplate","SkillBucket","name","displayName","startTest","userId","eligibility","template","questions","questionBankService","getRandomQuestions","count","questionPoolSize","roleType","selectionRoleType","code","tags","selectionTags","length","Math","random","toString","substr","sessionData","testTemplateId","questionIds","map","q","answers","startedAt","TEST_DURATION_MS","set","testSession","create","totalQuestions","selectedQuestionIds","testName","duration","totalQuestionBank","remainingTime","floor","toISOString","getTestState","session","validateSession","questionBank","findMany","in","select","question","options","difficulty","questionsWithStatus","qId","index","find","answered","undefined","selectedAnswer","max","submitTest","answeredCount","Object","keys","QuestionBank","submitAnswer","questionId","includes","success","isAutoSubmit","get","ForbiddenException","correctAnswer","explanation","correctCount","results","forEach","userAnswer","isCorrect","push","score","passingScore","passingCriteria","crypto","randomUUID","getTime","testSessionId","update","submittedAt","correctAnswers","round","toFixed","exitTest","restoreSessionFromDb","dbSession","console","log","user","Candidate","skillBuckets","error","getTestHistory","attempts","take","a"],"mappings":"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"}