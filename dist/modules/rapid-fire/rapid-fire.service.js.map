{"version":3,"sources":["../../../src/modules/rapid-fire/rapid-fire.service.ts"],"sourcesContent":["import { Injectable, BadRequestException, NotFoundException, ForbiddenException } from '@nestjs/common';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { QuestionBankService } from '../question-bank/question-bank.service';\r\n\r\ninterface SessionData {\r\n    userId: string;\r\n    candidateId: string;\r\n    skillBucketId: string;\r\n    testTemplateId: string;\r\n    questionIds: string[];\r\n    answers: Record<string, number>; // questionId -> selectedAnswer\r\n    startedAt: number;\r\n    endsAt: number;\r\n    status: 'ACTIVE' | 'SUBMITTED' | 'EXPIRED' | 'EXITED';\r\n}\r\n\r\n// In-memory session storage (in production, use Redis)\r\nconst activeSessions = new Map<string, SessionData>();\r\n\r\n@Injectable()\r\nexport class RapidFireTestService {\r\n    private readonly TEST_DURATION_MS = 20 * 60 * 1000; // 20 minutes\r\n\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private questionBankService: QuestionBankService,\r\n    ) { }\r\n\r\n    /**\r\n     * Check if candidate can take a test for a skill bucket\r\n     * Returns status with cooldown info\r\n     */\r\n    async canTakeTest(candidateId: string, skillBucketId: string) {\r\n        // Get skill bucket with test template\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id: skillBucketId },\r\n            include: { TestTemplate: true },\r\n        });\r\n\r\n        if (!skillBucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        if (!skillBucket.TestTemplate) {\r\n            throw new BadRequestException('No test configured for this skill');\r\n        }\r\n\r\n        // Check for valid passed test (within 7 days)\r\n        const validPassedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n            where: {\r\n                candidateId,\r\n                skillBucketId,\r\n                isPassed: true,\r\n                validTill: { gt: new Date() },\r\n            },\r\n            orderBy: { attemptedAt: 'desc' },\r\n        });\r\n\r\n        if (validPassedAttempt) {\r\n            return {\r\n                canTake: false,\r\n                status: 'ALREADY_PASSED',\r\n                validTill: validPassedAttempt.validTill,\r\n                message: 'You have already passed this test',\r\n            };\r\n        }\r\n\r\n        // Check for recent failed test (24-hour cooldown)\r\n        const recentFailedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n            where: {\r\n                candidateId,\r\n                skillBucketId,\r\n                isPassed: false,\r\n                retestAllowedAt: { gt: new Date() },\r\n            },\r\n            orderBy: { attemptedAt: 'desc' },\r\n        });\r\n\r\n        if (recentFailedAttempt) {\r\n            return {\r\n                canTake: false,\r\n                status: 'COOLDOWN',\r\n                retestAllowedAt: recentFailedAttempt.retestAllowedAt,\r\n                message: 'Please wait 24 hours before retaking the test',\r\n            };\r\n        }\r\n\r\n        // Check for active session\r\n        for (const [sessionId, data] of activeSessions.entries()) {\r\n            if (data.candidateId === candidateId && data.skillBucketId === skillBucketId && data.status === 'ACTIVE') {\r\n                return {\r\n                    canTake: false,\r\n                    status: 'IN_PROGRESS',\r\n                    sessionId,\r\n                    message: 'You have an active test session',\r\n                };\r\n            }\r\n        }\r\n\r\n        return {\r\n            canTake: true,\r\n            status: 'AVAILABLE',\r\n            testTemplate: skillBucket.TestTemplate,\r\n            SkillBucket: {\r\n                id: skillBucket.id,\r\n                name: skillBucket.name,\r\n                displayName: skillBucket.displayName,\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Start a rapid fire test\r\n     */\r\n    async startTest(userId: string, candidateId: string, skillBucketId: string) {\r\n        // Check if can take test\r\n        const eligibility = await this.canTakeTest(candidateId, skillBucketId);\r\n\r\n        if (!eligibility.canTake) {\r\n            throw new BadRequestException(eligibility.message);\r\n        }\r\n\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id: skillBucketId },\r\n            include: { TestTemplate: true },\r\n        });\r\n\r\n        const template = skillBucket!.TestTemplate!;\r\n\r\n        // Get random questions for this role\r\n        const questions = await this.questionBankService.getRandomQuestions({\r\n            count: template.questionPoolSize,\r\n            roleType: template.selectionRoleType || skillBucket!.code,\r\n            tags: template.selectionTags,\r\n        });\r\n\r\n        if (questions.length === 0) {\r\n            throw new BadRequestException('No questions available for this test');\r\n        }\r\n\r\n        // Create session ID\r\n        const sessionId = `rf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n        const now = Date.now();\r\n\r\n        // Store session data\r\n        const sessionData: SessionData = {\r\n            userId,\r\n            candidateId,\r\n            skillBucketId,\r\n            testTemplateId: template.id,\r\n            questionIds: questions.map(q => q.id),\r\n            answers: {},\r\n            startedAt: now,\r\n            endsAt: now + this.TEST_DURATION_MS,\r\n            status: 'ACTIVE',\r\n        };\r\n\r\n        activeSessions.set(sessionId, sessionData);\r\n\r\n        // Create database record (no applicationId needed for rapid fire tests)\r\n        await this.prisma.testSession.create({\r\n            data: {\r\n                id: sessionId,\r\n                testTemplateId: template.id,\r\n                status: 'ACTIVE',\r\n                startedAt: new Date(now),\r\n                endsAt: new Date(now + this.TEST_DURATION_MS),\r\n                totalQuestions: questions.length,\r\n                selectedQuestionIds: questions.map(q => q.id),\r\n            },\r\n        });\r\n\r\n        return {\r\n            sessionId,\r\n            testName: template.name,\r\n            duration: template.duration,\r\n            totalQuestionBank: questions.length,\r\n            remainingTime: Math.floor(this.TEST_DURATION_MS / 1000),\r\n            startedAt: new Date(now).toISOString(),\r\n            endsAt: new Date(now + this.TEST_DURATION_MS).toISOString(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get test state with all questions\r\n     */\r\n    async getTestState(sessionId: string, userId: string) {\r\n        const session = this.validateSession(sessionId, userId);\r\n\r\n        // Get all questions\r\n        const questions = await this.prisma.questionBank.findMany({\r\n            where: { id: { in: session.questionIds } },\r\n            select: {\r\n                id: true,\r\n                question: true,\r\n                options: true,\r\n                difficulty: true,\r\n                // Don't include correctAnswer!\r\n            },\r\n        });\r\n\r\n        // Map to include answer status\r\n        const questionsWithStatus = session.questionIds.map((qId, index) => {\r\n            const question = questions.find(q => q.id === qId);\r\n            return {\r\n                index: index + 1,\r\n                id: qId,\r\n                question: question?.question,\r\n                options: question?.options,\r\n                difficulty: question?.difficulty,\r\n                answered: session.answers[qId] !== undefined,\r\n                selectedAnswer: session.answers[qId],\r\n            };\r\n        });\r\n\r\n        const now = Date.now();\r\n        const remainingTime = Math.max(0, Math.floor((session.endsAt - now) / 1000));\r\n\r\n        // Auto-submit if time expired\r\n        if (remainingTime <= 0 && session.status === 'ACTIVE') {\r\n            await this.submitTest(sessionId, userId, true);\r\n            throw new BadRequestException('Test time has expired. Your answers have been auto-submitted.');\r\n        }\r\n\r\n        return {\r\n            sessionId,\r\n            status: session.status,\r\n            totalQuestionBank: session.questionIds.length,\r\n            answeredCount: Object.keys(session.answers).length,\r\n            remainingTime,\r\n            QuestionBank: questionsWithStatus,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Submit answer for a question\r\n     */\r\n    async submitAnswer(sessionId: string, userId: string, questionId: string, selectedAnswer: number) {\r\n        const session = this.validateSession(sessionId, userId);\r\n\r\n        // Check if question belongs to this session\r\n        if (!session.questionIds.includes(questionId)) {\r\n            throw new BadRequestException('Question not part of this test');\r\n        }\r\n\r\n        // Validate answer range\r\n        if (selectedAnswer < 0 || selectedAnswer > 3) {\r\n            throw new BadRequestException('Invalid answer selection');\r\n        }\r\n\r\n        // Save answer (allows changing - going back)\r\n        session.answers[questionId] = selectedAnswer;\r\n\r\n        return {\r\n            success: true,\r\n            answeredCount: Object.keys(session.answers).length,\r\n            totalQuestionBank: session.questionIds.length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Submit the entire test\r\n     */\r\n    async submitTest(sessionId: string, userId: string, isAutoSubmit = false) {\r\n        const session = activeSessions.get(sessionId);\r\n\r\n        if (!session) {\r\n            throw new NotFoundException('Test session not found');\r\n        }\r\n\r\n        if (session.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (session.status !== 'ACTIVE') {\r\n            throw new BadRequestException('Test already submitted');\r\n        }\r\n\r\n        // Calculate score\r\n        const questions = await this.prisma.questionBank.findMany({\r\n            where: { id: { in: session.questionIds } },\r\n            select: { id: true, correctAnswer: true, explanation: true },\r\n        });\r\n\r\n        let correctCount = 0;\r\n        const results: any[] = [];\r\n\r\n        questions.forEach(q => {\r\n            const userAnswer = session.answers[q.id];\r\n            const isCorrect = userAnswer === q.correctAnswer;\r\n            if (isCorrect) correctCount++;\r\n\r\n            results.push({\r\n                questionId: q.id,\r\n                userAnswer,\r\n                correctAnswer: q.correctAnswer,\r\n                isCorrect,\r\n                explanation: q.explanation,\r\n            });\r\n        });\r\n\r\n        const totalQuestions = session.questionIds.length;\r\n        const score = totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;\r\n\r\n        // Get passing criteria from template\r\n        const template = await this.prisma.testTemplate.findUnique({\r\n            where: { id: session.testTemplateId },\r\n        });\r\n\r\n        const passingScore = template?.passingCriteria || 70;\r\n        const isPassed = score >= passingScore;\r\n\r\n        // Update session status\r\n        session.status = 'SUBMITTED';\r\n\r\n        // Create skill test attempt record\r\n        const attemptedAt = new Date();\r\n        await this.prisma.skillTestAttempt.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                candidateId: session.candidateId,\r\n                skillBucketId: session.skillBucketId,\r\n                isPassed,\r\n                score,\r\n                attemptedAt,\r\n                validTill: isPassed ? new Date(attemptedAt.getTime() + 7 * 24 * 60 * 60 * 1000) : null,\r\n                retestAllowedAt: isPassed ? null : new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n                testSessionId: sessionId,\r\n            },\r\n        });\r\n\r\n        // Update test session in DB\r\n        await this.prisma.testSession.update({\r\n            where: { id: sessionId },\r\n            data: {\r\n                status: isAutoSubmit ? 'AUTO_SUBMITTED' : 'SUBMITTED',\r\n                submittedAt: new Date(),\r\n                score,\r\n                correctAnswers: correctCount,\r\n                isPassed,\r\n            },\r\n        });\r\n\r\n        // Clean up session from memory\r\n        activeSessions.delete(sessionId);\r\n\r\n        return {\r\n            success: true,\r\n            isAutoSubmit,\r\n            score: Math.round(score * 10) / 10,\r\n            correctCount,\r\n            totalQuestions,\r\n            isPassed,\r\n            passingScore,\r\n            message: isPassed\r\n                ? 'ðŸŽ‰ Congratulations! You passed the test!'\r\n                : `You scored ${score.toFixed(1)}%. You need ${passingScore}% to pass. You can retry after 24 hours.`,\r\n            results: isPassed ? undefined : results, // Only show details if failed\r\n            retestAllowedAt: isPassed ? null : new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Exit test (marks as failed)\r\n     */\r\n    async exitTest(sessionId: string, userId: string) {\r\n        const session = activeSessions.get(sessionId);\r\n\r\n        if (!session) {\r\n            throw new NotFoundException('Test session not found');\r\n        }\r\n\r\n        if (session.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (session.status !== 'ACTIVE') {\r\n            throw new BadRequestException('Test already completed');\r\n        }\r\n\r\n        // Mark as failed with 0 score\r\n        session.status = 'EXITED';\r\n\r\n        // Create failed attempt\r\n        const attemptedAt = new Date();\r\n        await this.prisma.skillTestAttempt.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                candidateId: session.candidateId,\r\n                skillBucketId: session.skillBucketId,\r\n                isPassed: false,\r\n                score: 0,\r\n                attemptedAt,\r\n                validTill: null,\r\n                retestAllowedAt: new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n                testSessionId: sessionId,\r\n            },\r\n        });\r\n\r\n        // Update test session in DB\r\n        await this.prisma.testSession.update({\r\n            where: { id: sessionId },\r\n            data: {\r\n                status: 'EXPIRED', // Using EXPIRED for exited tests\r\n                submittedAt: new Date(),\r\n                score: 0,\r\n                correctAnswers: 0,\r\n                isPassed: false,\r\n            },\r\n        });\r\n\r\n        // Clean up\r\n        activeSessions.delete(sessionId);\r\n\r\n        return {\r\n            success: true,\r\n            message: 'Test exited. This counts as a failed attempt. You can retry after 24 hours.',\r\n            retestAllowedAt: new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Validate session and check authorization\r\n     */\r\n    private validateSession(sessionId: string, userId: string): SessionData {\r\n        const session = activeSessions.get(sessionId);\r\n\r\n        if (!session) {\r\n            throw new NotFoundException('Test session not found or expired');\r\n        }\r\n\r\n        if (session.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized to access this test');\r\n        }\r\n\r\n        if (session.status !== 'ACTIVE') {\r\n            throw new BadRequestException('Test is no longer active');\r\n        }\r\n\r\n        // Check time expiry\r\n        if (Date.now() > session.endsAt) {\r\n            session.status = 'EXPIRED';\r\n            throw new BadRequestException('Test time has expired');\r\n        }\r\n\r\n        return session;\r\n    }\r\n\r\n    /**\r\n     * Get test history for a candidate\r\n     */\r\n\r\n    async getTestHistory(candidateId: string) {\r\n        const attempts = await this.prisma.skillTestAttempt.findMany({\r\n            where: { candidateId },\r\n            include: {\r\n                SkillBucket: {\r\n                    select: { id: true, name: true, displayName: true },\r\n                },\r\n            },\r\n            orderBy: { attemptedAt: 'desc' },\r\n            take: 20,\r\n        });\r\n\r\n        return attempts.map(a => ({\r\n            id: a.id,\r\n            SkillBucket: a.SkillBucket,\r\n            score: a.score,\r\n            isPassed: a.isPassed,\r\n            attemptedAt: a.attemptedAt,\r\n            validTill: a.validTill,\r\n            retestAllowedAt: a.retestAllowedAt,\r\n        }));\r\n    }\r\n}\r\n"],"names":["RapidFireTestService","activeSessions","Map","canTakeTest","candidateId","skillBucketId","skillBucket","prisma","findUnique","where","id","include","TestTemplate","NotFoundException","BadRequestException","validPassedAttempt","skillTestAttempt","findFirst","isPassed","validTill","gt","Date","orderBy","attemptedAt","canTake","status","message","recentFailedAttempt","retestAllowedAt","sessionId","data","entries","testTemplate","SkillBucket","name","displayName","startTest","userId","eligibility","template","questions","questionBankService","getRandomQuestions","count","questionPoolSize","roleType","selectionRoleType","code","tags","selectionTags","length","now","Math","random","toString","substr","sessionData","testTemplateId","questionIds","map","q","answers","startedAt","endsAt","TEST_DURATION_MS","set","testSession","create","totalQuestions","selectedQuestionIds","testName","duration","totalQuestionBank","remainingTime","floor","toISOString","getTestState","session","validateSession","questionBank","findMany","in","select","question","options","difficulty","questionsWithStatus","qId","index","find","answered","undefined","selectedAnswer","max","submitTest","answeredCount","Object","keys","QuestionBank","submitAnswer","questionId","includes","success","isAutoSubmit","get","ForbiddenException","correctAnswer","explanation","correctCount","results","forEach","userAnswer","isCorrect","push","score","passingScore","passingCriteria","crypto","randomUUID","getTime","testSessionId","update","submittedAt","correctAnswers","delete","round","toFixed","exitTest","getTestHistory","attempts","take","a"],"mappings":"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"}