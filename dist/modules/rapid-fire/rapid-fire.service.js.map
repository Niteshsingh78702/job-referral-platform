{"version":3,"sources":["../../../src/modules/rapid-fire/rapid-fire.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  BadRequestException,\r\n  NotFoundException,\r\n  ForbiddenException,\r\n} from '@nestjs/common';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { QuestionBankService } from '../question-bank/question-bank.service';\r\n\r\ninterface SessionData {\r\n  userId: string;\r\n  candidateId: string;\r\n  skillBucketId: string;\r\n  testTemplateId: string;\r\n  questionIds: string[];\r\n  answers: Record<string, number>; // questionId -> selectedAnswer\r\n  startedAt: number;\r\n  endsAt: number;\r\n  status: 'ACTIVE' | 'SUBMITTED' | 'EXPIRED' | 'EXITED';\r\n}\r\n\r\n// In-memory session storage (in production, use Redis)\r\nconst activeSessions = new Map<string, SessionData>();\r\n\r\n@Injectable()\r\nexport class RapidFireTestService {\r\n  private readonly TEST_DURATION_MS = 20 * 60 * 1000; // 20 minutes\r\n\r\n  constructor(\r\n    private prisma: PrismaService,\r\n    private questionBankService: QuestionBankService,\r\n  ) { }\r\n\r\n  /**\r\n   * Check if candidate can take a test for a skill bucket\r\n   * Returns status with cooldown info\r\n   */\r\n  async canTakeTest(candidateId: string, skillBucketId: string) {\r\n    // Get skill bucket with test template\r\n    const skillBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n      include: { TestTemplate: true },\r\n    });\r\n\r\n    if (!skillBucket) {\r\n      throw new NotFoundException('Skill bucket not found');\r\n    }\r\n\r\n    if (!skillBucket.TestTemplate) {\r\n      throw new BadRequestException('No test configured for this skill');\r\n    }\r\n\r\n    // Check for valid passed test (within 7 days)\r\n    const validPassedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n      where: {\r\n        candidateId,\r\n        skillBucketId,\r\n        isPassed: true,\r\n        validTill: { gt: new Date() },\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n    });\r\n\r\n    if (validPassedAttempt) {\r\n      return {\r\n        canTake: false,\r\n        status: 'ALREADY_PASSED',\r\n        validTill: validPassedAttempt.validTill,\r\n        message: 'You have already passed this test',\r\n      };\r\n    }\r\n\r\n    // Check for recent failed test (24-hour cooldown)\r\n    const recentFailedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n      where: {\r\n        candidateId,\r\n        skillBucketId,\r\n        isPassed: false,\r\n        retestAllowedAt: { gt: new Date() },\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n    });\r\n\r\n    if (recentFailedAttempt) {\r\n      return {\r\n        canTake: false,\r\n        status: 'COOLDOWN',\r\n        retestAllowedAt: recentFailedAttempt.retestAllowedAt,\r\n        message: 'Please wait 24 hours before retaking the test',\r\n      };\r\n    }\r\n\r\n    // Check for active session (also clean up expired sessions)\r\n    for (const [sessionId, data] of activeSessions.entries()) {\r\n      // Skip sessions that have expired\r\n      if (Date.now() > data.endsAt) {\r\n        activeSessions.delete(sessionId);\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        data.candidateId === candidateId &&\r\n        data.skillBucketId === skillBucketId &&\r\n        data.status === 'ACTIVE'\r\n      ) {\r\n        return {\r\n          canTake: false,\r\n          status: 'IN_PROGRESS',\r\n          sessionId,\r\n          message: 'You have an active test session',\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      canTake: true,\r\n      status: 'AVAILABLE',\r\n      testTemplate: skillBucket.TestTemplate,\r\n      SkillBucket: {\r\n        id: skillBucket.id,\r\n        name: skillBucket.name,\r\n        displayName: skillBucket.displayName,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Start a rapid fire test\r\n   */\r\n  async startTest(userId: string, candidateId: string | undefined, skillBucketId: string) {\r\n    // Ensure candidateId is valid - look up from DB if not provided\r\n    let resolvedCandidateId = candidateId;\r\n    if (!resolvedCandidateId) {\r\n      const user = await this.prisma.user.findUnique({\r\n        where: { id: userId },\r\n        select: { Candidate: { select: { id: true } } },\r\n      });\r\n      resolvedCandidateId = user?.Candidate?.id;\r\n      if (!resolvedCandidateId) {\r\n        throw new BadRequestException('Candidate profile not found. Please complete your profile first.');\r\n      }\r\n      console.log(`Resolved candidateId ${resolvedCandidateId} from database for user ${userId}`);\r\n    }\r\n\r\n    // Check if can take test\r\n    const eligibility = await this.canTakeTest(resolvedCandidateId, skillBucketId);\r\n\r\n    if (!eligibility.canTake) {\r\n      // If there's an active session, include the sessionId in the error response\r\n      if (eligibility.sessionId) {\r\n        throw new BadRequestException({\r\n          message: eligibility.message,\r\n          sessionId: eligibility.sessionId,\r\n          status: eligibility.status,\r\n        });\r\n      }\r\n      throw new BadRequestException(eligibility.message);\r\n    }\r\n\r\n    const skillBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n      include: { TestTemplate: true },\r\n    });\r\n\r\n    const template = skillBucket!.TestTemplate!;\r\n\r\n    // Get random questions for this role\r\n    const questions = await this.questionBankService.getRandomQuestions({\r\n      count: template.questionPoolSize,\r\n      roleType: template.selectionRoleType || skillBucket!.code,\r\n      tags: template.selectionTags,\r\n    });\r\n\r\n    if (questions.length === 0) {\r\n      throw new BadRequestException('No questions available for this test');\r\n    }\r\n\r\n    // Create session ID\r\n    const sessionId = `rf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    const now = Date.now();\r\n\r\n    // Store session data\r\n    const sessionData: SessionData = {\r\n      userId,\r\n      candidateId: resolvedCandidateId,\r\n      skillBucketId,\r\n      testTemplateId: template.id,\r\n      questionIds: questions.map((q) => q.id),\r\n      answers: {},\r\n      startedAt: now,\r\n      endsAt: now + this.TEST_DURATION_MS,\r\n      status: 'ACTIVE',\r\n    };\r\n\r\n    activeSessions.set(sessionId, sessionData);\r\n\r\n    // Create database record (no applicationId needed for rapid fire tests)\r\n    await this.prisma.testSession.create({\r\n      data: {\r\n        id: sessionId,\r\n        testTemplateId: template.id,\r\n        status: 'ACTIVE',\r\n        startedAt: new Date(now),\r\n        endsAt: new Date(now + this.TEST_DURATION_MS),\r\n        totalQuestions: questions.length,\r\n        selectedQuestionIds: questions.map((q) => q.id),\r\n      },\r\n    });\r\n\r\n    return {\r\n      sessionId,\r\n      testName: template.name,\r\n      duration: template.duration,\r\n      totalQuestionBank: questions.length,\r\n      remainingTime: Math.floor(this.TEST_DURATION_MS / 1000),\r\n      startedAt: new Date(now).toISOString(),\r\n      endsAt: new Date(now + this.TEST_DURATION_MS).toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get test state with all questions\r\n   */\r\n  async getTestState(sessionId: string, userId: string) {\r\n    const session = await this.validateSession(sessionId, userId);\r\n\r\n    // Get all questions\r\n    const questions = await this.prisma.questionBank.findMany({\r\n      where: { id: { in: session.questionIds } },\r\n      select: {\r\n        id: true,\r\n        question: true,\r\n        options: true,\r\n        difficulty: true,\r\n        // Don't include correctAnswer!\r\n      },\r\n    });\r\n\r\n    // Map to include answer status\r\n    const questionsWithStatus = session.questionIds.map((qId, index) => {\r\n      const question = questions.find((q) => q.id === qId);\r\n      return {\r\n        index: index + 1,\r\n        id: qId,\r\n        question: question?.question,\r\n        options: question?.options,\r\n        difficulty: question?.difficulty,\r\n        answered: session.answers[qId] !== undefined,\r\n        selectedAnswer: session.answers[qId],\r\n      };\r\n    });\r\n\r\n    const now = Date.now();\r\n    const remainingTime = Math.max(\r\n      0,\r\n      Math.floor((session.endsAt - now) / 1000),\r\n    );\r\n\r\n    // Auto-submit if time expired\r\n    if (remainingTime <= 0 && session.status === 'ACTIVE') {\r\n      await this.submitTest(sessionId, userId, true);\r\n      throw new BadRequestException(\r\n        'Test time has expired. Your answers have been auto-submitted.',\r\n      );\r\n    }\r\n\r\n    return {\r\n      sessionId,\r\n      status: session.status,\r\n      totalQuestionBank: session.questionIds.length,\r\n      answeredCount: Object.keys(session.answers).length,\r\n      remainingTime,\r\n      QuestionBank: questionsWithStatus,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Submit answer for a question\r\n   */\r\n  async submitAnswer(\r\n    sessionId: string,\r\n    userId: string,\r\n    questionId: string,\r\n    selectedAnswer: number,\r\n  ) {\r\n    const session = await this.validateSession(sessionId, userId);\r\n\r\n    // Check if question belongs to this session\r\n    if (!session.questionIds.includes(questionId)) {\r\n      throw new BadRequestException('Question not part of this test');\r\n    }\r\n\r\n    // Validate answer range\r\n    if (selectedAnswer < 0 || selectedAnswer > 3) {\r\n      throw new BadRequestException('Invalid answer selection');\r\n    }\r\n\r\n    // Save answer (allows changing - going back)\r\n    session.answers[questionId] = selectedAnswer;\r\n\r\n    return {\r\n      success: true,\r\n      answeredCount: Object.keys(session.answers).length,\r\n      totalQuestionBank: session.questionIds.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Submit the entire test\r\n   */\r\n  async submitTest(sessionId: string, userId: string, isAutoSubmit = false) {\r\n    let session = activeSessions.get(sessionId);\r\n\r\n    // Try to restore from DB if not in memory\r\n    if (!session) {\r\n      session = await this.restoreSessionFromDb(sessionId, userId);\r\n    }\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Test session not found');\r\n    }\r\n\r\n    if (session.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized');\r\n    }\r\n\r\n    if (session.status !== 'ACTIVE') {\r\n      throw new BadRequestException('Test already submitted');\r\n    }\r\n\r\n    // Calculate score\r\n    const questions = await this.prisma.questionBank.findMany({\r\n      where: { id: { in: session.questionIds } },\r\n      select: { id: true, correctAnswer: true, explanation: true },\r\n    });\r\n\r\n    let correctCount = 0;\r\n    const results: any[] = [];\r\n\r\n    questions.forEach((q) => {\r\n      const userAnswer = session.answers[q.id];\r\n      const isCorrect = userAnswer === q.correctAnswer;\r\n      if (isCorrect) correctCount++;\r\n\r\n      results.push({\r\n        questionId: q.id,\r\n        userAnswer,\r\n        correctAnswer: q.correctAnswer,\r\n        isCorrect,\r\n        explanation: q.explanation,\r\n      });\r\n    });\r\n\r\n    const totalQuestions = session.questionIds.length;\r\n    const score =\r\n      totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;\r\n\r\n    // Get passing criteria from template\r\n    const template = await this.prisma.testTemplate.findUnique({\r\n      where: { id: session.testTemplateId },\r\n    });\r\n\r\n    const passingScore = template?.passingCriteria || 70;\r\n    const isPassed = score >= passingScore;\r\n\r\n    // Update session status\r\n    session.status = 'SUBMITTED';\r\n\r\n    // Create skill test attempt record\r\n    const attemptedAt = new Date();\r\n    await this.prisma.skillTestAttempt.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        candidateId: session.candidateId,\r\n        skillBucketId: session.skillBucketId,\r\n        isPassed,\r\n        score,\r\n        attemptedAt,\r\n        validTill: isPassed\r\n          ? new Date(attemptedAt.getTime() + 7 * 24 * 60 * 60 * 1000)\r\n          : null,\r\n        retestAllowedAt: isPassed\r\n          ? null\r\n          : new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n        testSessionId: sessionId,\r\n      },\r\n    });\r\n\r\n    // Update test session in DB\r\n    await this.prisma.testSession.update({\r\n      where: { id: sessionId },\r\n      data: {\r\n        status: isAutoSubmit ? 'AUTO_SUBMITTED' : 'SUBMITTED',\r\n        submittedAt: new Date(),\r\n        score,\r\n        correctAnswers: correctCount,\r\n        isPassed,\r\n      },\r\n    });\r\n\r\n    // Update applications for this candidate with the same skillBucketId\r\n    // This ensures the application status reflects the test result\r\n    const applicationsToUpdate = await this.prisma.jobApplication.findMany({\r\n      where: {\r\n        candidateId: session.candidateId,\r\n        Job: {\r\n          skillBucketId: session.skillBucketId,\r\n        },\r\n        status: {\r\n          in: ['APPLIED', 'TEST_PENDING', 'TEST_REQUIRED', 'TEST_IN_PROGRESS'],\r\n        },\r\n      },\r\n      select: { id: true },\r\n    });\r\n\r\n    if (applicationsToUpdate.length > 0) {\r\n      const applicationIds = applicationsToUpdate.map(a => a.id);\r\n\r\n      if (isPassed) {\r\n        // Update applications to TEST_PASSED_WAITING_HR\r\n        await this.prisma.jobApplication.updateMany({\r\n          where: { id: { in: applicationIds } },\r\n          data: {\r\n            status: 'TEST_PASSED_WAITING_HR',\r\n            testPassedAt: new Date(),\r\n            testScore: score,\r\n          },\r\n        });\r\n        console.log(`Updated ${applicationIds.length} applications to TEST_PASSED_WAITING_HR for candidate ${session.candidateId}`);\r\n      } else {\r\n        // Update applications to TEST_FAILED\r\n        await this.prisma.jobApplication.updateMany({\r\n          where: { id: { in: applicationIds } },\r\n          data: {\r\n            status: 'TEST_FAILED',\r\n            testScore: score,\r\n          },\r\n        });\r\n        console.log(`Updated ${applicationIds.length} applications to TEST_FAILED for candidate ${session.candidateId}`);\r\n      }\r\n    }\r\n\r\n    // Clean up session from memory\r\n    activeSessions.delete(sessionId);\r\n\r\n    return {\r\n      success: true,\r\n      isAutoSubmit,\r\n      score: Math.round(score * 10) / 10,\r\n      correctCount,\r\n      totalQuestions,\r\n      isPassed,\r\n      passingScore,\r\n      message: isPassed\r\n        ? 'ðŸŽ‰ Congratulations! You passed the test!'\r\n        : `You scored ${score.toFixed(1)}%. You need ${passingScore}% to pass. You can retry after 24 hours.`,\r\n      results: isPassed ? undefined : results, // Only show details if failed\r\n      retestAllowedAt: isPassed\r\n        ? null\r\n        : new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Exit test (marks as failed)\r\n   */\r\n  async exitTest(sessionId: string, userId: string) {\r\n    let session = activeSessions.get(sessionId);\r\n\r\n    // Try to restore from DB if not in memory\r\n    if (!session) {\r\n      session = await this.restoreSessionFromDb(sessionId, userId);\r\n    }\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Test session not found');\r\n    }\r\n\r\n    if (session.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized');\r\n    }\r\n\r\n    if (session.status !== 'ACTIVE') {\r\n      throw new BadRequestException('Test already completed');\r\n    }\r\n\r\n    // Mark as failed with 0 score\r\n    session.status = 'EXITED';\r\n\r\n    // Create failed attempt\r\n    const attemptedAt = new Date();\r\n    await this.prisma.skillTestAttempt.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        candidateId: session.candidateId,\r\n        skillBucketId: session.skillBucketId,\r\n        isPassed: false,\r\n        score: 0,\r\n        attemptedAt,\r\n        validTill: null,\r\n        retestAllowedAt: new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n        testSessionId: sessionId,\r\n      },\r\n    });\r\n\r\n    // Update test session in DB\r\n    await this.prisma.testSession.update({\r\n      where: { id: sessionId },\r\n      data: {\r\n        status: 'EXPIRED', // Using EXPIRED for exited tests\r\n        submittedAt: new Date(),\r\n        score: 0,\r\n        correctAnswers: 0,\r\n        isPassed: false,\r\n      },\r\n    });\r\n\r\n    // Clean up\r\n    activeSessions.delete(sessionId);\r\n\r\n    return {\r\n      success: true,\r\n      message:\r\n        'Test exited. This counts as a failed attempt. You can retry after 24 hours.',\r\n      retestAllowedAt: new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate session and check authorization\r\n   * Returns session data or throws appropriate error\r\n   */\r\n  private async validateSession(sessionId: string, userId: string): Promise<SessionData> {\r\n    let session = activeSessions.get(sessionId);\r\n\r\n    // If not in memory, try to restore from database\r\n    if (!session) {\r\n      session = await this.restoreSessionFromDb(sessionId, userId);\r\n    }\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Test session not found or expired');\r\n    }\r\n\r\n    if (session.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized to access this test');\r\n    }\r\n\r\n    if (session.status !== 'ACTIVE') {\r\n      throw new BadRequestException('Test is no longer active');\r\n    }\r\n\r\n    // Check time expiry\r\n    if (Date.now() > session.endsAt) {\r\n      session.status = 'EXPIRED';\r\n      throw new BadRequestException('Test time has expired');\r\n    }\r\n\r\n    return session;\r\n  }\r\n\r\n  /**\r\n   * Restore session from database if server restarted\r\n   */\r\n  private async restoreSessionFromDb(sessionId: string, userId: string): Promise<SessionData | undefined> {\r\n    try {\r\n      const dbSession = await this.prisma.testSession.findUnique({\r\n        where: { id: sessionId },\r\n        include: { TestTemplate: { include: { SkillBucket: true } } },\r\n      });\r\n\r\n      if (!dbSession) {\r\n        console.log(`Session ${sessionId} not found in database`);\r\n        return undefined;\r\n      }\r\n\r\n      // Check if session is active and not expired\r\n      if (dbSession.status !== 'ACTIVE' || !dbSession.endsAt || new Date() > dbSession.endsAt) {\r\n        console.log(`Session ${sessionId} is not active or expired`);\r\n        return undefined;\r\n      }\r\n\r\n      // Get the user's candidate record\r\n      const user = await this.prisma.user.findUnique({\r\n        where: { id: userId },\r\n        select: { id: true, Candidate: { select: { id: true } } },\r\n      });\r\n\r\n      if (!user?.Candidate?.id) {\r\n        console.log(`User ${userId} has no candidate record`);\r\n        return undefined;\r\n      }\r\n\r\n      // Get skillBucketId from the first SkillBucket in the array\r\n      // TestTemplate has SkillBucket as an array relation\r\n      const skillBuckets = dbSession.TestTemplate?.SkillBucket || [];\r\n      const skillBucketId = skillBuckets.length > 0 ? skillBuckets[0].id : '';\r\n\r\n      // Restore session data\r\n      const sessionData: SessionData = {\r\n        userId: userId,\r\n        candidateId: user.Candidate.id,\r\n        skillBucketId: skillBucketId,\r\n        testTemplateId: dbSession.testTemplateId || '',\r\n        questionIds: dbSession.selectedQuestionIds || [],\r\n        answers: {}, // Answers are lost after restart - user needs to re-answer\r\n        startedAt: dbSession.startedAt?.getTime() || Date.now(),\r\n        endsAt: dbSession.endsAt.getTime(),\r\n        status: 'ACTIVE',\r\n      };\r\n\r\n      // Store back in memory\r\n      activeSessions.set(sessionId, sessionData);\r\n\r\n      console.log(`Session ${sessionId} restored from database for user ${userId}, candidateId: ${user.Candidate.id}`);\r\n      return sessionData;\r\n    } catch (error) {\r\n      console.error('Error restoring session from DB:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get test history for a candidate\r\n   */\r\n\r\n  async getTestHistory(candidateId: string) {\r\n    const attempts = await this.prisma.skillTestAttempt.findMany({\r\n      where: { candidateId },\r\n      include: {\r\n        SkillBucket: {\r\n          select: { id: true, name: true, displayName: true },\r\n        },\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n      take: 20,\r\n    });\r\n\r\n    return attempts.map((a) => ({\r\n      id: a.id,\r\n      SkillBucket: a.SkillBucket,\r\n      score: a.score,\r\n      isPassed: a.isPassed,\r\n      attemptedAt: a.attemptedAt,\r\n      validTill: a.validTill,\r\n      retestAllowedAt: a.retestAllowedAt,\r\n    }));\r\n  }\r\n}\r\n"],"names":["RapidFireTestService","activeSessions","Map","canTakeTest","candidateId","skillBucketId","skillBucket","prisma","findUnique","where","id","include","TestTemplate","NotFoundException","BadRequestException","validPassedAttempt","skillTestAttempt","findFirst","isPassed","validTill","gt","Date","orderBy","attemptedAt","canTake","status","message","recentFailedAttempt","retestAllowedAt","sessionId","data","entries","now","endsAt","delete","testTemplate","SkillBucket","name","displayName","startTest","userId","resolvedCandidateId","user","select","Candidate","console","log","eligibility","template","questions","questionBankService","getRandomQuestions","count","questionPoolSize","roleType","selectionRoleType","code","tags","selectionTags","length","Math","random","toString","substr","sessionData","testTemplateId","questionIds","map","q","answers","startedAt","TEST_DURATION_MS","set","testSession","create","totalQuestions","selectedQuestionIds","testName","duration","totalQuestionBank","remainingTime","floor","toISOString","getTestState","session","validateSession","questionBank","findMany","in","question","options","difficulty","questionsWithStatus","qId","index","find","answered","undefined","selectedAnswer","max","submitTest","answeredCount","Object","keys","QuestionBank","submitAnswer","questionId","includes","success","isAutoSubmit","get","restoreSessionFromDb","ForbiddenException","correctAnswer","explanation","correctCount","results","forEach","userAnswer","isCorrect","push","score","passingScore","passingCriteria","crypto","randomUUID","getTime","testSessionId","update","submittedAt","correctAnswers","applicationsToUpdate","jobApplication","Job","applicationIds","a","updateMany","testPassedAt","testScore","round","toFixed","exitTest","dbSession","skillBuckets","error","getTestHistory","attempts","take"],"mappings":"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"}