{"version":3,"sources":["../../../src/modules/rapid-fire/rapid-fire.service.ts"],"sourcesContent":["import { Injectable, BadRequestException, NotFoundException, ForbiddenException } from '@nestjs/common';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { QuestionBankService } from '../question-bank/question-bank.service';\r\n\r\ninterface SessionData {\r\n    userId: string;\r\n    candidateId: string;\r\n    skillBucketId: string;\r\n    testTemplateId: string;\r\n    questionIds: string[];\r\n    answers: Record<string, number>; // questionId -> selectedAnswer\r\n    startedAt: number;\r\n    endsAt: number;\r\n    status: 'ACTIVE' | 'SUBMITTED' | 'EXPIRED' | 'EXITED';\r\n}\r\n\r\n// In-memory session storage (in production, use Redis)\r\nconst activeSessions = new Map<string, SessionData>();\r\n\r\n@Injectable()\r\nexport class RapidFireTestService {\r\n    private readonly TEST_DURATION_MS = 20 * 60 * 1000; // 20 minutes\r\n\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private questionBankService: QuestionBankService,\r\n    ) { }\r\n\r\n    /**\r\n     * Check if candidate can take a test for a skill bucket\r\n     * Returns status with cooldown info\r\n     */\r\n    async canTakeTest(candidateId: string, skillBucketId: string) {\r\n        // Get skill bucket with test template\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id: skillBucketId },\r\n            include: { testTemplate: true },\r\n        });\r\n\r\n        if (!skillBucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        if (!skillBucket.testTemplateId) {\r\n            throw new BadRequestException('No test configured for this skill');\r\n        }\r\n\r\n        // Check for valid passed test (within 7 days)\r\n        const validPassedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n            where: {\r\n                candidateId,\r\n                skillBucketId,\r\n                isPassed: true,\r\n                validTill: { gt: new Date() },\r\n            },\r\n            orderBy: { attemptedAt: 'desc' },\r\n        });\r\n\r\n        if (validPassedAttempt) {\r\n            return {\r\n                canTake: false,\r\n                status: 'ALREADY_PASSED',\r\n                validTill: validPassedAttempt.validTill,\r\n                message: 'You have already passed this test',\r\n            };\r\n        }\r\n\r\n        // Check for recent failed test (24-hour cooldown)\r\n        const recentFailedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n            where: {\r\n                candidateId,\r\n                skillBucketId,\r\n                isPassed: false,\r\n                retestAllowedAt: { gt: new Date() },\r\n            },\r\n            orderBy: { attemptedAt: 'desc' },\r\n        });\r\n\r\n        if (recentFailedAttempt) {\r\n            return {\r\n                canTake: false,\r\n                status: 'COOLDOWN',\r\n                retestAllowedAt: recentFailedAttempt.retestAllowedAt,\r\n                message: 'Please wait 24 hours before retaking the test',\r\n            };\r\n        }\r\n\r\n        // Check for active session\r\n        for (const [sessionId, data] of activeSessions.entries()) {\r\n            if (data.candidateId === candidateId && data.skillBucketId === skillBucketId && data.status === 'ACTIVE') {\r\n                return {\r\n                    canTake: false,\r\n                    status: 'IN_PROGRESS',\r\n                    sessionId,\r\n                    message: 'You have an active test session',\r\n                };\r\n            }\r\n        }\r\n\r\n        return {\r\n            canTake: true,\r\n            status: 'AVAILABLE',\r\n            testTemplate: skillBucket.testTemplate,\r\n            SkillBucket: {\r\n                id: skillBucket.id,\r\n                name: skillBucket.name,\r\n                displayName: skillBucket.displayName,\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Start a rapid fire test\r\n     */\r\n    async startTest(userId: string, candidateId: string, skillBucketId: string) {\r\n        // Check if can take test\r\n        const eligibility = await this.canTakeTest(candidateId, skillBucketId);\r\n\r\n        if (!eligibility.canTake) {\r\n            throw new BadRequestException(eligibility.message);\r\n        }\r\n\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id: skillBucketId },\r\n            include: { testTemplate: true },\r\n        });\r\n\r\n        const template = skillBucket!.testTemplate!;\r\n\r\n        // Get random questions for this role\r\n        const questions = await this.questionBankService.getRandomQuestions({\r\n            count: template.questionPoolSize,\r\n            roleType: template.selectionRoleType || skillBucket!.code,\r\n            tags: template.selectionTags,\r\n        });\r\n\r\n        if (questions.length === 0) {\r\n            throw new BadRequestException('No questions available for this test');\r\n        }\r\n\r\n        // Create session ID\r\n        const sessionId = `rf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n        const now = Date.now();\r\n\r\n        // Store session data\r\n        const sessionData: SessionData = {\r\n            userId,\r\n            candidateId,\r\n            skillBucketId,\r\n            testTemplateId: template.id,\r\n            questionIds: questions.map(q => q.id),\r\n            answers: {},\r\n            startedAt: now,\r\n            endsAt: now + this.TEST_DURATION_MS,\r\n            status: 'ACTIVE',\r\n        };\r\n\r\n        activeSessions.set(sessionId, sessionData);\r\n\r\n        // Create database record (no applicationId needed for rapid fire tests)\r\n        await this.prisma.testSession.create({\r\n            data: {\r\n                id: sessionId,\r\n                testTemplateId: template.id,\r\n                status: 'ACTIVE',\r\n                startedAt: new Date(now),\r\n                endsAt: new Date(now + this.TEST_DURATION_MS),\r\n                totalQuestionBank: questions.length,\r\n                selectedQuestionIds: questions.map(q => q.id),\r\n            },\r\n        });\r\n\r\n        return {\r\n            sessionId,\r\n            testName: template.name,\r\n            duration: template.duration,\r\n            totalQuestionBank: questions.length,\r\n            remainingTime: Math.floor(this.TEST_DURATION_MS / 1000),\r\n            startedAt: new Date(now).toISOString(),\r\n            endsAt: new Date(now + this.TEST_DURATION_MS).toISOString(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get test state with all questions\r\n     */\r\n    async getTestState(sessionId: string, userId: string) {\r\n        const session = this.validateSession(sessionId, userId);\r\n\r\n        // Get all questions\r\n        const questions = await this.prisma.questionBank.findMany({\r\n            where: { id: { in: session.questionIds } },\r\n            select: {\r\n                id: true,\r\n                question: true,\r\n                options: true,\r\n                difficulty: true,\r\n                // Don't include correctAnswer!\r\n            },\r\n        });\r\n\r\n        // Map to include answer status\r\n        const questionsWithStatus = session.questionIds.map((qId, index) => {\r\n            const question = questions.find(q => q.id === qId);\r\n            return {\r\n                index: index + 1,\r\n                id: qId,\r\n                question: question?.question,\r\n                options: question?.options,\r\n                difficulty: question?.difficulty,\r\n                answered: session.answers[qId] !== undefined,\r\n                selectedAnswer: session.answers[qId],\r\n            };\r\n        });\r\n\r\n        const now = Date.now();\r\n        const remainingTime = Math.max(0, Math.floor((session.endsAt - now) / 1000));\r\n\r\n        // Auto-submit if time expired\r\n        if (remainingTime <= 0 && session.status === 'ACTIVE') {\r\n            await this.submitTest(sessionId, userId, true);\r\n            throw new BadRequestException('Test time has expired. Your answers have been auto-submitted.');\r\n        }\r\n\r\n        return {\r\n            sessionId,\r\n            status: session.status,\r\n            totalQuestionBank: session.questionIds.length,\r\n            answeredCount: Object.keys(session.answers).length,\r\n            remainingTime,\r\n            QuestionBank: questionsWithStatus,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Submit answer for a question\r\n     */\r\n    async submitAnswer(sessionId: string, userId: string, questionId: string, selectedAnswer: number) {\r\n        const session = this.validateSession(sessionId, userId);\r\n\r\n        // Check if question belongs to this session\r\n        if (!session.questionIds.includes(questionId)) {\r\n            throw new BadRequestException('Question not part of this test');\r\n        }\r\n\r\n        // Validate answer range\r\n        if (selectedAnswer < 0 || selectedAnswer > 3) {\r\n            throw new BadRequestException('Invalid answer selection');\r\n        }\r\n\r\n        // Save answer (allows changing - going back)\r\n        session.answers[questionId] = selectedAnswer;\r\n\r\n        return {\r\n            success: true,\r\n            answeredCount: Object.keys(session.answers).length,\r\n            totalQuestionBank: session.questionIds.length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Submit the entire test\r\n     */\r\n    async submitTest(sessionId: string, userId: string, isAutoSubmit = false) {\r\n        const session = activeSessions.get(sessionId);\r\n\r\n        if (!session) {\r\n            throw new NotFoundException('Test session not found');\r\n        }\r\n\r\n        if (session.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (session.status !== 'ACTIVE') {\r\n            throw new BadRequestException('Test already submitted');\r\n        }\r\n\r\n        // Calculate score\r\n        const questions = await this.prisma.questionBank.findMany({\r\n            where: { id: { in: session.questionIds } },\r\n            select: { id: true, correctAnswer: true, explanation: true },\r\n        });\r\n\r\n        let correctCount = 0;\r\n        const results: any[] = [];\r\n\r\n        questions.forEach(q => {\r\n            const userAnswer = session.answers[q.id];\r\n            const isCorrect = userAnswer === q.correctAnswer;\r\n            if (isCorrect) correctCount++;\r\n\r\n            results.push({\r\n                questionId: q.id,\r\n                userAnswer,\r\n                correctAnswer: q.correctAnswer,\r\n                isCorrect,\r\n                explanation: q.explanation,\r\n            });\r\n        });\r\n\r\n        const totalQuestions = session.questionIds.length;\r\n        const score = totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;\r\n\r\n        // Get passing criteria from template\r\n        const template = await this.prisma.testTemplate.findUnique({\r\n            where: { id: session.testTemplateId },\r\n        });\r\n\r\n        const passingScore = template?.passingCriteria || 70;\r\n        const isPassed = score >= passingScore;\r\n\r\n        // Update session status\r\n        session.status = 'SUBMITTED';\r\n\r\n        // Create skill test attempt record\r\n        const attemptedAt = new Date();\r\n        await this.prisma.skillTestAttempt.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                candidateId: session.candidateId,\r\n                skillBucketId: session.skillBucketId,\r\n                isPassed,\r\n                score,\r\n                attemptedAt,\r\n                validTill: isPassed ? new Date(attemptedAt.getTime() + 7 * 24 * 60 * 60 * 1000) : null,\r\n                retestAllowedAt: isPassed ? null : new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n                testSessionId: sessionId,\r\n            },\r\n        });\r\n\r\n        // Update test session in DB\r\n        await this.prisma.testSession.update({\r\n            where: { id: sessionId },\r\n            data: {\r\n                status: isAutoSubmit ? 'AUTO_SUBMITTED' : 'SUBMITTED',\r\n                submittedAt: new Date(),\r\n                score,\r\n                correctAnswers: correctCount,\r\n                isPassed,\r\n            },\r\n        });\r\n\r\n        // Clean up session from memory\r\n        activeSessions.delete(sessionId);\r\n\r\n        return {\r\n            success: true,\r\n            isAutoSubmit,\r\n            score: Math.round(score * 10) / 10,\r\n            correctCount,\r\n            totalQuestions,\r\n            isPassed,\r\n            passingScore,\r\n            message: isPassed\r\n                ? 'ðŸŽ‰ Congratulations! You passed the test!'\r\n                : `You scored ${score.toFixed(1)}%. You need ${passingScore}% to pass. You can retry after 24 hours.`,\r\n            results: isPassed ? undefined : results, // Only show details if failed\r\n            retestAllowedAt: isPassed ? null : new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Exit test (marks as failed)\r\n     */\r\n    async exitTest(sessionId: string, userId: string) {\r\n        const session = activeSessions.get(sessionId);\r\n\r\n        if (!session) {\r\n            throw new NotFoundException('Test session not found');\r\n        }\r\n\r\n        if (session.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (session.status !== 'ACTIVE') {\r\n            throw new BadRequestException('Test already completed');\r\n        }\r\n\r\n        // Mark as failed with 0 score\r\n        session.status = 'EXITED';\r\n\r\n        // Create failed attempt\r\n        const attemptedAt = new Date();\r\n        await this.prisma.skillTestAttempt.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                candidateId: session.candidateId,\r\n                skillBucketId: session.skillBucketId,\r\n                isPassed: false,\r\n                score: 0,\r\n                attemptedAt,\r\n                validTill: null,\r\n                retestAllowedAt: new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n                testSessionId: sessionId,\r\n            },\r\n        });\r\n\r\n        // Update test session in DB\r\n        await this.prisma.testSession.update({\r\n            where: { id: sessionId },\r\n            data: {\r\n                status: 'EXPIRED', // Using EXPIRED for exited tests\r\n                submittedAt: new Date(),\r\n                score: 0,\r\n                correctAnswers: 0,\r\n                isPassed: false,\r\n            },\r\n        });\r\n\r\n        // Clean up\r\n        activeSessions.delete(sessionId);\r\n\r\n        return {\r\n            success: true,\r\n            message: 'Test exited. This counts as a failed attempt. You can retry after 24 hours.',\r\n            retestAllowedAt: new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Validate session and check authorization\r\n     */\r\n    private validateSession(sessionId: string, userId: string): SessionData {\r\n        const session = activeSessions.get(sessionId);\r\n\r\n        if (!session) {\r\n            throw new NotFoundException('Test session not found or expired');\r\n        }\r\n\r\n        if (session.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized to access this test');\r\n        }\r\n\r\n        if (session.status !== 'ACTIVE') {\r\n            throw new BadRequestException('Test is no longer active');\r\n        }\r\n\r\n        // Check time expiry\r\n        if (Date.now() > session.endsAt) {\r\n            session.status = 'EXPIRED';\r\n            throw new BadRequestException('Test time has expired');\r\n        }\r\n\r\n        return session;\r\n    }\r\n\r\n    /**\r\n     * Get test history for a candidate\r\n     */\r\n\r\n    async getTestHistory(candidateId: string) {\r\n        const attempts = await this.prisma.skillTestAttempt.findMany({\r\n            where: { candidateId },\r\n            include: {\r\n                SkillBucket: {\r\n                    select: { id: true, name: true, displayName: true },\r\n                },\r\n            },\r\n            orderBy: { attemptedAt: 'desc' },\r\n            take: 20,\r\n        });\r\n\r\n        return attempts.map(a => ({\r\n            id: a.id,\r\n            SkillBucket: a.SkillBucket,\r\n            score: a.score,\r\n            isPassed: a.isPassed,\r\n            attemptedAt: a.attemptedAt,\r\n            validTill: a.validTill,\r\n            retestAllowedAt: a.retestAllowedAt,\r\n        }));\r\n    }\r\n}\r\n"],"names":["RapidFireTestService","activeSessions","Map","canTakeTest","candidateId","skillBucketId","skillBucket","prisma","findUnique","where","id","include","testTemplate","NotFoundException","testTemplateId","BadRequestException","validPassedAttempt","skillTestAttempt","findFirst","isPassed","validTill","gt","Date","orderBy","attemptedAt","canTake","status","message","recentFailedAttempt","retestAllowedAt","sessionId","data","entries","SkillBucket","name","displayName","startTest","userId","eligibility","template","questions","questionBankService","getRandomQuestions","count","questionPoolSize","roleType","selectionRoleType","code","tags","selectionTags","length","now","Math","random","toString","substr","sessionData","questionIds","map","q","answers","startedAt","endsAt","TEST_DURATION_MS","set","testSession","create","totalQuestionBank","selectedQuestionIds","testName","duration","remainingTime","floor","toISOString","getTestState","session","validateSession","questionBank","findMany","in","select","question","options","difficulty","questionsWithStatus","qId","index","find","answered","undefined","selectedAnswer","max","submitTest","answeredCount","Object","keys","QuestionBank","submitAnswer","questionId","includes","success","isAutoSubmit","get","ForbiddenException","correctAnswer","explanation","correctCount","results","forEach","userAnswer","isCorrect","push","totalQuestions","score","passingScore","passingCriteria","crypto","randomUUID","getTime","testSessionId","update","submittedAt","correctAnswers","delete","round","toFixed","exitTest","getTestHistory","attempts","take","a"],"mappings":"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"}