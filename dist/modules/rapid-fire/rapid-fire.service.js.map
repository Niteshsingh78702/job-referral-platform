{"version":3,"sources":["../../../src/modules/rapid-fire/rapid-fire.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  BadRequestException,\r\n  NotFoundException,\r\n  ForbiddenException,\r\n} from '@nestjs/common';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { QuestionBankService } from '../question-bank/question-bank.service';\r\n\r\ninterface SessionData {\r\n  userId: string;\r\n  candidateId: string;\r\n  skillBucketId: string;\r\n  testTemplateId: string;\r\n  questionIds: string[];\r\n  answers: Record<string, number>; // questionId -> selectedAnswer\r\n  startedAt: number;\r\n  endsAt: number;\r\n  status: 'ACTIVE' | 'SUBMITTED' | 'EXPIRED' | 'EXITED';\r\n}\r\n\r\n// In-memory session storage (in production, use Redis)\r\nconst activeSessions = new Map<string, SessionData>();\r\n\r\n@Injectable()\r\nexport class RapidFireTestService {\r\n  private readonly TEST_DURATION_MS = 20 * 60 * 1000; // 20 minutes\r\n\r\n  constructor(\r\n    private prisma: PrismaService,\r\n    private questionBankService: QuestionBankService,\r\n  ) { }\r\n\r\n  /**\r\n   * Check if candidate can take a test for a skill bucket\r\n   * Returns status with cooldown info\r\n   */\r\n  async canTakeTest(candidateId: string, skillBucketId: string) {\r\n    // Get skill bucket with test template\r\n    const skillBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n      include: { TestTemplate: true },\r\n    });\r\n\r\n    if (!skillBucket) {\r\n      throw new NotFoundException('Skill bucket not found');\r\n    }\r\n\r\n    if (!skillBucket.TestTemplate) {\r\n      throw new BadRequestException('No test configured for this skill');\r\n    }\r\n\r\n    // Check for valid passed test (within 7 days)\r\n    const validPassedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n      where: {\r\n        candidateId,\r\n        skillBucketId,\r\n        isPassed: true,\r\n        validTill: { gt: new Date() },\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n    });\r\n\r\n    if (validPassedAttempt) {\r\n      return {\r\n        canTake: false,\r\n        status: 'ALREADY_PASSED',\r\n        validTill: validPassedAttempt.validTill,\r\n        message: 'You have already passed this test',\r\n      };\r\n    }\r\n\r\n    // Check for recent failed test (24-hour cooldown)\r\n    const recentFailedAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n      where: {\r\n        candidateId,\r\n        skillBucketId,\r\n        isPassed: false,\r\n        retestAllowedAt: { gt: new Date() },\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n    });\r\n\r\n    if (recentFailedAttempt) {\r\n      return {\r\n        canTake: false,\r\n        status: 'COOLDOWN',\r\n        retestAllowedAt: recentFailedAttempt.retestAllowedAt,\r\n        message: 'Please wait 24 hours before retaking the test',\r\n      };\r\n    }\r\n\r\n    // Check for active session\r\n    for (const [sessionId, data] of activeSessions.entries()) {\r\n      if (\r\n        data.candidateId === candidateId &&\r\n        data.skillBucketId === skillBucketId &&\r\n        data.status === 'ACTIVE'\r\n      ) {\r\n        return {\r\n          canTake: false,\r\n          status: 'IN_PROGRESS',\r\n          sessionId,\r\n          message: 'You have an active test session',\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      canTake: true,\r\n      status: 'AVAILABLE',\r\n      testTemplate: skillBucket.TestTemplate,\r\n      SkillBucket: {\r\n        id: skillBucket.id,\r\n        name: skillBucket.name,\r\n        displayName: skillBucket.displayName,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Start a rapid fire test\r\n   */\r\n  async startTest(userId: string, candidateId: string, skillBucketId: string) {\r\n    // Check if can take test\r\n    const eligibility = await this.canTakeTest(candidateId, skillBucketId);\r\n\r\n    if (!eligibility.canTake) {\r\n      // If there's an active session, include the sessionId in the error response\r\n      if (eligibility.sessionId) {\r\n        throw new BadRequestException({\r\n          message: eligibility.message,\r\n          sessionId: eligibility.sessionId,\r\n          status: eligibility.status,\r\n        });\r\n      }\r\n      throw new BadRequestException(eligibility.message);\r\n    }\r\n\r\n    const skillBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n      include: { TestTemplate: true },\r\n    });\r\n\r\n    const template = skillBucket!.TestTemplate!;\r\n\r\n    // Get random questions for this role\r\n    const questions = await this.questionBankService.getRandomQuestions({\r\n      count: template.questionPoolSize,\r\n      roleType: template.selectionRoleType || skillBucket!.code,\r\n      tags: template.selectionTags,\r\n    });\r\n\r\n    if (questions.length === 0) {\r\n      throw new BadRequestException('No questions available for this test');\r\n    }\r\n\r\n    // Create session ID\r\n    const sessionId = `rf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    const now = Date.now();\r\n\r\n    // Store session data\r\n    const sessionData: SessionData = {\r\n      userId,\r\n      candidateId,\r\n      skillBucketId,\r\n      testTemplateId: template.id,\r\n      questionIds: questions.map((q) => q.id),\r\n      answers: {},\r\n      startedAt: now,\r\n      endsAt: now + this.TEST_DURATION_MS,\r\n      status: 'ACTIVE',\r\n    };\r\n\r\n    activeSessions.set(sessionId, sessionData);\r\n\r\n    // Create database record (no applicationId needed for rapid fire tests)\r\n    await this.prisma.testSession.create({\r\n      data: {\r\n        id: sessionId,\r\n        testTemplateId: template.id,\r\n        status: 'ACTIVE',\r\n        startedAt: new Date(now),\r\n        endsAt: new Date(now + this.TEST_DURATION_MS),\r\n        totalQuestions: questions.length,\r\n        selectedQuestionIds: questions.map((q) => q.id),\r\n      },\r\n    });\r\n\r\n    return {\r\n      sessionId,\r\n      testName: template.name,\r\n      duration: template.duration,\r\n      totalQuestionBank: questions.length,\r\n      remainingTime: Math.floor(this.TEST_DURATION_MS / 1000),\r\n      startedAt: new Date(now).toISOString(),\r\n      endsAt: new Date(now + this.TEST_DURATION_MS).toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get test state with all questions\r\n   */\r\n  async getTestState(sessionId: string, userId: string) {\r\n    const session = this.validateSession(sessionId, userId);\r\n\r\n    // Get all questions\r\n    const questions = await this.prisma.questionBank.findMany({\r\n      where: { id: { in: session.questionIds } },\r\n      select: {\r\n        id: true,\r\n        question: true,\r\n        options: true,\r\n        difficulty: true,\r\n        // Don't include correctAnswer!\r\n      },\r\n    });\r\n\r\n    // Map to include answer status\r\n    const questionsWithStatus = session.questionIds.map((qId, index) => {\r\n      const question = questions.find((q) => q.id === qId);\r\n      return {\r\n        index: index + 1,\r\n        id: qId,\r\n        question: question?.question,\r\n        options: question?.options,\r\n        difficulty: question?.difficulty,\r\n        answered: session.answers[qId] !== undefined,\r\n        selectedAnswer: session.answers[qId],\r\n      };\r\n    });\r\n\r\n    const now = Date.now();\r\n    const remainingTime = Math.max(\r\n      0,\r\n      Math.floor((session.endsAt - now) / 1000),\r\n    );\r\n\r\n    // Auto-submit if time expired\r\n    if (remainingTime <= 0 && session.status === 'ACTIVE') {\r\n      await this.submitTest(sessionId, userId, true);\r\n      throw new BadRequestException(\r\n        'Test time has expired. Your answers have been auto-submitted.',\r\n      );\r\n    }\r\n\r\n    return {\r\n      sessionId,\r\n      status: session.status,\r\n      totalQuestionBank: session.questionIds.length,\r\n      answeredCount: Object.keys(session.answers).length,\r\n      remainingTime,\r\n      QuestionBank: questionsWithStatus,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Submit answer for a question\r\n   */\r\n  async submitAnswer(\r\n    sessionId: string,\r\n    userId: string,\r\n    questionId: string,\r\n    selectedAnswer: number,\r\n  ) {\r\n    const session = this.validateSession(sessionId, userId);\r\n\r\n    // Check if question belongs to this session\r\n    if (!session.questionIds.includes(questionId)) {\r\n      throw new BadRequestException('Question not part of this test');\r\n    }\r\n\r\n    // Validate answer range\r\n    if (selectedAnswer < 0 || selectedAnswer > 3) {\r\n      throw new BadRequestException('Invalid answer selection');\r\n    }\r\n\r\n    // Save answer (allows changing - going back)\r\n    session.answers[questionId] = selectedAnswer;\r\n\r\n    return {\r\n      success: true,\r\n      answeredCount: Object.keys(session.answers).length,\r\n      totalQuestionBank: session.questionIds.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Submit the entire test\r\n   */\r\n  async submitTest(sessionId: string, userId: string, isAutoSubmit = false) {\r\n    const session = activeSessions.get(sessionId);\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Test session not found');\r\n    }\r\n\r\n    if (session.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized');\r\n    }\r\n\r\n    if (session.status !== 'ACTIVE') {\r\n      throw new BadRequestException('Test already submitted');\r\n    }\r\n\r\n    // Calculate score\r\n    const questions = await this.prisma.questionBank.findMany({\r\n      where: { id: { in: session.questionIds } },\r\n      select: { id: true, correctAnswer: true, explanation: true },\r\n    });\r\n\r\n    let correctCount = 0;\r\n    const results: any[] = [];\r\n\r\n    questions.forEach((q) => {\r\n      const userAnswer = session.answers[q.id];\r\n      const isCorrect = userAnswer === q.correctAnswer;\r\n      if (isCorrect) correctCount++;\r\n\r\n      results.push({\r\n        questionId: q.id,\r\n        userAnswer,\r\n        correctAnswer: q.correctAnswer,\r\n        isCorrect,\r\n        explanation: q.explanation,\r\n      });\r\n    });\r\n\r\n    const totalQuestions = session.questionIds.length;\r\n    const score =\r\n      totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;\r\n\r\n    // Get passing criteria from template\r\n    const template = await this.prisma.testTemplate.findUnique({\r\n      where: { id: session.testTemplateId },\r\n    });\r\n\r\n    const passingScore = template?.passingCriteria || 70;\r\n    const isPassed = score >= passingScore;\r\n\r\n    // Update session status\r\n    session.status = 'SUBMITTED';\r\n\r\n    // Create skill test attempt record\r\n    const attemptedAt = new Date();\r\n    await this.prisma.skillTestAttempt.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        candidateId: session.candidateId,\r\n        skillBucketId: session.skillBucketId,\r\n        isPassed,\r\n        score,\r\n        attemptedAt,\r\n        validTill: isPassed\r\n          ? new Date(attemptedAt.getTime() + 7 * 24 * 60 * 60 * 1000)\r\n          : null,\r\n        retestAllowedAt: isPassed\r\n          ? null\r\n          : new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n        testSessionId: sessionId,\r\n      },\r\n    });\r\n\r\n    // Update test session in DB\r\n    await this.prisma.testSession.update({\r\n      where: { id: sessionId },\r\n      data: {\r\n        status: isAutoSubmit ? 'AUTO_SUBMITTED' : 'SUBMITTED',\r\n        submittedAt: new Date(),\r\n        score,\r\n        correctAnswers: correctCount,\r\n        isPassed,\r\n      },\r\n    });\r\n\r\n    // Clean up session from memory\r\n    activeSessions.delete(sessionId);\r\n\r\n    return {\r\n      success: true,\r\n      isAutoSubmit,\r\n      score: Math.round(score * 10) / 10,\r\n      correctCount,\r\n      totalQuestions,\r\n      isPassed,\r\n      passingScore,\r\n      message: isPassed\r\n        ? 'ðŸŽ‰ Congratulations! You passed the test!'\r\n        : `You scored ${score.toFixed(1)}%. You need ${passingScore}% to pass. You can retry after 24 hours.`,\r\n      results: isPassed ? undefined : results, // Only show details if failed\r\n      retestAllowedAt: isPassed\r\n        ? null\r\n        : new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Exit test (marks as failed)\r\n   */\r\n  async exitTest(sessionId: string, userId: string) {\r\n    const session = activeSessions.get(sessionId);\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Test session not found');\r\n    }\r\n\r\n    if (session.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized');\r\n    }\r\n\r\n    if (session.status !== 'ACTIVE') {\r\n      throw new BadRequestException('Test already completed');\r\n    }\r\n\r\n    // Mark as failed with 0 score\r\n    session.status = 'EXITED';\r\n\r\n    // Create failed attempt\r\n    const attemptedAt = new Date();\r\n    await this.prisma.skillTestAttempt.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        candidateId: session.candidateId,\r\n        skillBucketId: session.skillBucketId,\r\n        isPassed: false,\r\n        score: 0,\r\n        attemptedAt,\r\n        validTill: null,\r\n        retestAllowedAt: new Date(attemptedAt.getTime() + 24 * 60 * 60 * 1000),\r\n        testSessionId: sessionId,\r\n      },\r\n    });\r\n\r\n    // Update test session in DB\r\n    await this.prisma.testSession.update({\r\n      where: { id: sessionId },\r\n      data: {\r\n        status: 'EXPIRED', // Using EXPIRED for exited tests\r\n        submittedAt: new Date(),\r\n        score: 0,\r\n        correctAnswers: 0,\r\n        isPassed: false,\r\n      },\r\n    });\r\n\r\n    // Clean up\r\n    activeSessions.delete(sessionId);\r\n\r\n    return {\r\n      success: true,\r\n      message:\r\n        'Test exited. This counts as a failed attempt. You can retry after 24 hours.',\r\n      retestAllowedAt: new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate session and check authorization\r\n   */\r\n  private validateSession(sessionId: string, userId: string): SessionData {\r\n    const session = activeSessions.get(sessionId);\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Test session not found or expired');\r\n    }\r\n\r\n    if (session.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized to access this test');\r\n    }\r\n\r\n    if (session.status !== 'ACTIVE') {\r\n      throw new BadRequestException('Test is no longer active');\r\n    }\r\n\r\n    // Check time expiry\r\n    if (Date.now() > session.endsAt) {\r\n      session.status = 'EXPIRED';\r\n      throw new BadRequestException('Test time has expired');\r\n    }\r\n\r\n    return session;\r\n  }\r\n\r\n  /**\r\n   * Get test history for a candidate\r\n   */\r\n\r\n  async getTestHistory(candidateId: string) {\r\n    const attempts = await this.prisma.skillTestAttempt.findMany({\r\n      where: { candidateId },\r\n      include: {\r\n        SkillBucket: {\r\n          select: { id: true, name: true, displayName: true },\r\n        },\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n      take: 20,\r\n    });\r\n\r\n    return attempts.map((a) => ({\r\n      id: a.id,\r\n      SkillBucket: a.SkillBucket,\r\n      score: a.score,\r\n      isPassed: a.isPassed,\r\n      attemptedAt: a.attemptedAt,\r\n      validTill: a.validTill,\r\n      retestAllowedAt: a.retestAllowedAt,\r\n    }));\r\n  }\r\n}\r\n"],"names":["RapidFireTestService","activeSessions","Map","canTakeTest","candidateId","skillBucketId","skillBucket","prisma","findUnique","where","id","include","TestTemplate","NotFoundException","BadRequestException","validPassedAttempt","skillTestAttempt","findFirst","isPassed","validTill","gt","Date","orderBy","attemptedAt","canTake","status","message","recentFailedAttempt","retestAllowedAt","sessionId","data","entries","testTemplate","SkillBucket","name","displayName","startTest","userId","eligibility","template","questions","questionBankService","getRandomQuestions","count","questionPoolSize","roleType","selectionRoleType","code","tags","selectionTags","length","now","Math","random","toString","substr","sessionData","testTemplateId","questionIds","map","q","answers","startedAt","endsAt","TEST_DURATION_MS","set","testSession","create","totalQuestions","selectedQuestionIds","testName","duration","totalQuestionBank","remainingTime","floor","toISOString","getTestState","session","validateSession","questionBank","findMany","in","select","question","options","difficulty","questionsWithStatus","qId","index","find","answered","undefined","selectedAnswer","max","submitTest","answeredCount","Object","keys","QuestionBank","submitAnswer","questionId","includes","success","isAutoSubmit","get","ForbiddenException","correctAnswer","explanation","correctCount","results","forEach","userAnswer","isCorrect","push","score","passingScore","passingCriteria","crypto","randomUUID","getTime","testSessionId","update","submittedAt","correctAnswers","delete","round","toFixed","exitTest","getTestHistory","attempts","take","a"],"mappings":"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"}