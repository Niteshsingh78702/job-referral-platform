{"version":3,"sources":["../../../src/modules/skill-bucket/skill-bucket.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    NotFoundException,\r\n    BadRequestException,\r\n    Logger,\r\n} from '@nestjs/common';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { CreateSkillBucketDto, UpdateSkillBucketDto, SkillTestStatusDto } from './dto';\r\n\r\n// Validity duration in days\r\nconst TEST_VALIDITY_DAYS = 7;\r\n// Retest cooldown in hours\r\nconst RETEST_COOLDOWN_HOURS = 24;\r\n\r\n@Injectable()\r\nexport class SkillBucketService {\r\n    private readonly logger = new Logger(SkillBucketService.name);\r\n\r\n    constructor(private prisma: PrismaService) { }\r\n\r\n    // ==========================================\r\n    // ADMIN: Skill Bucket Management\r\n    // ==========================================\r\n\r\n    async createSkillBucket(dto: CreateSkillBucketDto) {\r\n        // Check if code already exists\r\n        const existing = await this.prisma.skillBucket.findUnique({\r\n            where: { code: dto.code },\r\n        });\r\n\r\n        if (existing) {\r\n            throw new BadRequestException(`Skill bucket with code '${dto.code}' already exists`);\r\n        }\r\n\r\n        return this.prisma.skillBucket.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                code: dto.code,\r\n                name: dto.name,\r\n                description: dto.description,\r\n                displayName: dto.displayName || `HR Shortlisting Check - ${dto.name}`,\r\n                experienceMin: dto.experienceMin ?? 0,\r\n                experienceMax: dto.experienceMax ?? 3,\r\n                updatedAt: new Date(),\r\n            },\r\n            include: {\r\n                Test: true,\r\n            },\r\n        });\r\n    }\r\n\r\n    async updateSkillBucket(id: string, dto: UpdateSkillBucketDto) {\r\n        const bucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id },\r\n        });\r\n\r\n        if (!bucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        return this.prisma.skillBucket.update({\r\n            where: { id },\r\n            data: {\r\n                name: dto.name,\r\n                description: dto.description,\r\n                displayName: dto.displayName,\r\n                experienceMin: dto.experienceMin,\r\n                experienceMax: dto.experienceMax,\r\n                isActive: dto.isActive,\r\n                testId: dto.testId,\r\n            },\r\n            include: {\r\n                Test: true,\r\n            },\r\n        });\r\n    }\r\n\r\n    async getSkillBuckets(includeInactive = false) {\r\n        return this.prisma.skillBucket.findMany({\r\n            where: includeInactive ? {} : { isActive: true },\r\n            include: {\r\n                Test: {\r\n                    select: {\r\n                        id: true,\r\n                        title: true,\r\n                        duration: true,\r\n                        totalQuestions: true,\r\n                    },\r\n                },\r\n                _count: {\r\n                    select: {\r\n                        Job: true,\r\n                        SkillTestAttempt: true,\r\n                    },\r\n                },\r\n            },\r\n            orderBy: { code: 'asc' },\r\n        });\r\n    }\r\n\r\n    async getSkillBucketById(id: string) {\r\n        const bucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id },\r\n            include: {\r\n                Test: true,\r\n            },\r\n        });\r\n\r\n        if (!bucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        return bucket;\r\n    }\r\n\r\n    async getSkillBucketByCode(code: string) {\r\n        const bucket = await this.prisma.skillBucket.findUnique({\r\n            where: { code },\r\n            include: {\r\n                Test: true,\r\n            },\r\n        });\r\n\r\n        if (!bucket) {\r\n            throw new NotFoundException(`Skill bucket '${code}' not found`);\r\n        }\r\n\r\n        return bucket;\r\n    }\r\n\r\n    // ==========================================\r\n    // Candidate: Skill Test Status Check\r\n    // ==========================================\r\n\r\n    /**\r\n     * Check candidate's skill test status for a specific skill bucket\r\n     * This is the CORE logic for determining:\r\n     * - If candidate has a valid pass (can apply without test)\r\n     * - If candidate has an expired pass (needs retest)\r\n     * - If candidate failed and is in cooldown (cannot retest yet)\r\n     * - If candidate failed and can retest (cooldown expired)\r\n     * - If candidate never took the test\r\n     */\r\n    async checkCandidateSkillStatus(\r\n        candidateId: string,\r\n        skillBucketId: string,\r\n    ): Promise<SkillTestStatusDto> {\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id: skillBucketId },\r\n        });\r\n\r\n        if (!skillBucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        // Get the most recent attempt for this candidate + skill bucket\r\n        const latestAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n            where: {\r\n                candidateId,\r\n                skillBucketId,\r\n            },\r\n            orderBy: { attemptedAt: 'desc' },\r\n        });\r\n\r\n        const now = new Date();\r\n\r\n        // Never taken\r\n        if (!latestAttempt) {\r\n            return {\r\n                skillBucketId,\r\n                skillBucketCode: skillBucket.code,\r\n                skillBucketName: skillBucket.name,\r\n                displayName: skillBucket.displayName || skillBucket.name,\r\n                isPassed: false,\r\n                isValid: false,\r\n                isFailed: false,\r\n                canReTest: true,\r\n                neverTaken: true,\r\n            };\r\n        }\r\n\r\n        // Passed attempt\r\n        if (latestAttempt.isPassed) {\r\n            const validTill = latestAttempt.validTill!;\r\n            const isValid = now <= validTill;\r\n\r\n            // Calculate days remaining\r\n            const msRemaining = validTill.getTime() - now.getTime();\r\n            const daysRemaining = Math.ceil(msRemaining / (1000 * 60 * 60 * 24));\r\n\r\n            return {\r\n                skillBucketId,\r\n                skillBucketCode: skillBucket.code,\r\n                skillBucketName: skillBucket.name,\r\n                displayName: skillBucket.displayName || skillBucket.name,\r\n                isPassed: true,\r\n                isValid,\r\n                score: latestAttempt.score,\r\n                validTill,\r\n                validDaysRemaining: isValid ? daysRemaining : 0,\r\n                isFailed: false,\r\n                canReTest: !isValid, // Can retest if expired\r\n                neverTaken: false,\r\n            };\r\n        }\r\n\r\n        // Failed attempt\r\n        const retestAllowedAt = latestAttempt.retestAllowedAt!;\r\n        const canRetest = now >= retestAllowedAt;\r\n\r\n        // Calculate hours until retest\r\n        const msUntilRetest = retestAllowedAt.getTime() - now.getTime();\r\n        const hoursUntilRetest = Math.ceil(msUntilRetest / (1000 * 60 * 60));\r\n\r\n        return {\r\n            skillBucketId,\r\n            skillBucketCode: skillBucket.code,\r\n            skillBucketName: skillBucket.name,\r\n            displayName: skillBucket.displayName || skillBucket.name,\r\n            isPassed: false,\r\n            isValid: false,\r\n            score: latestAttempt.score,\r\n            isFailed: true,\r\n            canRetest,\r\n            retestAllowedAt,\r\n            retestInHours: canRetest ? 0 : hoursUntilRetest,\r\n            neverTaken: false,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Check skill status by Job ID (for apply flow)\r\n     */\r\n    async checkCandidateSkillStatusByJobId(\r\n        candidateId: string,\r\n        jobId: string,\r\n    ): Promise<SkillTestStatusDto | null> {\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            select: { skillBucketId: true },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        // If job has no skill bucket, no test required\r\n        if (!job.skillBucketId) {\r\n            return null;\r\n        }\r\n\r\n        return this.checkCandidateSkillStatus(candidateId, job.skillBucketId);\r\n    }\r\n\r\n    // ==========================================\r\n    // RECORD TEST ATTEMPTS\r\n    // ==========================================\r\n\r\n    /**\r\n     * Record a skill test attempt after test submission\r\n     * Called from TestService after test is graded\r\n     */\r\n    async recordSkillTestAttempt(\r\n        candidateId: string,\r\n        skillBucketId: string,\r\n        isPassed: boolean,\r\n        score: number,\r\n        testSessionId?: string,\r\n    ) {\r\n        const now = new Date();\r\n\r\n        // Get configured validity/cooldown from TestTemplate (via SkillBucket)\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id: skillBucketId },\r\n            include: { TestTemplate: true },\r\n        });\r\n\r\n        // Use configured values or defaults\r\n        const validityDays = skillBucket?.TestTemplate?.testValidityDays ?? TEST_VALIDITY_DAYS;\r\n        const cooldownHours = skillBucket?.TestTemplate?.retestCooldownHours ?? RETEST_COOLDOWN_HOURS;\r\n\r\n        // Calculate validity or cooldown based on result\r\n        let validTill: Date | null = null;\r\n        let retestAllowedAt: Date | null = null;\r\n\r\n        if (isPassed) {\r\n            // Valid for configured days\r\n            validTill = new Date(now.getTime() + validityDays * 24 * 60 * 60 * 1000);\r\n        } else {\r\n            // Cooldown for configured hours\r\n            retestAllowedAt = new Date(now.getTime() + cooldownHours * 60 * 60 * 1000);\r\n        }\r\n\r\n        const attempt = await this.prisma.skillTestAttempt.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                candidateId,\r\n                skillBucketId,\r\n                isPassed,\r\n                score,\r\n                validTill,\r\n                retestAllowedAt,\r\n                testSessionId,\r\n            },\r\n        });\r\n\r\n        this.logger.log(\r\n            `Recorded skill test attempt: candidate=${candidateId}, skill=${skillBucketId}, ` +\r\n            `passed=${isPassed}, score=${score}, validTill=${validTill}, retestAllowedAt=${retestAllowedAt}, ` +\r\n            `validityDays=${validityDays}, cooldownHours=${cooldownHours}`\r\n        );\r\n\r\n        return attempt;\r\n    }\r\n\r\n    /**\r\n     * Get all valid skill passes for a candidate (for displaying badges)\r\n     */\r\n    async getCandidateValidPasses(candidateId: string) {\r\n        const now = new Date();\r\n\r\n        const validAttempts = await this.prisma.skillTestAttempt.findMany({\r\n            where: {\r\n                candidateId,\r\n                isPassed: true,\r\n                validTill: {\r\n                    gte: now,\r\n                },\r\n            },\r\n            include: {\r\n                SkillBucket: {\r\n                    select: {\r\n                        code: true,\r\n                        name: true,\r\n                        displayName: true,\r\n                    },\r\n                },\r\n            },\r\n            orderBy: { validTill: 'desc' },\r\n        });\r\n\r\n        return validAttempts.map(attempt => ({\r\n            skillBucketCode: attempt.SkillBucket.code,\r\n            skillBucketName: attempt.SkillBucket.name,\r\n            displayName: attempt.SkillBucket.displayName || attempt.SkillBucket.name,\r\n            score: attempt.score,\r\n            validTill: attempt.validTill,\r\n            daysRemaining: Math.ceil(\r\n                (attempt.validTill!.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)\r\n            ),\r\n        }));\r\n    }\r\n\r\n    // ==========================================\r\n    // COMPOSITE SKILL REQUIREMENTS (Full Stack etc.)\r\n    // ==========================================\r\n\r\n    /**\r\n     * Check ALL required skills for a job (supports composite skill requirements)\r\n     * For Full Stack jobs that require both Java Backend AND React Frontend\r\n     * \r\n     * Returns:\r\n     * - canApply: true if ALL required skills are passed and valid\r\n     * - missingTests: array of skills that need to be taken/retaken\r\n     * - passedTests: array of skills already passed and valid\r\n     */\r\n    async checkAllRequiredSkillsForJob(\r\n        candidateId: string,\r\n        jobId: string,\r\n    ): Promise<{\r\n        canApply: boolean;\r\n        missingTests: SkillTestStatusDto[];\r\n        passedTests: SkillTestStatusDto[];\r\n        hasRequirements: boolean;\r\n    }> {\r\n        // Get job with both legacy single skill bucket and new composite requirements\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            include: {\r\n                JobRequiredSkillBucket: {\r\n                    include: {\r\n                        SkillBucket: true,\r\n                    },\r\n                    orderBy: { displayOrder: 'asc' },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        // Collect all required skill bucket IDs\r\n        const requiredSkillBucketIds: string[] = [];\r\n\r\n        // 1. Check legacy single skill bucket (backward compatibility)\r\n        if (job.skillBucketId) {\r\n            requiredSkillBucketIds.push(job.skillBucketId);\r\n        }\r\n\r\n        // 2. Check new composite skill requirements\r\n        for (const req of job.JobRequiredSkillBucket) {\r\n            if (!requiredSkillBucketIds.includes(req.skillBucketId)) {\r\n                requiredSkillBucketIds.push(req.skillBucketId);\r\n            }\r\n        }\r\n\r\n        // No skill requirements - can apply freely\r\n        if (requiredSkillBucketIds.length === 0) {\r\n            return {\r\n                canApply: true,\r\n                missingTests: [],\r\n                passedTests: [],\r\n                hasRequirements: false,\r\n            };\r\n        }\r\n\r\n        // Check each required skill\r\n        const passedTests: SkillTestStatusDto[] = [];\r\n        const missingTests: SkillTestStatusDto[] = [];\r\n\r\n        for (const skillBucketId of requiredSkillBucketIds) {\r\n            const status = await this.checkCandidateSkillStatus(candidateId, skillBucketId);\r\n\r\n            if (status.isPassed && status.isValid) {\r\n                passedTests.push(status);\r\n            } else {\r\n                missingTests.push(status);\r\n            }\r\n        }\r\n\r\n        return {\r\n            canApply: missingTests.length === 0,\r\n            missingTests,\r\n            passedTests,\r\n            hasRequirements: true,\r\n        };\r\n    }\r\n\r\n    // ==========================================\r\n    // ADMIN: Delete Skill Bucket\r\n    // ==========================================\r\n\r\n    async deleteSkillBucket(id: string) {\r\n        const bucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id },\r\n            include: {\r\n                _count: {\r\n                    select: {\r\n                        Job: true,\r\n                        SkillTestAttempt: true,\r\n                        JobRequiredSkillBucket: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!bucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        // Check if skill bucket is in use\r\n        if (bucket._count.Job > 0 || bucket._count.JobRequiredSkillBucket > 0) {\r\n            throw new BadRequestException(\r\n                `Cannot delete skill bucket: it is assigned to ${bucket._count.Job + bucket._count.JobRequiredSkillBucket} job(s). Deactivate it instead.`\r\n            );\r\n        }\r\n\r\n        // If there are attempts, just deactivate instead of hard delete\r\n        if (bucket._count.SkillTestAttempt > 0) {\r\n            return this.prisma.skillBucket.update({\r\n                where: { id },\r\n                data: { isActive: false },\r\n            });\r\n        }\r\n\r\n        // Safe to hard delete\r\n        return this.prisma.skillBucket.delete({\r\n            where: { id },\r\n        });\r\n    }\r\n\r\n    // ==========================================\r\n    // ADMIN: Add/Remove Skill Requirements from Job\r\n    // ==========================================\r\n\r\n    async addSkillRequirementToJob(jobId: string, skillBucketId: string, displayOrder = 0) {\r\n        // Verify job exists\r\n        const job = await this.prisma.job.findUnique({ where: { id: jobId } });\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        // Verify skill bucket exists\r\n        const bucket = await this.prisma.skillBucket.findUnique({ where: { id: skillBucketId } });\r\n        if (!bucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        // Create the requirement (upsert to avoid duplicates)\r\n        return this.prisma.jobRequiredSkillBucket.upsert({\r\n            where: {\r\n                jobId_skillBucketId: { jobId, skillBucketId },\r\n            },\r\n            create: {\r\n                id: crypto.randomUUID(),\r\n                jobId,\r\n                skillBucketId,\r\n                displayOrder,\r\n            },\r\n            update: {\r\n                displayOrder,\r\n            },\r\n            include: {\r\n                SkillBucket: true,\r\n            },\r\n        });\r\n    }\r\n\r\n    async removeSkillRequirementFromJob(jobId: string, skillBucketId: string) {\r\n        const requirement = await this.prisma.jobRequiredSkillBucket.findUnique({\r\n            where: {\r\n                jobId_skillBucketId: { jobId, skillBucketId },\r\n            },\r\n        });\r\n\r\n        if (!requirement) {\r\n            throw new NotFoundException('Skill requirement not found for this job');\r\n        }\r\n\r\n        return this.prisma.jobRequiredSkillBucket.delete({\r\n            where: {\r\n                jobId_skillBucketId: { jobId, skillBucketId },\r\n            },\r\n        });\r\n    }\r\n\r\n    async getJobSkillRequirements(jobId: string) {\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            include: {\r\n                SkillBucket: true, // Legacy single bucket\r\n                JobRequiredSkillBucket: {\r\n                    include: {\r\n                        SkillBucket: true,\r\n                    },\r\n                    orderBy: { displayOrder: 'asc' },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        return {\r\n            legacySkillBucket: job.SkillBucket,\r\n            compositeRequirements: job.JobRequiredSkillBucket,\r\n        };\r\n    }\r\n}\r\n"],"names":["SkillBucketService","TEST_VALIDITY_DAYS","RETEST_COOLDOWN_HOURS","createSkillBucket","dto","existing","prisma","skillBucket","findUnique","where","code","BadRequestException","create","data","id","crypto","randomUUID","name","description","displayName","experienceMin","experienceMax","updatedAt","Date","include","Test","updateSkillBucket","bucket","NotFoundException","update","isActive","testId","getSkillBuckets","includeInactive","findMany","select","title","duration","totalQuestions","_count","Job","SkillTestAttempt","orderBy","getSkillBucketById","getSkillBucketByCode","checkCandidateSkillStatus","candidateId","skillBucketId","latestAttempt","skillTestAttempt","findFirst","attemptedAt","now","skillBucketCode","skillBucketName","isPassed","isValid","isFailed","canReTest","neverTaken","validTill","msRemaining","getTime","daysRemaining","Math","ceil","score","validDaysRemaining","retestAllowedAt","canRetest","msUntilRetest","hoursUntilRetest","retestInHours","checkCandidateSkillStatusByJobId","jobId","job","recordSkillTestAttempt","testSessionId","TestTemplate","validityDays","testValidityDays","cooldownHours","retestCooldownHours","attempt","logger","log","getCandidateValidPasses","validAttempts","gte","SkillBucket","map","checkAllRequiredSkillsForJob","JobRequiredSkillBucket","displayOrder","requiredSkillBucketIds","push","req","includes","length","canApply","missingTests","passedTests","hasRequirements","status","deleteSkillBucket","delete","addSkillRequirementToJob","jobRequiredSkillBucket","upsert","jobId_skillBucketId","removeSkillRequirementFromJob","requirement","getJobSkillRequirements","legacySkillBucket","compositeRequirements","Logger"],"mappings":"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"}