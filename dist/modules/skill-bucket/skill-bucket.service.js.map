{"version":3,"sources":["../../../src/modules/skill-bucket/skill-bucket.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    NotFoundException,\r\n    BadRequestException,\r\n    Logger,\r\n} from '@nestjs/common';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { CreateSkillBucketDto, UpdateSkillBucketDto, SkillTestStatusDto } from './dto';\r\n\r\n// Validity duration in days\r\nconst TEST_VALIDITY_DAYS = 7;\r\n// Retest cooldown in hours\r\nconst RETEST_COOLDOWN_HOURS = 24;\r\n\r\n@Injectable()\r\nexport class SkillBucketService {\r\n    private readonly logger = new Logger(SkillBucketService.name);\r\n\r\n    constructor(private prisma: PrismaService) { }\r\n\r\n    // ==========================================\r\n    // ADMIN: Skill Bucket Management\r\n    // ==========================================\r\n\r\n    async createSkillBucket(dto: CreateSkillBucketDto) {\r\n        // Check if code already exists\r\n        const existing = await this.prisma.skillBucket.findUnique({\r\n            where: { code: dto.code },\r\n        });\r\n\r\n        if (existing) {\r\n            throw new BadRequestException(`Skill bucket with code '${dto.code}' already exists`);\r\n        }\r\n\r\n        return this.prisma.skillBucket.create({\r\n            data: {\r\n                code: dto.code,\r\n                name: dto.name,\r\n                description: dto.description,\r\n                displayName: dto.displayName || `HR Shortlisting Check - ${dto.name}`,\r\n                experienceMin: dto.experienceMin ?? 0,\r\n                experienceMax: dto.experienceMax ?? 3,\r\n                testId: dto.testId,\r\n            },\r\n            include: {\r\n                Test: true,\r\n            },\r\n        });\r\n    }\r\n\r\n    async updateSkillBucket(id: string, dto: UpdateSkillBucketDto) {\r\n        const bucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id },\r\n        });\r\n\r\n        if (!bucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        return this.prisma.skillBucket.update({\r\n            where: { id },\r\n            data: {\r\n                name: dto.name,\r\n                description: dto.description,\r\n                displayName: dto.displayName,\r\n                experienceMin: dto.experienceMin,\r\n                experienceMax: dto.experienceMax,\r\n                isActive: dto.isActive,\r\n                testId: dto.testId,\r\n            },\r\n            include: {\r\n                Test: true,\r\n            },\r\n        });\r\n    }\r\n\r\n    async getSkillBuckets(includeInactive = false) {\r\n        return this.prisma.skillBucket.findMany({\r\n            where: includeInactive ? {} : { isActive: true },\r\n            include: {\r\n                Test: {\r\n                    select: {\r\n                        id: true,\r\n                        title: true,\r\n                        duration: true,\r\n                        totalQuestionBank: true,\r\n                    },\r\n                },\r\n                _count: {\r\n                    select: {\r\n                        jobs: true,\r\n                        attempts: true,\r\n                    },\r\n                },\r\n            },\r\n            orderBy: { code: 'asc' },\r\n        });\r\n    }\r\n\r\n    async getSkillBucketById(id: string) {\r\n        const bucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id },\r\n            include: {\r\n                Test: true,\r\n            },\r\n        });\r\n\r\n        if (!bucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        return bucket;\r\n    }\r\n\r\n    async getSkillBucketByCode(code: string) {\r\n        const bucket = await this.prisma.skillBucket.findUnique({\r\n            where: { code },\r\n            include: {\r\n                Test: true,\r\n            },\r\n        });\r\n\r\n        if (!bucket) {\r\n            throw new NotFoundException(`Skill bucket '${code}' not found`);\r\n        }\r\n\r\n        return bucket;\r\n    }\r\n\r\n    // ==========================================\r\n    // Candidate: Skill Test Status Check\r\n    // ==========================================\r\n\r\n    /**\r\n     * Check candidate's skill test status for a specific skill bucket\r\n     * This is the CORE logic for determining:\r\n     * - If candidate has a valid pass (can apply without test)\r\n     * - If candidate has an expired pass (needs retest)\r\n     * - If candidate failed and is in cooldown (cannot retest yet)\r\n     * - If candidate failed and can retest (cooldown expired)\r\n     * - If candidate never took the test\r\n     */\r\n    async checkCandidateSkillStatus(\r\n        candidateId: string,\r\n        skillBucketId: string,\r\n    ): Promise<SkillTestStatusDto> {\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id: skillBucketId },\r\n        });\r\n\r\n        if (!skillBucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        // Get the most recent attempt for this candidate + skill bucket\r\n        const latestAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n            where: {\r\n                candidateId,\r\n                skillBucketId,\r\n            },\r\n            orderBy: { attemptedAt: 'desc' },\r\n        });\r\n\r\n        const now = new Date();\r\n\r\n        // Never taken\r\n        if (!latestAttempt) {\r\n            return {\r\n                skillBucketId,\r\n                skillBucketCode: skillBucket.code,\r\n                skillBucketName: skillBucket.name,\r\n                displayName: skillBucket.displayName || skillBucket.name,\r\n                isPassed: false,\r\n                isValid: false,\r\n                isFailed: false,\r\n                canReTest: true,\r\n                neverTaken: true,\r\n            };\r\n        }\r\n\r\n        // Passed attempt\r\n        if (latestAttempt.isPassed) {\r\n            const validTill = latestAttempt.validTill!;\r\n            const isValid = now <= validTill;\r\n\r\n            // Calculate days remaining\r\n            const msRemaining = validTill.getTime() - now.getTime();\r\n            const daysRemaining = Math.ceil(msRemaining / (1000 * 60 * 60 * 24));\r\n\r\n            return {\r\n                skillBucketId,\r\n                skillBucketCode: skillBucket.code,\r\n                skillBucketName: skillBucket.name,\r\n                displayName: skillBucket.displayName || skillBucket.name,\r\n                isPassed: true,\r\n                isValid,\r\n                score: latestAttempt.score,\r\n                validTill,\r\n                validDaysRemaining: isValid ? daysRemaining : 0,\r\n                isFailed: false,\r\n                canReTest: !isValid, // Can retest if expired\r\n                neverTaken: false,\r\n            };\r\n        }\r\n\r\n        // Failed attempt\r\n        const retestAllowedAt = latestAttempt.retestAllowedAt!;\r\n        const canRetest = now >= retestAllowedAt;\r\n\r\n        // Calculate hours until retest\r\n        const msUntilRetest = retestAllowedAt.getTime() - now.getTime();\r\n        const hoursUntilRetest = Math.ceil(msUntilRetest / (1000 * 60 * 60));\r\n\r\n        return {\r\n            skillBucketId,\r\n            skillBucketCode: skillBucket.code,\r\n            skillBucketName: skillBucket.name,\r\n            displayName: skillBucket.displayName || skillBucket.name,\r\n            isPassed: false,\r\n            isValid: false,\r\n            score: latestAttempt.score,\r\n            isFailed: true,\r\n            canRetest,\r\n            retestAllowedAt,\r\n            retestInHours: canRetest ? 0 : hoursUntilRetest,\r\n            neverTaken: false,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Check skill status by Job ID (for apply flow)\r\n     */\r\n    async checkCandidateSkillStatusByJobId(\r\n        candidateId: string,\r\n        jobId: string,\r\n    ): Promise<SkillTestStatusDto | null> {\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            select: { skillBucketId: true },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        // If job has no skill bucket, no test required\r\n        if (!job.skillBucketId) {\r\n            return null;\r\n        }\r\n\r\n        return this.checkCandidateSkillStatus(candidateId, job.skillBucketId);\r\n    }\r\n\r\n    // ==========================================\r\n    // RECORD TEST ATTEMPTS\r\n    // ==========================================\r\n\r\n    /**\r\n     * Record a skill test attempt after test submission\r\n     * Called from TestService after test is graded\r\n     */\r\n    async recordSkillTestAttempt(\r\n        candidateId: string,\r\n        skillBucketId: string,\r\n        isPassed: boolean,\r\n        score: number,\r\n        testSessionId?: string,\r\n    ) {\r\n        const now = new Date();\r\n\r\n        // Calculate validity or cooldown based on result\r\n        let validTill: Date | null = null;\r\n        let retestAllowedAt: Date | null = null;\r\n\r\n        if (isPassed) {\r\n            // Valid for 7 days\r\n            validTill = new Date(now.getTime() + TEST_VALIDITY_DAYS * 24 * 60 * 60 * 1000);\r\n        } else {\r\n            // Cooldown for 24 hours\r\n            retestAllowedAt = new Date(now.getTime() + RETEST_COOLDOWN_HOURS * 60 * 60 * 1000);\r\n        }\r\n\r\n        const attempt = await this.prisma.skillTestAttempt.create({\r\n            data: {\r\n                candidateId,\r\n                skillBucketId,\r\n                isPassed,\r\n                score,\r\n                validTill,\r\n                retestAllowedAt,\r\n                testSessionId,\r\n            },\r\n        });\r\n\r\n        this.logger.log(\r\n            `Recorded skill test attempt: candidate=${candidateId}, skill=${skillBucketId}, ` +\r\n            `passed=${isPassed}, score=${score}, validTill=${validTill}, retestAllowedAt=${retestAllowedAt}`\r\n        );\r\n\r\n        return attempt;\r\n    }\r\n\r\n    /**\r\n     * Get all valid skill passes for a candidate (for displaying badges)\r\n     */\r\n    async getCandidateValidPasses(candidateId: string) {\r\n        const now = new Date();\r\n\r\n        const validAttempts = await this.prisma.skillTestAttempt.findMany({\r\n            where: {\r\n                candidateId,\r\n                isPassed: true,\r\n                validTill: {\r\n                    gte: now,\r\n                },\r\n            },\r\n            include: {\r\n                SkillBucket: {\r\n                    select: {\r\n                        code: true,\r\n                        name: true,\r\n                        displayName: true,\r\n                    },\r\n                },\r\n            },\r\n            orderBy: { validTill: 'desc' },\r\n        });\r\n\r\n        return validAttempts.map(attempt => ({\r\n            skillBucketCode: attempt.skillBucket.code,\r\n            skillBucketName: attempt.skillBucket.name,\r\n            displayName: attempt.skillBucket.displayName || attempt.skillBucket.name,\r\n            score: attempt.score,\r\n            validTill: attempt.validTill,\r\n            daysRemaining: Math.ceil(\r\n                (attempt.validTill!.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)\r\n            ),\r\n        }));\r\n    }\r\n\r\n    // ==========================================\r\n    // COMPOSITE SKILL REQUIREMENTS (Full Stack etc.)\r\n    // ==========================================\r\n\r\n    /**\r\n     * Check ALL required skills for a job (supports composite skill requirements)\r\n     * For Full Stack jobs that require both Java Backend AND React Frontend\r\n     * \r\n     * Returns:\r\n     * - canApply: true if ALL required skills are passed and valid\r\n     * - missingTests: array of skills that need to be taken/retaken\r\n     * - passedTests: array of skills already passed and valid\r\n     */\r\n    async checkAllRequiredSkillsForJob(\r\n        candidateId: string,\r\n        jobId: string,\r\n    ): Promise<{\r\n        canApply: boolean;\r\n        missingTests: SkillTestStatusDto[];\r\n        passedTests: SkillTestStatusDto[];\r\n        hasRequirements: boolean;\r\n    }> {\r\n        // Get job with both legacy single skill bucket and new composite requirements\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            include: {\r\n                requiredSkillBucket: {\r\n                    include: {\r\n                        SkillBucket: true,\r\n                    },\r\n                    orderBy: { displayOrder: 'asc' },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        // Collect all required skill bucket IDs\r\n        const requiredSkillBucketIds: string[] = [];\r\n\r\n        // 1. Check legacy single skill bucket (backward compatibility)\r\n        if (job.skillBucketId) {\r\n            requiredSkillBucketIds.push(job.skillBucketId);\r\n        }\r\n\r\n        // 2. Check new composite skill requirements\r\n        for (const req of job.requiredSkillBuckets) {\r\n            if (!requiredSkillBucketIds.includes(req.skillBucketId)) {\r\n                requiredSkillBucketIds.push(req.skillBucketId);\r\n            }\r\n        }\r\n\r\n        // No skill requirements - can apply freely\r\n        if (requiredSkillBucketIds.length === 0) {\r\n            return {\r\n                canApply: true,\r\n                missingTests: [],\r\n                passedTests: [],\r\n                hasRequirements: false,\r\n            };\r\n        }\r\n\r\n        // Check each required skill\r\n        const passedTests: SkillTestStatusDto[] = [];\r\n        const missingTests: SkillTestStatusDto[] = [];\r\n\r\n        for (const skillBucketId of requiredSkillBucketIds) {\r\n            const status = await this.checkCandidateSkillStatus(candidateId, skillBucketId);\r\n\r\n            if (status.isPassed && status.isValid) {\r\n                passedTests.push(status);\r\n            } else {\r\n                missingTests.push(status);\r\n            }\r\n        }\r\n\r\n        return {\r\n            canApply: missingTests.length === 0,\r\n            missingTests,\r\n            passedTests,\r\n            hasRequirements: true,\r\n        };\r\n    }\r\n\r\n    // ==========================================\r\n    // ADMIN: Delete Skill Bucket\r\n    // ==========================================\r\n\r\n    async deleteSkillBucket(id: string) {\r\n        const bucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id },\r\n            include: {\r\n                _count: {\r\n                    select: {\r\n                        jobs: true,\r\n                        attempts: true,\r\n                        jobRequirements: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!bucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        // Check if skill bucket is in use\r\n        if (bucket._count.jobs > 0 || bucket._count.jobRequirements > 0) {\r\n            throw new BadRequestException(\r\n                `Cannot delete skill bucket: it is assigned to ${bucket._count.jobs + bucket._count.jobRequirements} job(s). Deactivate it instead.`\r\n            );\r\n        }\r\n\r\n        // If there are attempts, just deactivate instead of hard delete\r\n        if (bucket._count.attempts > 0) {\r\n            return this.prisma.skillBucket.update({\r\n                where: { id },\r\n                data: { isActive: false },\r\n            });\r\n        }\r\n\r\n        // Safe to hard delete\r\n        return this.prisma.skillBucket.delete({\r\n            where: { id },\r\n        });\r\n    }\r\n\r\n    // ==========================================\r\n    // ADMIN: Add/Remove Skill Requirements from Job\r\n    // ==========================================\r\n\r\n    async addSkillRequirementToJob(jobId: string, skillBucketId: string, displayOrder = 0) {\r\n        // Verify job exists\r\n        const job = await this.prisma.job.findUnique({ where: { id: jobId } });\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        // Verify skill bucket exists\r\n        const bucket = await this.prisma.skillBucket.findUnique({ where: { id: skillBucketId } });\r\n        if (!bucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        // Create the requirement (upsert to avoid duplicates)\r\n        return this.prisma.jobRequiredSkillBucket.upsert({\r\n            where: {\r\n                jobId_skillBucketId: { jobId, skillBucketId },\r\n            },\r\n            create: {\r\n                jobId,\r\n                skillBucketId,\r\n                displayOrder,\r\n            },\r\n            update: {\r\n                displayOrder,\r\n            },\r\n            include: {\r\n                SkillBucket: true,\r\n            },\r\n        });\r\n    }\r\n\r\n    async removeSkillRequirementFromJob(jobId: string, skillBucketId: string) {\r\n        const requirement = await this.prisma.jobRequiredSkillBucket.findUnique({\r\n            where: {\r\n                jobId_skillBucketId: { jobId, skillBucketId },\r\n            },\r\n        });\r\n\r\n        if (!requirement) {\r\n            throw new NotFoundException('Skill requirement not found for this job');\r\n        }\r\n\r\n        return this.prisma.jobRequiredSkillBucket.delete({\r\n            where: {\r\n                jobId_skillBucketId: { jobId, skillBucketId },\r\n            },\r\n        });\r\n    }\r\n\r\n    async getJobSkillRequirements(jobId: string) {\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            include: {\r\n                SkillBucket: true, // Legacy single bucket\r\n                requiredSkillBucket: {\r\n                    include: {\r\n                        SkillBucket: true,\r\n                    },\r\n                    orderBy: { displayOrder: 'asc' },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        return {\r\n            legacySkillBucket: job.SkillBucket,\r\n            compositeRequirements: job.requiredSkillBuckets,\r\n        };\r\n    }\r\n}\r\n"],"names":["SkillBucketService","TEST_VALIDITY_DAYS","RETEST_COOLDOWN_HOURS","createSkillBucket","dto","existing","prisma","skillBucket","findUnique","where","code","BadRequestException","create","data","name","description","displayName","experienceMin","experienceMax","testId","include","Test","updateSkillBucket","id","bucket","NotFoundException","update","isActive","getSkillBuckets","includeInactive","findMany","select","title","duration","totalQuestionBank","_count","jobs","attempts","orderBy","getSkillBucketById","getSkillBucketByCode","checkCandidateSkillStatus","candidateId","skillBucketId","latestAttempt","skillTestAttempt","findFirst","attemptedAt","now","Date","skillBucketCode","skillBucketName","isPassed","isValid","isFailed","canReTest","neverTaken","validTill","msRemaining","getTime","daysRemaining","Math","ceil","score","validDaysRemaining","retestAllowedAt","canRetest","msUntilRetest","hoursUntilRetest","retestInHours","checkCandidateSkillStatusByJobId","jobId","job","recordSkillTestAttempt","testSessionId","attempt","logger","log","getCandidateValidPasses","validAttempts","gte","SkillBucket","map","checkAllRequiredSkillsForJob","requiredSkillBucket","displayOrder","requiredSkillBucketIds","push","req","requiredSkillBuckets","includes","length","canApply","missingTests","passedTests","hasRequirements","status","deleteSkillBucket","jobRequirements","delete","addSkillRequirementToJob","jobRequiredSkillBucket","upsert","jobId_skillBucketId","removeSkillRequirementFromJob","requirement","getJobSkillRequirements","legacySkillBucket","compositeRequirements","Logger"],"mappings":"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"}