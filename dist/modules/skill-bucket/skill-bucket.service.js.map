{"version":3,"sources":["../../../src/modules/skill-bucket/skill-bucket.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  NotFoundException,\r\n  BadRequestException,\r\n  Logger,\r\n} from '@nestjs/common';\r\nimport * as crypto from 'crypto';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport {\r\n  CreateSkillBucketDto,\r\n  UpdateSkillBucketDto,\r\n  SkillTestStatusDto,\r\n} from './dto';\r\n\r\n// Validity duration in days\r\nconst TEST_VALIDITY_DAYS = 7;\r\n// Retest cooldown in hours\r\nconst RETEST_COOLDOWN_HOURS = 24;\r\n\r\n@Injectable()\r\nexport class SkillBucketService {\r\n  private readonly logger = new Logger(SkillBucketService.name);\r\n\r\n  constructor(private prisma: PrismaService) { }\r\n\r\n  // ==========================================\r\n  // ADMIN: Skill Bucket Management\r\n  // ==========================================\r\n\r\n  async createSkillBucket(dto: CreateSkillBucketDto) {\r\n    // Check if code already exists\r\n    const existing = await this.prisma.skillBucket.findUnique({\r\n      where: { code: dto.code },\r\n    });\r\n\r\n    if (existing) {\r\n      throw new BadRequestException(\r\n        `Skill bucket with code '${dto.code}' already exists`,\r\n      );\r\n    }\r\n\r\n    return this.prisma.skillBucket.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        code: dto.code,\r\n        name: dto.name,\r\n        description: dto.description,\r\n        displayName: dto.displayName || `HR Shortlisting Check - ${dto.name}`,\r\n        experienceMin: dto.experienceMin ?? 0,\r\n        experienceMax: dto.experienceMax ?? 3,\r\n        updatedAt: new Date(),\r\n      },\r\n      include: {\r\n        Test: true,\r\n      },\r\n    });\r\n  }\r\n\r\n  async updateSkillBucket(id: string, dto: UpdateSkillBucketDto) {\r\n    const bucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id },\r\n    });\r\n\r\n    if (!bucket) {\r\n      throw new NotFoundException('Skill bucket not found');\r\n    }\r\n\r\n    return this.prisma.skillBucket.update({\r\n      where: { id },\r\n      data: {\r\n        name: dto.name,\r\n        description: dto.description,\r\n        displayName: dto.displayName,\r\n        experienceMin: dto.experienceMin,\r\n        experienceMax: dto.experienceMax,\r\n        isActive: dto.isActive,\r\n        testId: dto.testId,\r\n      },\r\n      include: {\r\n        Test: true,\r\n      },\r\n    });\r\n  }\r\n\r\n  async getSkillBuckets(includeInactive = false) {\r\n    return this.prisma.skillBucket.findMany({\r\n      where: includeInactive ? {} : { isActive: true },\r\n      include: {\r\n        Test: {\r\n          select: {\r\n            id: true,\r\n            title: true,\r\n            duration: true,\r\n            totalQuestions: true,\r\n          },\r\n        },\r\n        _count: {\r\n          select: {\r\n            Job: true,\r\n            SkillTestAttempt: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: { code: 'asc' },\r\n    });\r\n  }\r\n\r\n  async getSkillBucketById(id: string) {\r\n    const bucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id },\r\n      include: {\r\n        Test: true,\r\n      },\r\n    });\r\n\r\n    if (!bucket) {\r\n      throw new NotFoundException('Skill bucket not found');\r\n    }\r\n\r\n    return bucket;\r\n  }\r\n\r\n  async getSkillBucketByCode(code: string) {\r\n    const bucket = await this.prisma.skillBucket.findUnique({\r\n      where: { code },\r\n      include: {\r\n        Test: true,\r\n      },\r\n    });\r\n\r\n    if (!bucket) {\r\n      throw new NotFoundException(`Skill bucket '${code}' not found`);\r\n    }\r\n\r\n    return bucket;\r\n  }\r\n\r\n  // ==========================================\r\n  // Candidate: Skill Test Status Check\r\n  // ==========================================\r\n\r\n  /**\r\n   * Check candidate's skill test status for a specific skill bucket\r\n   * This is the CORE logic for determining:\r\n   * - If candidate has a valid pass (can apply without test)\r\n   * - If candidate has an expired pass (needs retest)\r\n   * - If candidate failed and is in cooldown (cannot retest yet)\r\n   * - If candidate failed and can retest (cooldown expired)\r\n   * - If candidate never took the test\r\n   */\r\n  async checkCandidateSkillStatus(\r\n    candidateId: string,\r\n    skillBucketId: string,\r\n  ): Promise<SkillTestStatusDto> {\r\n    const skillBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n    });\r\n\r\n    if (!skillBucket) {\r\n      throw new NotFoundException('Skill bucket not found');\r\n    }\r\n\r\n    // Get the most recent attempt for this candidate + skill bucket\r\n    const latestAttempt = await this.prisma.skillTestAttempt.findFirst({\r\n      where: {\r\n        candidateId,\r\n        skillBucketId,\r\n      },\r\n      orderBy: { attemptedAt: 'desc' },\r\n    });\r\n\r\n    const now = new Date();\r\n\r\n    // Never taken\r\n    if (!latestAttempt) {\r\n      return {\r\n        skillBucketId,\r\n        skillBucketCode: skillBucket.code,\r\n        skillBucketName: skillBucket.name,\r\n        displayName: skillBucket.displayName || skillBucket.name,\r\n        isPassed: false,\r\n        isValid: false,\r\n        isFailed: false,\r\n        canRetest: true,\r\n        neverTaken: true,\r\n      };\r\n    }\r\n\r\n    // Passed attempt\r\n    if (latestAttempt.isPassed) {\r\n      const validTill = latestAttempt.validTill!;\r\n      const isValid = now <= validTill;\r\n\r\n      // Calculate days remaining\r\n      const msRemaining = validTill.getTime() - now.getTime();\r\n      const daysRemaining = Math.ceil(msRemaining / (1000 * 60 * 60 * 24));\r\n\r\n      return {\r\n        skillBucketId,\r\n        skillBucketCode: skillBucket.code,\r\n        skillBucketName: skillBucket.name,\r\n        displayName: skillBucket.displayName || skillBucket.name,\r\n        isPassed: true,\r\n        isValid,\r\n        score: latestAttempt.score,\r\n        validTill,\r\n        validDaysRemaining: isValid ? daysRemaining : 0,\r\n        isFailed: false,\r\n        canRetest: !isValid, // Can retest if expired\r\n        neverTaken: false,\r\n      };\r\n    }\r\n\r\n    // Failed attempt\r\n    const retestAllowedAt = latestAttempt.retestAllowedAt!;\r\n    const canRetest = now >= retestAllowedAt;\r\n\r\n    // Calculate hours until retest\r\n    const msUntilRetest = retestAllowedAt.getTime() - now.getTime();\r\n    const hoursUntilRetest = Math.ceil(msUntilRetest / (1000 * 60 * 60));\r\n\r\n    return {\r\n      skillBucketId,\r\n      skillBucketCode: skillBucket.code,\r\n      skillBucketName: skillBucket.name,\r\n      displayName: skillBucket.displayName || skillBucket.name,\r\n      isPassed: false,\r\n      isValid: false,\r\n      score: latestAttempt.score,\r\n      isFailed: true,\r\n      canRetest,\r\n      retestAllowedAt,\r\n      retestInHours: canRetest ? 0 : hoursUntilRetest,\r\n      neverTaken: false,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check skill status by Job ID (for apply flow)\r\n   */\r\n  async checkCandidateSkillStatusByJobId(\r\n    candidateId: string,\r\n    jobId: string,\r\n  ): Promise<SkillTestStatusDto | null> {\r\n    const job = await this.prisma.job.findUnique({\r\n      where: { id: jobId },\r\n      select: { skillBucketId: true },\r\n    });\r\n\r\n    if (!job) {\r\n      throw new NotFoundException('Job not found');\r\n    }\r\n\r\n    // If job has no skill bucket, no test required\r\n    if (!job.skillBucketId) {\r\n      return null;\r\n    }\r\n\r\n    return this.checkCandidateSkillStatus(candidateId, job.skillBucketId);\r\n  }\r\n\r\n  // ==========================================\r\n  // RECORD TEST ATTEMPTS\r\n  // ==========================================\r\n\r\n  /**\r\n   * Record a skill test attempt after test submission\r\n   * Called from TestService after test is graded\r\n   */\r\n  async recordSkillTestAttempt(\r\n    candidateId: string,\r\n    skillBucketId: string,\r\n    isPassed: boolean,\r\n    score: number,\r\n    testSessionId?: string,\r\n  ) {\r\n    const now = new Date();\r\n\r\n    // Get configured validity/cooldown from TestTemplate (via SkillBucket)\r\n    const skillBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n      include: { TestTemplate: true },\r\n    });\r\n\r\n    // Use configured values or defaults\r\n    const validityDays =\r\n      skillBucket?.TestTemplate?.testValidityDays ?? TEST_VALIDITY_DAYS;\r\n    const cooldownHours =\r\n      skillBucket?.TestTemplate?.retestCooldownHours ?? RETEST_COOLDOWN_HOURS;\r\n\r\n    // Calculate validity or cooldown based on result\r\n    let validTill: Date | null = null;\r\n    let retestAllowedAt: Date | null = null;\r\n\r\n    if (isPassed) {\r\n      // Valid for configured days\r\n      validTill = new Date(now.getTime() + validityDays * 24 * 60 * 60 * 1000);\r\n    } else {\r\n      // Cooldown for configured hours\r\n      retestAllowedAt = new Date(\r\n        now.getTime() + cooldownHours * 60 * 60 * 1000,\r\n      );\r\n    }\r\n\r\n    const attempt = await this.prisma.skillTestAttempt.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        candidateId,\r\n        skillBucketId,\r\n        isPassed,\r\n        score,\r\n        validTill,\r\n        retestAllowedAt,\r\n        testSessionId,\r\n      },\r\n    });\r\n\r\n    this.logger.log(\r\n      `Recorded skill test attempt: candidate=${candidateId}, skill=${skillBucketId}, ` +\r\n      `passed=${isPassed}, score=${score}, validTill=${validTill}, retestAllowedAt=${retestAllowedAt}, ` +\r\n      `validityDays=${validityDays}, cooldownHours=${cooldownHours}`,\r\n    );\r\n\r\n    return attempt;\r\n  }\r\n\r\n  /**\r\n   * Get all valid skill passes for a candidate (for displaying badges)\r\n   */\r\n  async getCandidateValidPasses(candidateId: string) {\r\n    const now = new Date();\r\n\r\n    const validAttempts = await this.prisma.skillTestAttempt.findMany({\r\n      where: {\r\n        candidateId,\r\n        isPassed: true,\r\n        validTill: {\r\n          gte: now,\r\n        },\r\n      },\r\n      include: {\r\n        SkillBucket: {\r\n          select: {\r\n            code: true,\r\n            name: true,\r\n            displayName: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: { validTill: 'desc' },\r\n    });\r\n\r\n    return validAttempts.map((attempt) => ({\r\n      skillBucketCode: attempt.SkillBucket.code,\r\n      skillBucketName: attempt.SkillBucket.name,\r\n      displayName: attempt.SkillBucket.displayName || attempt.SkillBucket.name,\r\n      score: attempt.score,\r\n      validTill: attempt.validTill,\r\n      daysRemaining: Math.ceil(\r\n        (attempt.validTill!.getTime() - now.getTime()) / (1000 * 60 * 60 * 24),\r\n      ),\r\n    }));\r\n  }\r\n\r\n  // ==========================================\r\n  // COMPOSITE SKILL REQUIREMENTS (Full Stack etc.)\r\n  // ==========================================\r\n\r\n  /**\r\n   * Check ALL required skills for a job (supports composite skill requirements)\r\n   * For Full Stack jobs that require both Java Backend AND React Frontend\r\n   *\r\n   * Returns:\r\n   * - canApply: true if ALL required skills are passed and valid\r\n   * - missingTests: array of skills that need to be taken/retaken\r\n   * - passedTests: array of skills already passed and valid\r\n   */\r\n  async checkAllRequiredSkillsForJob(\r\n    candidateId: string,\r\n    jobId: string,\r\n  ): Promise<{\r\n    canApply: boolean;\r\n    missingTests: SkillTestStatusDto[];\r\n    passedTests: SkillTestStatusDto[];\r\n    hasRequirements: boolean;\r\n  }> {\r\n    // Get job with both legacy single skill bucket and new composite requirements\r\n    const job = await this.prisma.job.findUnique({\r\n      where: { id: jobId },\r\n      include: {\r\n        JobRequiredSkillBucket: {\r\n          include: {\r\n            SkillBucket: true,\r\n          },\r\n          orderBy: { displayOrder: 'asc' },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!job) {\r\n      throw new NotFoundException('Job not found');\r\n    }\r\n\r\n    // Collect all required skill bucket IDs\r\n    const requiredSkillBucketIds: string[] = [];\r\n\r\n    // 1. Check legacy single skill bucket (backward compatibility)\r\n    if (job.skillBucketId) {\r\n      requiredSkillBucketIds.push(job.skillBucketId);\r\n    }\r\n\r\n    // 2. Check new composite skill requirements\r\n    for (const req of job.JobRequiredSkillBucket) {\r\n      if (!requiredSkillBucketIds.includes(req.skillBucketId)) {\r\n        requiredSkillBucketIds.push(req.skillBucketId);\r\n      }\r\n    }\r\n\r\n    // No skill requirements - can apply freely\r\n    if (requiredSkillBucketIds.length === 0) {\r\n      return {\r\n        canApply: true,\r\n        missingTests: [],\r\n        passedTests: [],\r\n        hasRequirements: false,\r\n      };\r\n    }\r\n\r\n    // Check each required skill\r\n    const passedTests: SkillTestStatusDto[] = [];\r\n    const missingTests: SkillTestStatusDto[] = [];\r\n\r\n    for (const skillBucketId of requiredSkillBucketIds) {\r\n      const status = await this.checkCandidateSkillStatus(\r\n        candidateId,\r\n        skillBucketId,\r\n      );\r\n\r\n      if (status.isPassed && status.isValid) {\r\n        passedTests.push(status);\r\n      } else {\r\n        missingTests.push(status);\r\n      }\r\n    }\r\n\r\n    return {\r\n      canApply: missingTests.length === 0,\r\n      missingTests,\r\n      passedTests,\r\n      hasRequirements: true,\r\n    };\r\n  }\r\n\r\n  // ==========================================\r\n  // ADMIN: Delete Skill Bucket\r\n  // ==========================================\r\n\r\n  async deleteSkillBucket(id: string) {\r\n    const bucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id },\r\n      include: {\r\n        _count: {\r\n          select: {\r\n            Job: true,\r\n            SkillTestAttempt: true,\r\n            JobRequiredSkillBucket: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!bucket) {\r\n      throw new NotFoundException('Skill bucket not found');\r\n    }\r\n\r\n    // Check if skill bucket is in use\r\n    if (bucket._count.Job > 0 || bucket._count.JobRequiredSkillBucket > 0) {\r\n      throw new BadRequestException(\r\n        `Cannot delete skill bucket: it is assigned to ${bucket._count.Job + bucket._count.JobRequiredSkillBucket} job(s). Deactivate it instead.`,\r\n      );\r\n    }\r\n\r\n    // If there are attempts, just deactivate instead of hard delete\r\n    if (bucket._count.SkillTestAttempt > 0) {\r\n      return this.prisma.skillBucket.update({\r\n        where: { id },\r\n        data: { isActive: false },\r\n      });\r\n    }\r\n\r\n    // Safe to hard delete\r\n    return this.prisma.skillBucket.delete({\r\n      where: { id },\r\n    });\r\n  }\r\n\r\n  // ==========================================\r\n  // ADMIN: Add/Remove Skill Requirements from Job\r\n  // ==========================================\r\n\r\n  async addSkillRequirementToJob(\r\n    jobId: string,\r\n    skillBucketId: string,\r\n    displayOrder = 0,\r\n  ) {\r\n    // Verify job exists\r\n    const job = await this.prisma.job.findUnique({ where: { id: jobId } });\r\n    if (!job) {\r\n      throw new NotFoundException('Job not found');\r\n    }\r\n\r\n    // Verify skill bucket exists\r\n    const bucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n    });\r\n    if (!bucket) {\r\n      throw new NotFoundException('Skill bucket not found');\r\n    }\r\n\r\n    // Create the requirement (upsert to avoid duplicates)\r\n    return this.prisma.jobRequiredSkillBucket.upsert({\r\n      where: {\r\n        jobId_skillBucketId: { jobId, skillBucketId },\r\n      },\r\n      create: {\r\n        id: crypto.randomUUID(),\r\n        jobId,\r\n        skillBucketId,\r\n        displayOrder,\r\n      },\r\n      update: {\r\n        displayOrder,\r\n      },\r\n      include: {\r\n        SkillBucket: true,\r\n      },\r\n    });\r\n  }\r\n\r\n  async removeSkillRequirementFromJob(jobId: string, skillBucketId: string) {\r\n    const requirement = await this.prisma.jobRequiredSkillBucket.findUnique({\r\n      where: {\r\n        jobId_skillBucketId: { jobId, skillBucketId },\r\n      },\r\n    });\r\n\r\n    if (!requirement) {\r\n      throw new NotFoundException('Skill requirement not found for this job');\r\n    }\r\n\r\n    return this.prisma.jobRequiredSkillBucket.delete({\r\n      where: {\r\n        jobId_skillBucketId: { jobId, skillBucketId },\r\n      },\r\n    });\r\n  }\r\n\r\n  async getJobSkillRequirements(jobId: string) {\r\n    const job = await this.prisma.job.findUnique({\r\n      where: { id: jobId },\r\n      include: {\r\n        SkillBucket: true, // Legacy single bucket\r\n        JobRequiredSkillBucket: {\r\n          include: {\r\n            SkillBucket: true,\r\n          },\r\n          orderBy: { displayOrder: 'asc' },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!job) {\r\n      throw new NotFoundException('Job not found');\r\n    }\r\n\r\n    return {\r\n      legacySkillBucket: job.SkillBucket,\r\n      compositeRequirements: job.JobRequiredSkillBucket,\r\n    };\r\n  }\r\n}\r\n"],"names":["SkillBucketService","TEST_VALIDITY_DAYS","RETEST_COOLDOWN_HOURS","createSkillBucket","dto","existing","prisma","skillBucket","findUnique","where","code","BadRequestException","create","data","id","crypto","randomUUID","name","description","displayName","experienceMin","experienceMax","updatedAt","Date","include","Test","updateSkillBucket","bucket","NotFoundException","update","isActive","testId","getSkillBuckets","includeInactive","findMany","select","title","duration","totalQuestions","_count","Job","SkillTestAttempt","orderBy","getSkillBucketById","getSkillBucketByCode","checkCandidateSkillStatus","candidateId","skillBucketId","latestAttempt","skillTestAttempt","findFirst","attemptedAt","now","skillBucketCode","skillBucketName","isPassed","isValid","isFailed","canRetest","neverTaken","validTill","msRemaining","getTime","daysRemaining","Math","ceil","score","validDaysRemaining","retestAllowedAt","msUntilRetest","hoursUntilRetest","retestInHours","checkCandidateSkillStatusByJobId","jobId","job","recordSkillTestAttempt","testSessionId","TestTemplate","validityDays","testValidityDays","cooldownHours","retestCooldownHours","attempt","logger","log","getCandidateValidPasses","validAttempts","gte","SkillBucket","map","checkAllRequiredSkillsForJob","JobRequiredSkillBucket","displayOrder","requiredSkillBucketIds","push","req","includes","length","canApply","missingTests","passedTests","hasRequirements","status","deleteSkillBucket","delete","addSkillRequirementToJob","jobRequiredSkillBucket","upsert","jobId_skillBucketId","removeSkillRequirementFromJob","requirement","getJobSkillRequirements","legacySkillBucket","compositeRequirements","Logger"],"mappings":"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"}