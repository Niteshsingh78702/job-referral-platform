{"version":3,"sources":["../../../src/modules/test/test.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    NotFoundException,\r\n    BadRequestException,\r\n    ForbiddenException,\r\n    Logger,\r\n} from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport * as crypto from 'crypto';\r\nimport Redis from 'ioredis';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { CreateTestDto, CreateRoleTestDto, UpdateTestDto, AddQuestionDto, SubmitAnswerDto, TestEventDto } from './dto';\r\nimport {\r\n    TestSessionStatus,\r\n    ApplicationStatus,\r\n    CandidateTestAttemptStatus,\r\n    ReferralStatus,\r\n    AuditAction,\r\n    REDIS_KEYS,\r\n} from '../../common/constants';\r\nimport { SkillBucketService } from '../skill-bucket/skill-bucket.service';\r\n\r\ninterface TestSessionData {\r\n    sessionId: string;\r\n    applicationId: string;\r\n    testId: string;\r\n    userId: string;\r\n    startedAt: number;\r\n    endsAt: number;\r\n    questionOrder: number[];\r\n    tabSwitchCount: number;\r\n    maxTabSwitches: number;\r\n}\r\n\r\n@Injectable()\r\nexport class TestService {\r\n    private redis: Redis | null = null;\r\n    private readonly logger = new Logger(TestService.name);\r\n    // In-memory fallback for test sessions\r\n    private sessionStore: Map<string, { data: string; expiry: number }> = new Map();\r\n\r\n    constructor(\r\n        private prisma: PrismaService,\r\n        private configService: ConfigService,\r\n        private skillBucketService: SkillBucketService,\r\n    ) {\r\n        this.initRedis();\r\n    }\r\n\r\n    private initRedis(): void {\r\n        const redisUrl = this.configService.get('REDIS_URL');\r\n        const redisHost = this.configService.get('REDIS_HOST');\r\n\r\n        if (redisUrl || redisHost) {\r\n            try {\r\n                if (redisUrl) {\r\n                    this.redis = new Redis(redisUrl);\r\n                } else {\r\n                    this.redis = new Redis({\r\n                        host: redisHost || 'localhost',\r\n                        port: this.configService.get('REDIS_PORT', 6379),\r\n                        password: this.configService.get('REDIS_PASSWORD'),\r\n                    });\r\n                }\r\n\r\n                this.redis.on('error', (err) => {\r\n                    this.logger.warn(`Redis error: ${err.message}. Using in-memory storage.`);\r\n                    this.redis = null;\r\n                });\r\n            } catch {\r\n                this.logger.warn('Redis not available. Test sessions will use in-memory storage.');\r\n            }\r\n        } else {\r\n            this.logger.log('Redis not configured. Test sessions will use in-memory storage.');\r\n        }\r\n    }\r\n\r\n    // Helper methods for Redis operations with fallback\r\n    private async redisSet(key: string, value: string, pxMs?: number): Promise<void> {\r\n        if (this.redis) {\r\n            try {\r\n                if (pxMs) {\r\n                    await this.redis.set(key, value, 'PX', pxMs);\r\n                } else {\r\n                    await this.redis.set(key, value);\r\n                }\r\n                return;\r\n            } catch {\r\n                // Fall through to in-memory\r\n            }\r\n        }\r\n        this.sessionStore.set(key, { data: value, expiry: pxMs ? Date.now() + pxMs : Date.now() + 3600000 });\r\n    }\r\n\r\n    private async redisGet(key: string): Promise<string | null> {\r\n        if (this.redis) {\r\n            try {\r\n                return await this.redis.get(key);\r\n            } catch {\r\n                // Fall through\r\n            }\r\n        }\r\n        const stored = this.sessionStore.get(key);\r\n        if (!stored) return null;\r\n        if (Date.now() > stored.expiry) {\r\n            this.sessionStore.delete(key);\r\n            return null;\r\n        }\r\n        return stored.data;\r\n    }\r\n\r\n    private async redisDel(key: string): Promise<void> {\r\n        if (this.redis) {\r\n            try {\r\n                await this.redis.del(key);\r\n            } catch {\r\n                // Fall through\r\n            }\r\n        }\r\n        this.sessionStore.delete(key);\r\n    }\r\n\r\n    // ===========================================\r\n    // ADMIN: Test Management\r\n    // ===========================================\r\n\r\n    async createTest(dto: CreateTestDto) {\r\n        return this.prisma.test.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                title: dto.title,\r\n                description: dto.description,\r\n                duration: dto.duration || 30,\r\n                passingScore: dto.passingScore || 70,\r\n                totalTestQuestion: dto.totalQuestions || 20,\r\n                shuffleTestQuestion: dto.shuffleQuestions ?? true,\r\n                maxTabSwitches: dto.maxTabSwitches || 2,\r\n                difficulty: dto.difficulty || 'MEDIUM',\r\n                updatedAt: new Date(),\r\n            },\r\n        });\r\n    }\r\n\r\n    async addQuestion(testId: string, dto: AddQuestionDto) {\r\n        const test = await this.prisma.test.findUnique({\r\n            where: { id: testId },\r\n            include: { TestQuestion: true },\r\n        });\r\n\r\n        if (!test) {\r\n            throw new NotFoundException('Test not found');\r\n        }\r\n\r\n        return this.prisma.testQuestion.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                testId,\r\n                question: dto.question,\r\n                options: dto.options,\r\n                correctAnswer: dto.correctAnswer,\r\n                explanation: dto.explanation,\r\n                points: dto.points || 1,\r\n                orderIndex: test.TestQuestion.length,\r\n            },\r\n        });\r\n    }\r\n\r\n    async getTestById(testId: string) {\r\n        const test = await this.prisma.test.findUnique({\r\n            where: { id: testId },\r\n            include: {\r\n                TestQuestion: {\r\n                    orderBy: { orderIndex: 'asc' },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!test) {\r\n            throw new NotFoundException('Test not found');\r\n        }\r\n\r\n        return test;\r\n    }\r\n\r\n    // ===========================================\r\n    // ADMIN: Role-Based Test Management\r\n    // ===========================================\r\n\r\n    async createRoleTest(dto: CreateRoleTestDto) {\r\n        // Check if test already exists for this skill bucket (role)\r\n        const existingTest = await this.prisma.skillBucket.findUnique({\r\n            where: { id: dto.skillBucketId },\r\n            include: { Test: true },\r\n        });\r\n\r\n        if (!existingTest) {\r\n            throw new NotFoundException('Skill bucket (role) not found');\r\n        }\r\n\r\n        if (existingTest.testId) {\r\n            throw new BadRequestException('Test already exists for this role. Each role can have only one test.');\r\n        }\r\n\r\n        // Create the test\r\n        const test = await this.prisma.test.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                title: dto.title,\r\n                description: dto.description,\r\n                duration: dto.duration || 30,\r\n                passingScore: dto.passingScore || 70,\r\n                totalQuestions: dto.totalQuestions || 20,\r\n                validityDays: dto.validityDays || 7,\r\n                isActive: dto.isActive || false,\r\n                updatedAt: new Date(),\r\n            },\r\n        });\r\n\r\n        // Link test to skill bucket\r\n        await this.prisma.skillBucket.update({\r\n            where: { id: dto.skillBucketId },\r\n            data: { testId: test.id },\r\n        });\r\n\r\n        return test;\r\n    }\r\n\r\n    async getAllRoleTests() {\r\n        const skillBuckets = await this.prisma.skillBucket.findMany({\r\n            include: {\r\n                Test: {\r\n                    include: {\r\n                        TestQuestion: true,\r\n                        _count: {\r\n                            select: { TestSession: true },\r\n                        },\r\n                    },\r\n                },\r\n                TestTemplate: {\r\n                    select: {\r\n                        selectionRoleType: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        // For each bucket, count available questions from QuestionBank\r\n        const roleTestsWithQuestionCount = await Promise.all(\r\n            skillBuckets.map(async (bucket) => {\r\n                // Use TestTemplate.selectionRoleType if set, otherwise use bucket.code\r\n                const roleType = bucket.TestTemplate?.selectionRoleType || bucket.code;\r\n                const availableQuestions = await this.prisma.questionBank.count({\r\n                    where: {\r\n                        roleType: roleType,\r\n                        isActive: true,\r\n                    },\r\n                });\r\n\r\n                return {\r\n                    skillBucketId: bucket.id,\r\n                    skillBucketName: bucket.name,\r\n                    skillBucketCode: bucket.code,\r\n                    test: bucket.Test ? {\r\n                        id: bucket.Test.id,\r\n                        title: bucket.Test.title,\r\n                        description: bucket.Test.description,\r\n                        duration: bucket.Test.duration,\r\n                        passingScore: bucket.Test.passingScore,\r\n                        totalQuestions: bucket.Test.totalQuestions,\r\n                        validityDays: bucket.Test.validityDays,\r\n                        isActive: bucket.Test.isActive,\r\n                        questionsCount: availableQuestions, // Now counts from QuestionBank\r\n                        sessionsCount: bucket.Test._count.TestSession,\r\n                        createdAt: bucket.Test.createdAt,\r\n                    } : null,\r\n                };\r\n            })\r\n        );\r\n\r\n        return roleTestsWithQuestionCount;\r\n    }\r\n\r\n    async getTestBySkillBucket(skillBucketId: string) {\r\n        const skillBucket = await this.prisma.skillBucket.findUnique({\r\n            where: { id: skillBucketId },\r\n            include: {\r\n                Test: {\r\n                    include: {\r\n                        TestQuestion: {\r\n                            orderBy: { orderIndex: 'asc' },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!skillBucket) {\r\n            throw new NotFoundException('Skill bucket not found');\r\n        }\r\n\r\n        if (!skillBucket.Test) {\r\n            throw new NotFoundException('No test found for this role');\r\n        }\r\n\r\n        return {\r\n            skillBucket: {\r\n                id: skillBucket.id,\r\n                name: skillBucket.name,\r\n                code: skillBucket.code,\r\n            },\r\n            test: skillBucket.Test,\r\n        };\r\n    }\r\n\r\n    async updateTest(testId: string, dto: UpdateTestDto) {\r\n        const test = await this.prisma.test.findUnique({\r\n            where: { id: testId },\r\n            include: { TestQuestion: true },\r\n        });\r\n\r\n        if (!test) {\r\n            throw new NotFoundException('Test not found');\r\n        }\r\n\r\n        // Validate activation - cannot activate without questions\r\n        if (dto.isActive === true && test.TestQuestion.length === 0) {\r\n            throw new BadRequestException('Cannot activate test without questions. Add at least one question first.');\r\n        }\r\n\r\n        return this.prisma.test.update({\r\n            where: { id: testId },\r\n            data: {\r\n                ...(dto.title && { title: dto.title }),\r\n                ...(dto.description !== undefined && { description: dto.description }),\r\n                ...(dto.duration && { duration: dto.duration }),\r\n                ...(dto.passingScore && { passingScore: dto.passingScore }),\r\n                ...(dto.totalQuestions && { totalQuestions: dto.totalQuestions }),\r\n                ...(dto.validityDays && { validityDays: dto.validityDays }),\r\n                ...(dto.isActive !== undefined && { isActive: dto.isActive }),\r\n                updatedAt: new Date(),\r\n            },\r\n        });\r\n    }\r\n\r\n    async activateTest(testId: string) {\r\n        const test = await this.prisma.test.findUnique({\r\n            where: { id: testId },\r\n            include: {\r\n                SkillBucket: true,\r\n            },\r\n        });\r\n\r\n        if (!test) {\r\n            throw new NotFoundException('Test not found');\r\n        }\r\n\r\n        // Check if there are questions in QuestionBank matching the skill bucket code\r\n        const skillBucketCode = test.SkillBucket?.code;\r\n        const questionCount = await this.prisma.questionBank.count({\r\n            where: {\r\n                roleType: skillBucketCode || '',\r\n                isActive: true,\r\n            },\r\n        });\r\n\r\n        if (questionCount === 0) {\r\n            throw new BadRequestException(\r\n                `Cannot activate test without questions. No questions found in Question Bank for role type \"${skillBucketCode}\". Add questions first using CSV upload.`\r\n            );\r\n        }\r\n\r\n        return this.prisma.test.update({\r\n            where: { id: testId },\r\n            data: { isActive: true, updatedAt: new Date() },\r\n        });\r\n    }\r\n\r\n    async deactivateTest(testId: string) {\r\n        const test = await this.prisma.test.findUnique({\r\n            where: { id: testId },\r\n        });\r\n\r\n        if (!test) {\r\n            throw new NotFoundException('Test not found');\r\n        }\r\n\r\n        return this.prisma.test.update({\r\n            where: { id: testId },\r\n            data: { isActive: false, updatedAt: new Date() },\r\n        });\r\n    }\r\n\r\n    // ===========================================\r\n    // Candidate: Test Eligibility & Taking\r\n    // ===========================================\r\n\r\n    async getTestEligibility(candidateId: string, jobId: string) {\r\n        // Get job with skill bucket and test info\r\n        const job = await this.prisma.job.findUnique({\r\n            where: { id: jobId },\r\n            include: {\r\n                SkillBucket: {\r\n                    include: { Test: true },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!job) {\r\n            throw new NotFoundException('Job not found');\r\n        }\r\n\r\n        if (!job.SkillBucket || !job.SkillBucket.Test) {\r\n            return {\r\n                eligible: false,\r\n                reason: 'NO_TEST_CONFIGURED',\r\n                message: 'No test is configured for this job role.',\r\n            };\r\n        }\r\n\r\n        const test = job.SkillBucket.Test;\r\n\r\n        if (!test.isActive) {\r\n            return {\r\n                eligible: false,\r\n                reason: 'TEST_INACTIVE',\r\n                message: 'Test is currently not available for this role.',\r\n            };\r\n        }\r\n\r\n        // Check for existing attempt\r\n        const existingAttempt = await this.prisma.candidateTestAttempt.findUnique({\r\n            where: {\r\n                candidateId_jobId: {\r\n                    candidateId,\r\n                    jobId,\r\n                },\r\n            },\r\n        });\r\n\r\n        if (existingAttempt) {\r\n            if (existingAttempt.status === CandidateTestAttemptStatus.PASSED) {\r\n                return {\r\n                    eligible: false,\r\n                    reason: 'ALREADY_PASSED',\r\n                    message: 'You have already passed the test for this job.',\r\n                    attemptStatus: existingAttempt.status,\r\n                    score: existingAttempt.score,\r\n                };\r\n            }\r\n\r\n            if (existingAttempt.status === CandidateTestAttemptStatus.FAILED) {\r\n                return {\r\n                    eligible: false,\r\n                    reason: 'ALREADY_FAILED',\r\n                    message: 'You have already failed the test for this job. Re-attempts are not allowed.',\r\n                    attemptStatus: existingAttempt.status,\r\n                    score: existingAttempt.score,\r\n                };\r\n            }\r\n\r\n            if (existingAttempt.status === CandidateTestAttemptStatus.EXPIRED) {\r\n                return {\r\n                    eligible: false,\r\n                    reason: 'TEST_EXPIRED',\r\n                    message: 'The test validity period has expired.',\r\n                    attemptStatus: existingAttempt.status,\r\n                };\r\n            }\r\n\r\n            if (existingAttempt.status === CandidateTestAttemptStatus.IN_PROGRESS) {\r\n                return {\r\n                    eligible: true,\r\n                    reason: 'IN_PROGRESS',\r\n                    message: 'You have an ongoing test session.',\r\n                    attemptStatus: existingAttempt.status,\r\n                    testSessionId: existingAttempt.testSessionId,\r\n                };\r\n            }\r\n\r\n            // NOT_STARTED - check if expired\r\n            if (new Date() > existingAttempt.expiresAt) {\r\n                // Mark as expired\r\n                await this.prisma.candidateTestAttempt.update({\r\n                    where: { id: existingAttempt.id },\r\n                    data: { status: CandidateTestAttemptStatus.EXPIRED },\r\n                });\r\n\r\n                return {\r\n                    eligible: false,\r\n                    reason: 'TEST_EXPIRED',\r\n                    message: 'The test validity period has expired.',\r\n                    attemptStatus: CandidateTestAttemptStatus.EXPIRED,\r\n                };\r\n            }\r\n\r\n            // NOT_STARTED and still valid\r\n            return {\r\n                eligible: true,\r\n                reason: 'READY',\r\n                message: 'You can start the test.',\r\n                attemptStatus: existingAttempt.status,\r\n                expiresAt: existingAttempt.expiresAt,\r\n                test: {\r\n                    id: test.id,\r\n                    title: test.title,\r\n                    duration: test.duration,\r\n                    totalQuestions: test.totalQuestions,\r\n                    passingScore: test.passingScore,\r\n                },\r\n            };\r\n        }\r\n\r\n        // No attempt exists - eligible to start\r\n        return {\r\n            eligible: true,\r\n            reason: 'NO_ATTEMPT',\r\n            message: 'You can start the test.',\r\n            test: {\r\n                id: test.id,\r\n                title: test.title,\r\n                duration: test.duration,\r\n                totalQuestions: test.totalQuestions,\r\n                passingScore: test.passingScore,\r\n                validityDays: test.validityDays,\r\n            },\r\n        };\r\n    }\r\n\r\n    // ===========================================\r\n    // Candidate: Test Taking\r\n    // ===========================================\r\n\r\n    async startTest(applicationId: string, userId: string) {\r\n        // Verify application exists and is in correct state\r\n        const application = await this.prisma.jobApplication.findUnique({\r\n            where: { id: applicationId },\r\n            include: {\r\n                Candidate: { include: { User: true } },\r\n                Job: { include: { Test: { include: { TestQuestion: true } } } },\r\n                TestSession: true,\r\n            },\r\n        });\r\n\r\n        if (!application) {\r\n            throw new NotFoundException('Application not found');\r\n        }\r\n\r\n        if (application.Candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized to access this application');\r\n        }\r\n\r\n        if (application.status !== ApplicationStatus.TEST_REQUIRED &&\r\n            application.status !== ApplicationStatus.TEST_PENDING) {\r\n            throw new BadRequestException('Test not available for this application');\r\n        }\r\n\r\n        if (!application.Job.Test) {\r\n            throw new BadRequestException('No test configured for this job');\r\n        }\r\n\r\n        // Defense-in-depth: Check skill test cooldown if job has skill bucket\r\n        if (application.Job.skillBucketId) {\r\n            const skillStatus = await this.skillBucketService.checkCandidateSkillStatus(\r\n                application.Candidate.id,\r\n                application.Job.skillBucketId,\r\n            );\r\n\r\n            // Block if candidate is in retest cooldown (failed recently)\r\n            if (skillStatus.isFailed && !skillStatus.canRetest) {\r\n                throw new BadRequestException(\r\n                    `Retest not allowed yet. Please wait ${skillStatus.retestInHours} hours before retrying.`\r\n                );\r\n            }\r\n\r\n            // Also check if already passed and still valid (shouldn't need to retake)\r\n            if (skillStatus.isPassed && skillStatus.isValid) {\r\n                throw new BadRequestException(\r\n                    `You already have a valid skill pass for this role (valid for ${skillStatus.validDaysRemaining} more days). No need to retake the test.`\r\n                );\r\n            }\r\n        }\r\n\r\n        // Check if already has an active or completed session\r\n        const existingSession = application.TestSession.find(\r\n            (s) => s.status !== TestSessionStatus.EXPIRED,\r\n        );\r\n\r\n        if (existingSession) {\r\n            if (existingSession.status === TestSessionStatus.ACTIVE) {\r\n                // Return existing session (resume)\r\n                return this.getTestSession(existingSession.id, userId);\r\n            }\r\n            throw new BadRequestException('Test already attempted for this application');\r\n        }\r\n\r\n        const test = application.Job.Test;\r\n        const now = Date.now();\r\n        const endsAt = now + test.duration * 60 * 1000;\r\n\r\n        // Shuffle questions if enabled\r\n        let questionOrder = test.TestQuestion.map((_, i) => i);\r\n        if (test.shuffleQuestions) {\r\n            questionOrder = this.shuffleArray([...questionOrder]);\r\n        }\r\n\r\n        // Create test session in database\r\n        const session = await this.prisma.testSession.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                applicationId,\r\n                testId: test.id,\r\n                status: TestSessionStatus.ACTIVE,\r\n                startedAt: new Date(),\r\n                endsAt: new Date(endsAt),\r\n                totalTestQuestion: test.TestQuestion.length,\r\n                questionOrder,\r\n            },\r\n        });\r\n\r\n        // Store session in Redis with TTL\r\n        const sessionData: TestSessionData = {\r\n            sessionId: session.id,\r\n            applicationId,\r\n            testId: test.id,\r\n            userId,\r\n            startedAt: now,\r\n            endsAt,\r\n            questionOrder,\r\n            tabSwitchCount: 0,\r\n            maxTabSwitches: test.maxTabSwitches,\r\n        };\r\n\r\n        await this.redisSet(\r\n            REDIS_KEYS.TEST_SESSION(session.id),\r\n            JSON.stringify(sessionData),\r\n            endsAt - now + 60000, // Add 1 minute buffer\r\n        );\r\n\r\n        // Log audit\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId,\r\n                action: AuditAction.TEST_START,\r\n                entityType: 'TestSession',\r\n                entityId: session.id,\r\n                metadata: { applicationId, testId: test.id },\r\n            },\r\n        });\r\n\r\n        return this.getTestSession(session.id, userId);\r\n    }\r\n\r\n    async getTestSession(sessionId: string, userId: string) {\r\n        // Get from Redis/memory first\r\n        const redisData = await this.redisGet(REDIS_KEYS.TEST_SESSION(sessionId));\r\n\r\n        if (!redisData) {\r\n            // Session might have expired\r\n            throw new BadRequestException('Test session expired or not found');\r\n        }\r\n\r\n        const sessionData: TestSessionData = JSON.parse(redisData);\r\n\r\n        if (sessionData.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized to access this session');\r\n        }\r\n\r\n        // Check if time expired\r\n        if (Date.now() > sessionData.endsAt) {\r\n            await this.autoSubmitTest(sessionId);\r\n            throw new BadRequestException('Test time has expired');\r\n        }\r\n\r\n        // Get session with questions\r\n        const session = await this.prisma.testSession.findUnique({\r\n            where: { id: sessionId },\r\n            include: {\r\n                Test: {\r\n                    include: {\r\n                        TestQuestion: {\r\n                            orderBy: { orderIndex: 'asc' },\r\n                            select: {\r\n                                id: true,\r\n                                question: true,\r\n                                options: true,\r\n                                points: true,\r\n                                // Exclude correctAnswer\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n                answers: true,\r\n            },\r\n        });\r\n\r\n        if (!session) {\r\n            throw new NotFoundException('Session not found');\r\n        }\r\n\r\n        // Standard test - check that test relation exists\r\n        if (!session.test) {\r\n            throw new BadRequestException('This is a rapid-fire test session. Use the rapid-fire endpoints.');\r\n        }\r\n\r\n        // Reorder questions based on shuffled order\r\n        const orderedQuestions = sessionData.questionOrder.map(\r\n            (i) => session.test!.questions[i],\r\n        );\r\n\r\n        return {\r\n            sessionId: session.id,\r\n            testTitle: session.test!.title,\r\n            duration: session.test!.duration,\r\n            totalTestQuestion: session.totalQuestions,\r\n            remainingTime: Math.max(0, Math.floor((sessionData.endsAt - Date.now()) / 1000)),\r\n            TestQuestion: orderedQuestions,\r\n            answers: session.answers.map((a) => ({\r\n                questionId: a.questionId,\r\n                selectedAnswer: a.selectedAnswer,\r\n            })),\r\n            tabSwitchCount: sessionData.tabSwitchCount,\r\n            maxTabSwitches: sessionData.maxTabSwitches,\r\n        };\r\n    }\r\n\r\n    async submitAnswer(sessionId: string, userId: string, dto: SubmitAnswerDto) {\r\n        // Validate session from storage\r\n        const redisData = await this.redisGet(REDIS_KEYS.TEST_SESSION(sessionId));\r\n\r\n        if (!redisData) {\r\n            throw new BadRequestException('Test session expired or not found');\r\n        }\r\n\r\n        const sessionData: TestSessionData = JSON.parse(redisData);\r\n\r\n        if (sessionData.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (Date.now() > sessionData.endsAt) {\r\n            await this.autoSubmitTest(sessionId);\r\n            throw new BadRequestException('Test time has expired');\r\n        }\r\n\r\n        // Verify question belongs to this test\r\n        const question = await this.prisma.testQuestion.findFirst({\r\n            where: {\r\n                id: dto.questionId,\r\n                testId: sessionData.testId,\r\n            },\r\n        });\r\n\r\n        if (!question) {\r\n            throw new BadRequestException('Invalid question');\r\n        }\r\n\r\n        // Check if answer is valid\r\n        if (dto.selectedAnswer < 0 || dto.selectedAnswer >= (question.options as any[]).length) {\r\n            throw new BadRequestException('Invalid answer option');\r\n        }\r\n\r\n        // Save or update answer\r\n        const isCorrect = dto.selectedAnswer === question.correctAnswer;\r\n\r\n        await this.prisma.testAnswer.upsert({\r\n            where: {\r\n                sessionId_questionId: {\r\n                    sessionId,\r\n                    questionId: dto.questionId,\r\n                },\r\n            },\r\n            create: {\r\n                sessionId,\r\n                questionId: dto.questionId,\r\n                selectedAnswer: dto.selectedAnswer,\r\n                isCorrect,\r\n            },\r\n            update: {\r\n                selectedAnswer: dto.selectedAnswer,\r\n                isCorrect,\r\n                answeredAt: new Date(),\r\n            },\r\n        });\r\n\r\n        return { success: true, questionId: dto.questionId };\r\n    }\r\n\r\n    async submitTest(sessionId: string, userId: string) {\r\n        // Validate session\r\n        const session = await this.prisma.testSession.findUnique({\r\n            where: { id: sessionId },\r\n            include: {\r\n                JobApplication: { include: { Candidate: true } },\r\n                Test: true,\r\n                answers: true,\r\n            },\r\n        });\r\n\r\n        if (!session) {\r\n            throw new NotFoundException('Session not found');\r\n        }\r\n\r\n        // Check authorization (application may be null for rapid fire tests)\r\n        if (session.application && session.application.candidate.userId !== userId) {\r\n            throw new ForbiddenException('Not authorized');\r\n        }\r\n\r\n        if (session.status !== TestSessionStatus.ACTIVE) {\r\n            throw new BadRequestException('Test already submitted');\r\n        }\r\n\r\n        return this.processTestSubmission(session, false);\r\n    }\r\n\r\n    async logTestEvent(sessionId: string, userId: string, dto: TestEventDto) {\r\n        // Get session from storage\r\n        const redisData = await this.redisGet(REDIS_KEYS.TEST_SESSION(sessionId));\r\n\r\n        if (!redisData) {\r\n            return { success: false };\r\n        }\r\n\r\n        const sessionData: TestSessionData = JSON.parse(redisData);\r\n\r\n        if (sessionData.userId !== userId) {\r\n            return { success: false };\r\n        }\r\n\r\n        // Log event\r\n        await this.prisma.testEvent.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                sessionId,\r\n                eventType: dto.eventType,\r\n                eventData: dto.eventData,\r\n            },\r\n        });\r\n\r\n        // Handle tab switch\r\n        if (dto.eventType === 'TAB_SWITCH') {\r\n            sessionData.tabSwitchCount++;\r\n\r\n            // Update session storage\r\n            await this.redisSet(\r\n                REDIS_KEYS.TEST_SESSION(sessionId),\r\n                JSON.stringify(sessionData),\r\n            );\r\n\r\n            // Log audit\r\n            await this.prisma.auditLog.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    userId,\r\n                    action: AuditAction.TEST_TAB_SWITCH,\r\n                    entityType: 'TestSession',\r\n                    entityId: sessionId,\r\n                    metadata: { count: sessionData.tabSwitchCount },\r\n                },\r\n            });\r\n\r\n            // Check if exceeds max\r\n            if (sessionData.tabSwitchCount >= sessionData.maxTabSwitches) {\r\n                // Auto-submit test\r\n                await this.autoSubmitTest(sessionId);\r\n                return {\r\n                    success: true,\r\n                    autoSubmitted: true,\r\n                    message: 'Test auto-submitted due to too many tab switches',\r\n                };\r\n            }\r\n\r\n            return {\r\n                success: true,\r\n                warning: true,\r\n                remainingWarnings: sessionData.maxTabSwitches - sessionData.tabSwitchCount,\r\n            };\r\n        }\r\n\r\n        return { success: true };\r\n    }\r\n\r\n    // ===========================================\r\n    // INTERNAL HELPERS\r\n    // ===========================================\r\n\r\n    private async autoSubmitTest(sessionId: string) {\r\n        const session = await this.prisma.testSession.findUnique({\r\n            where: { id: sessionId },\r\n            include: {\r\n                JobApplication: { include: { Candidate: true } },\r\n                Test: true,\r\n                answers: true,\r\n            },\r\n        });\r\n\r\n        if (!session || session.status !== TestSessionStatus.ACTIVE) {\r\n            return;\r\n        }\r\n\r\n        return this.processTestSubmission(session, true);\r\n    }\r\n\r\n    private async processTestSubmission(session: any, isAutoSubmit: boolean) {\r\n        const correctAnswers = session.answers.filter((a: any) => a.isCorrect).length;\r\n        const score = (correctAnswers / session.totalQuestions) * 100;\r\n        const isPassed = score >= session.test.passingScore;\r\n\r\n        // Update session\r\n        await this.prisma.testSession.update({\r\n            where: { id: session.id },\r\n            data: {\r\n                status: isAutoSubmit\r\n                    ? TestSessionStatus.AUTO_SUBMITTED\r\n                    : TestSessionStatus.SUBMITTED,\r\n                submittedAt: new Date(),\r\n                score,\r\n                correctAnswers,\r\n                isPassed,\r\n            },\r\n        });\r\n\r\n        // Update application status - PASSED goes to WAITING for HR review\r\n        const newStatus = isPassed\r\n            ? ApplicationStatus.TEST_PASSED_WAITING_HR\r\n            : ApplicationStatus.REJECTED;\r\n\r\n        await this.prisma.jobApplication.update({\r\n            where: { id: session.applicationId },\r\n            data: {\r\n                status: newStatus,\r\n                testScore: score,\r\n                testPassedAt: isPassed ? new Date() : null,\r\n            },\r\n        });\r\n\r\n        // SKILL-BASED Test: Record skill test attempt if job has a skill bucket\r\n        try {\r\n            const application = await this.prisma.jobApplication.findUnique({\r\n                where: { id: session.applicationId },\r\n                include: {\r\n                    Candidate: true,\r\n                    Job: {\r\n                        include: {\r\n                            SkillBucket: true,\r\n                        },\r\n                    },\r\n                },\r\n            });\r\n\r\n            if (application?.Job?.skillBucketId) {\r\n                await this.skillBucketService.recordSkillTestAttempt(\r\n                    application.Candidate.id,\r\n                    application.Job.skillBucketId,\r\n                    isPassed,\r\n                    score,\r\n                    session.id,\r\n                );\r\n                this.logger.log(\r\n                    `Recorded skill test attempt for candidate ${application.Candidate.id} ` +\r\n                    `on skill bucket ${application.Job.skillBucketId}: passed=${isPassed}`\r\n                );\r\n            }\r\n        } catch (error) {\r\n            this.logger.error('Failed to record skill test attempt:', error);\r\n            // Don't fail the submission if skill tracking fails\r\n        }\r\n\r\n        // If passed, create referral entry\r\n        if (isPassed) {\r\n            await this.prisma.referral.create({\r\n                data: {\r\n                    id: crypto.randomUUID(),\r\n                    applicationId: session.applicationId,\r\n                    type: 'HR_DIRECT', // Default to HR, can be changed to employee\r\n                    status: ReferralStatus.PENDING,\r\n                    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\r\n                    updatedAt: new Date(),\r\n                },\r\n            });\r\n        }\r\n\r\n        // Clear session storage\r\n        await this.redisDel(REDIS_KEYS.TEST_SESSION(session.id));\r\n\r\n        // Log audit\r\n        await this.prisma.auditLog.create({\r\n            data: {\r\n                id: crypto.randomUUID(),\r\n                userId: session.application.candidate.userId,\r\n                action: AuditAction.TEST_SUBMIT,\r\n                entityType: 'TestSession',\r\n                entityId: session.id,\r\n                metadata: { score, isPassed, isAutoSubmit },\r\n            },\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sessionId: session.id,\r\n            score,\r\n            isPassed,\r\n            correctAnswers,\r\n            totalTestQuestion: session.totalQuestions,\r\n            isAutoSubmit,\r\n        };\r\n    }\r\n\r\n    private shuffleArray<T>(array: T[]): T[] {\r\n        for (let i = array.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            [array[i], array[j]] = [array[j], array[i]];\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\n"],"names":["TestService","initRedis","redisUrl","configService","get","redisHost","redis","Redis","host","port","password","on","err","logger","warn","message","log","redisSet","key","value","pxMs","set","sessionStore","data","expiry","Date","now","redisGet","stored","delete","redisDel","del","createTest","dto","prisma","test","create","id","crypto","randomUUID","title","description","duration","passingScore","totalTestQuestion","totalQuestions","shuffleTestQuestion","shuffleQuestions","maxTabSwitches","difficulty","updatedAt","addQuestion","testId","findUnique","where","include","TestQuestion","NotFoundException","testQuestion","question","options","correctAnswer","explanation","points","orderIndex","length","getTestById","orderBy","createRoleTest","existingTest","skillBucket","skillBucketId","Test","BadRequestException","validityDays","isActive","update","getAllRoleTests","skillBuckets","findMany","_count","select","TestSession","TestTemplate","selectionRoleType","roleTestsWithQuestionCount","Promise","all","map","bucket","roleType","code","availableQuestions","questionBank","count","skillBucketName","name","skillBucketCode","questionsCount","sessionsCount","createdAt","getTestBySkillBucket","updateTest","undefined","activateTest","SkillBucket","questionCount","deactivateTest","getTestEligibility","candidateId","jobId","job","eligible","reason","existingAttempt","candidateTestAttempt","candidateId_jobId","status","CandidateTestAttemptStatus","PASSED","attemptStatus","score","FAILED","EXPIRED","IN_PROGRESS","testSessionId","expiresAt","startTest","applicationId","userId","application","jobApplication","Candidate","User","Job","ForbiddenException","ApplicationStatus","TEST_REQUIRED","TEST_PENDING","skillStatus","skillBucketService","checkCandidateSkillStatus","isFailed","canRetest","retestInHours","isPassed","isValid","validDaysRemaining","existingSession","find","s","TestSessionStatus","ACTIVE","getTestSession","endsAt","questionOrder","_","i","shuffleArray","session","testSession","startedAt","sessionData","sessionId","tabSwitchCount","REDIS_KEYS","TEST_SESSION","JSON","stringify","auditLog","action","AuditAction","TEST_START","entityType","entityId","metadata","redisData","parse","autoSubmitTest","answers","orderedQuestions","questions","testTitle","remainingTime","Math","max","floor","a","questionId","selectedAnswer","submitAnswer","findFirst","isCorrect","testAnswer","upsert","sessionId_questionId","answeredAt","success","submitTest","JobApplication","candidate","processTestSubmission","logTestEvent","testEvent","eventType","eventData","TEST_TAB_SWITCH","autoSubmitted","warning","remainingWarnings","isAutoSubmit","correctAnswers","filter","AUTO_SUBMITTED","SUBMITTED","submittedAt","newStatus","TEST_PASSED_WAITING_HR","REJECTED","testScore","testPassedAt","recordSkillTestAttempt","error","referral","type","ReferralStatus","PENDING","TEST_SUBMIT","array","j","random","Logger","Map"],"mappings":"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"}