{"version":3,"sources":["../../../src/modules/test/test.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  NotFoundException,\r\n  BadRequestException,\r\n  ForbiddenException,\r\n  Logger,\r\n} from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport * as crypto from 'crypto';\r\nimport Redis from 'ioredis';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport {\r\n  CreateTestDto,\r\n  CreateRoleTestDto,\r\n  UpdateTestDto,\r\n  AddQuestionDto,\r\n  SubmitAnswerDto,\r\n  TestEventDto,\r\n} from './dto';\r\nimport {\r\n  TestSessionStatus,\r\n  ApplicationStatus,\r\n  CandidateTestAttemptStatus,\r\n  ReferralStatus,\r\n  AuditAction,\r\n  REDIS_KEYS,\r\n} from '../../common/constants';\r\nimport { SkillBucketService } from '../skill-bucket/skill-bucket.service';\r\n\r\ninterface TestSessionData {\r\n  sessionId: string;\r\n  applicationId: string;\r\n  testId: string;\r\n  userId: string;\r\n  startedAt: number;\r\n  endsAt: number;\r\n  questionOrder: number[];\r\n  tabSwitchCount: number;\r\n  maxTabSwitches: number;\r\n}\r\n\r\n@Injectable()\r\nexport class TestService {\r\n  private redis: Redis | null = null;\r\n  private readonly logger = new Logger(TestService.name);\r\n  // In-memory fallback for test sessions\r\n  private sessionStore: Map<string, { data: string; expiry: number }> =\r\n    new Map();\r\n\r\n  constructor(\r\n    private prisma: PrismaService,\r\n    private configService: ConfigService,\r\n    private skillBucketService: SkillBucketService,\r\n  ) {\r\n    this.initRedis();\r\n  }\r\n\r\n  private initRedis(): void {\r\n    const redisUrl = this.configService.get('REDIS_URL');\r\n    const redisHost = this.configService.get('REDIS_HOST');\r\n\r\n    if (redisUrl || redisHost) {\r\n      try {\r\n        if (redisUrl) {\r\n          this.redis = new Redis(redisUrl);\r\n        } else {\r\n          this.redis = new Redis({\r\n            host: redisHost || 'localhost',\r\n            port: this.configService.get('REDIS_PORT', 6379),\r\n            password: this.configService.get('REDIS_PASSWORD'),\r\n          });\r\n        }\r\n\r\n        this.redis.on('error', (err) => {\r\n          this.logger.warn(\r\n            `Redis error: ${err.message}. Using in-memory storage.`,\r\n          );\r\n          this.redis = null;\r\n        });\r\n      } catch {\r\n        this.logger.warn(\r\n          'Redis not available. Test sessions will use in-memory storage.',\r\n        );\r\n      }\r\n    } else {\r\n      this.logger.log(\r\n        'Redis not configured. Test sessions will use in-memory storage.',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Helper methods for Redis operations with fallback\r\n  private async redisSet(\r\n    key: string,\r\n    value: string,\r\n    pxMs?: number,\r\n  ): Promise<void> {\r\n    if (this.redis) {\r\n      try {\r\n        if (pxMs) {\r\n          await this.redis.set(key, value, 'PX', pxMs);\r\n        } else {\r\n          await this.redis.set(key, value);\r\n        }\r\n        return;\r\n      } catch {\r\n        // Fall through to in-memory\r\n      }\r\n    }\r\n    this.sessionStore.set(key, {\r\n      data: value,\r\n      expiry: pxMs ? Date.now() + pxMs : Date.now() + 3600000,\r\n    });\r\n  }\r\n\r\n  private async redisGet(key: string): Promise<string | null> {\r\n    if (this.redis) {\r\n      try {\r\n        return await this.redis.get(key);\r\n      } catch {\r\n        // Fall through\r\n      }\r\n    }\r\n    const stored = this.sessionStore.get(key);\r\n    if (!stored) return null;\r\n    if (Date.now() > stored.expiry) {\r\n      this.sessionStore.delete(key);\r\n      return null;\r\n    }\r\n    return stored.data;\r\n  }\r\n\r\n  private async redisDel(key: string): Promise<void> {\r\n    if (this.redis) {\r\n      try {\r\n        await this.redis.del(key);\r\n      } catch {\r\n        // Fall through\r\n      }\r\n    }\r\n    this.sessionStore.delete(key);\r\n  }\r\n\r\n  // ===========================================\r\n  // ADMIN: Test Management\r\n  // ===========================================\r\n\r\n  async createTest(dto: CreateTestDto) {\r\n    return this.prisma.test.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        title: dto.title,\r\n        description: dto.description,\r\n        duration: dto.duration || 30,\r\n        passingScore: dto.passingScore || 70,\r\n        totalQuestions: dto.totalQuestions || 20,\r\n        shuffleQuestions: dto.shuffleQuestions ?? true,\r\n        maxTabSwitches: dto.maxTabSwitches || 2,\r\n        difficulty: dto.difficulty || 'MEDIUM',\r\n        updatedAt: new Date(),\r\n      },\r\n    });\r\n  }\r\n\r\n  async addQuestion(testId: string, dto: AddQuestionDto) {\r\n    const test = await this.prisma.test.findUnique({\r\n      where: { id: testId },\r\n      include: { TestQuestion: true },\r\n    });\r\n\r\n    if (!test) {\r\n      throw new NotFoundException('Test not found');\r\n    }\r\n\r\n    return this.prisma.testQuestion.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        testId,\r\n        question: dto.question,\r\n        options: dto.options,\r\n        correctAnswer: dto.correctAnswer,\r\n        explanation: dto.explanation,\r\n        points: dto.points || 1,\r\n        orderIndex: test.TestQuestion.length,\r\n      },\r\n    });\r\n  }\r\n\r\n  async getTestById(testId: string) {\r\n    const test = await this.prisma.test.findUnique({\r\n      where: { id: testId },\r\n      include: {\r\n        TestQuestion: {\r\n          orderBy: { orderIndex: 'asc' },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!test) {\r\n      throw new NotFoundException('Test not found');\r\n    }\r\n\r\n    return test;\r\n  }\r\n\r\n  // ===========================================\r\n  // ADMIN: Role-Based Test Management\r\n  // ===========================================\r\n\r\n  async createRoleTest(dto: CreateRoleTestDto) {\r\n    // Check if test already exists for this skill bucket (role)\r\n    const existingBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: dto.skillBucketId },\r\n      include: { Test: true, TestTemplate: true },\r\n    });\r\n\r\n    if (!existingBucket) {\r\n      throw new NotFoundException('Skill bucket (role) not found');\r\n    }\r\n\r\n    if (existingBucket.testId || existingBucket.testTemplateId) {\r\n      throw new BadRequestException(\r\n        'Test already exists for this role. Each role can have only one test.',\r\n      );\r\n    }\r\n\r\n    // Create the Test (for backward compatibility)\r\n    const test = await this.prisma.test.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        title: dto.title,\r\n        description: dto.description,\r\n        duration: dto.duration || 30,\r\n        passingScore: dto.passingScore || 70,\r\n        totalQuestions: dto.totalQuestions || 20,\r\n        validityDays: dto.validityDays || 7,\r\n        isActive: dto.isActive || false,\r\n        updatedAt: new Date(),\r\n      },\r\n    });\r\n\r\n    // Also create TestTemplate (for rapid-fire tests)\r\n    const testTemplate = await this.prisma.testTemplate.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        name: dto.title,\r\n        description: dto.description,\r\n        duration: dto.duration || 20,\r\n        passingCriteria: dto.passingScore || 70,\r\n        testValidityDays: dto.validityDays || 7,\r\n        questionPoolSize: dto.totalQuestions || 20,\r\n        selectionRoleType: existingBucket.code, // Use skill bucket code to match questions\r\n        isActive: dto.isActive || true,\r\n        updatedAt: new Date(),\r\n      },\r\n    });\r\n\r\n    // Link both Test and TestTemplate to skill bucket\r\n    await this.prisma.skillBucket.update({\r\n      where: { id: dto.skillBucketId },\r\n      data: {\r\n        testId: test.id,\r\n        testTemplateId: testTemplate.id,\r\n      },\r\n    });\r\n\r\n    return { ...test, testTemplate };\r\n  }\r\n\r\n  async getAllRoleTests() {\r\n    const skillBuckets = await this.prisma.skillBucket.findMany({\r\n      include: {\r\n        Test: {\r\n          include: {\r\n            TestQuestion: true,\r\n            _count: {\r\n              select: { TestSession: true },\r\n            },\r\n          },\r\n        },\r\n        TestTemplate: {\r\n          select: {\r\n            selectionRoleType: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    // For each bucket, count available questions from QuestionBank\r\n    const roleTestsWithQuestionCount = await Promise.all(\r\n      skillBuckets.map(async (bucket) => {\r\n        // Use TestTemplate.selectionRoleType if set, otherwise use bucket.code\r\n        const roleType = bucket.TestTemplate?.selectionRoleType || bucket.code;\r\n        const availableQuestions = await this.prisma.questionBank.count({\r\n          where: {\r\n            roleType: roleType,\r\n            isActive: true,\r\n          },\r\n        });\r\n\r\n        return {\r\n          skillBucketId: bucket.id,\r\n          skillBucketName: bucket.name,\r\n          skillBucketCode: bucket.code,\r\n          test: bucket.Test\r\n            ? {\r\n              id: bucket.Test.id,\r\n              title: bucket.Test.title,\r\n              description: bucket.Test.description,\r\n              duration: bucket.Test.duration,\r\n              passingScore: bucket.Test.passingScore,\r\n              totalQuestions: bucket.Test.totalQuestions,\r\n              validityDays: bucket.Test.validityDays,\r\n              isActive: bucket.Test.isActive,\r\n              questionsCount: availableQuestions, // Now counts from QuestionBank\r\n              sessionsCount: bucket.Test._count.TestSession,\r\n              createdAt: bucket.Test.createdAt,\r\n            }\r\n            : null,\r\n        };\r\n      }),\r\n    );\r\n\r\n    return roleTestsWithQuestionCount;\r\n  }\r\n\r\n  async getTestBySkillBucket(skillBucketId: string) {\r\n    const skillBucket = await this.prisma.skillBucket.findUnique({\r\n      where: { id: skillBucketId },\r\n      include: {\r\n        Test: {\r\n          include: {\r\n            TestQuestion: {\r\n              orderBy: { orderIndex: 'asc' },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!skillBucket) {\r\n      throw new NotFoundException('Skill bucket not found');\r\n    }\r\n\r\n    if (!skillBucket.Test) {\r\n      throw new NotFoundException('No test found for this role');\r\n    }\r\n\r\n    return {\r\n      skillBucket: {\r\n        id: skillBucket.id,\r\n        name: skillBucket.name,\r\n        code: skillBucket.code,\r\n      },\r\n      test: skillBucket.Test,\r\n    };\r\n  }\r\n\r\n  async updateTest(testId: string, dto: UpdateTestDto) {\r\n    const test = await this.prisma.test.findUnique({\r\n      where: { id: testId },\r\n      include: { TestQuestion: true },\r\n    });\r\n\r\n    if (!test) {\r\n      throw new NotFoundException('Test not found');\r\n    }\r\n\r\n    // Validate activation - cannot activate without questions\r\n    if (dto.isActive === true && test.TestQuestion.length === 0) {\r\n      throw new BadRequestException(\r\n        'Cannot activate test without questions. Add at least one question first.',\r\n      );\r\n    }\r\n\r\n    return this.prisma.test.update({\r\n      where: { id: testId },\r\n      data: {\r\n        ...(dto.title && { title: dto.title }),\r\n        ...(dto.description !== undefined && { description: dto.description }),\r\n        ...(dto.duration && { duration: dto.duration }),\r\n        ...(dto.passingScore && { passingScore: dto.passingScore }),\r\n        ...(dto.totalQuestions && { totalQuestions: dto.totalQuestions }),\r\n        ...(dto.validityDays && { validityDays: dto.validityDays }),\r\n        ...(dto.isActive !== undefined && { isActive: dto.isActive }),\r\n        updatedAt: new Date(),\r\n      },\r\n    });\r\n  }\r\n\r\n  async activateTest(testId: string) {\r\n    const test = await this.prisma.test.findUnique({\r\n      where: { id: testId },\r\n      include: {\r\n        SkillBucket: true,\r\n      },\r\n    });\r\n\r\n    if (!test) {\r\n      throw new NotFoundException('Test not found');\r\n    }\r\n\r\n    // Check if there are questions in QuestionBank matching the skill bucket code\r\n    const skillBucketCode = test.SkillBucket?.code;\r\n    const questionCount = await this.prisma.questionBank.count({\r\n      where: {\r\n        roleType: skillBucketCode || '',\r\n        isActive: true,\r\n      },\r\n    });\r\n\r\n    if (questionCount === 0) {\r\n      throw new BadRequestException(\r\n        `Cannot activate test without questions. No questions found in Question Bank for role type \"${skillBucketCode}\". Add questions first using CSV upload.`,\r\n      );\r\n    }\r\n\r\n    return this.prisma.test.update({\r\n      where: { id: testId },\r\n      data: { isActive: true, updatedAt: new Date() },\r\n    });\r\n  }\r\n\r\n  async deactivateTest(testId: string) {\r\n    const test = await this.prisma.test.findUnique({\r\n      where: { id: testId },\r\n    });\r\n\r\n    if (!test) {\r\n      throw new NotFoundException('Test not found');\r\n    }\r\n\r\n    return this.prisma.test.update({\r\n      where: { id: testId },\r\n      data: { isActive: false, updatedAt: new Date() },\r\n    });\r\n  }\r\n\r\n  // ===========================================\r\n  // Candidate: Test Eligibility & Taking\r\n  // ===========================================\r\n\r\n  async getTestEligibility(candidateId: string, jobId: string) {\r\n    // Get job with skill bucket and test info\r\n    const job = await this.prisma.job.findUnique({\r\n      where: { id: jobId },\r\n      include: {\r\n        SkillBucket: {\r\n          include: { Test: true },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!job) {\r\n      throw new NotFoundException('Job not found');\r\n    }\r\n\r\n    if (!job.SkillBucket || !job.SkillBucket.Test) {\r\n      return {\r\n        eligible: false,\r\n        reason: 'NO_TEST_CONFIGURED',\r\n        message: 'No test is configured for this job role.',\r\n      };\r\n    }\r\n\r\n    const test = job.SkillBucket.Test;\r\n\r\n    if (!test.isActive) {\r\n      return {\r\n        eligible: false,\r\n        reason: 'TEST_INACTIVE',\r\n        message: 'Test is currently not available for this role.',\r\n      };\r\n    }\r\n\r\n    // Check for existing attempt\r\n    const existingAttempt = await this.prisma.candidateTestAttempt.findUnique({\r\n      where: {\r\n        candidateId_jobId: {\r\n          candidateId,\r\n          jobId,\r\n        },\r\n      },\r\n    });\r\n\r\n    if (existingAttempt) {\r\n      if (existingAttempt.status === CandidateTestAttemptStatus.PASSED) {\r\n        return {\r\n          eligible: false,\r\n          reason: 'ALREADY_PASSED',\r\n          message: 'You have already passed the test for this job.',\r\n          attemptStatus: existingAttempt.status,\r\n          score: existingAttempt.score,\r\n        };\r\n      }\r\n\r\n      if (existingAttempt.status === CandidateTestAttemptStatus.FAILED) {\r\n        return {\r\n          eligible: false,\r\n          reason: 'ALREADY_FAILED',\r\n          message:\r\n            'You have already failed the test for this job. Re-attempts are not allowed.',\r\n          attemptStatus: existingAttempt.status,\r\n          score: existingAttempt.score,\r\n        };\r\n      }\r\n\r\n      if (existingAttempt.status === CandidateTestAttemptStatus.EXPIRED) {\r\n        return {\r\n          eligible: false,\r\n          reason: 'TEST_EXPIRED',\r\n          message: 'The test validity period has expired.',\r\n          attemptStatus: existingAttempt.status,\r\n        };\r\n      }\r\n\r\n      if (existingAttempt.status === CandidateTestAttemptStatus.IN_PROGRESS) {\r\n        return {\r\n          eligible: true,\r\n          reason: 'IN_PROGRESS',\r\n          message: 'You have an ongoing test session.',\r\n          attemptStatus: existingAttempt.status,\r\n          testSessionId: existingAttempt.testSessionId,\r\n        };\r\n      }\r\n\r\n      // NOT_STARTED - check if expired\r\n      if (new Date() > existingAttempt.expiresAt) {\r\n        // Mark as expired\r\n        await this.prisma.candidateTestAttempt.update({\r\n          where: { id: existingAttempt.id },\r\n          data: { status: CandidateTestAttemptStatus.EXPIRED },\r\n        });\r\n\r\n        return {\r\n          eligible: false,\r\n          reason: 'TEST_EXPIRED',\r\n          message: 'The test validity period has expired.',\r\n          attemptStatus: CandidateTestAttemptStatus.EXPIRED,\r\n        };\r\n      }\r\n\r\n      // NOT_STARTED and still valid\r\n      return {\r\n        eligible: true,\r\n        reason: 'READY',\r\n        message: 'You can start the test.',\r\n        attemptStatus: existingAttempt.status,\r\n        expiresAt: existingAttempt.expiresAt,\r\n        test: {\r\n          id: test.id,\r\n          title: test.title,\r\n          duration: test.duration,\r\n          totalQuestions: test.totalQuestions,\r\n          passingScore: test.passingScore,\r\n        },\r\n      };\r\n    }\r\n\r\n    // No attempt exists - eligible to start\r\n    return {\r\n      eligible: true,\r\n      reason: 'NO_ATTEMPT',\r\n      message: 'You can start the test.',\r\n      test: {\r\n        id: test.id,\r\n        title: test.title,\r\n        duration: test.duration,\r\n        totalQuestions: test.totalQuestions,\r\n        passingScore: test.passingScore,\r\n        validityDays: test.validityDays,\r\n      },\r\n    };\r\n  }\r\n\r\n  // ===========================================\r\n  // Candidate: Test Taking\r\n  // ===========================================\r\n\r\n  async startTest(applicationId: string, userId: string) {\r\n    // Verify application exists and is in correct state\r\n    const application = await this.prisma.jobApplication.findUnique({\r\n      where: { id: applicationId },\r\n      include: {\r\n        Candidate: { include: { User: true } },\r\n        Job: { include: { Test: { include: { TestQuestion: true } } } },\r\n        TestSession: true,\r\n      },\r\n    });\r\n\r\n    if (!application) {\r\n      throw new NotFoundException('Application not found');\r\n    }\r\n\r\n    if (application.Candidate.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized to access this application');\r\n    }\r\n\r\n    if (\r\n      application.status !== ApplicationStatus.TEST_REQUIRED &&\r\n      application.status !== ApplicationStatus.TEST_PENDING &&\r\n      application.status !== ApplicationStatus.APPLIED\r\n    ) {\r\n      throw new BadRequestException('Test not available for this application');\r\n    }\r\n\r\n    if (!application.Job.Test) {\r\n      throw new BadRequestException('No test configured for this job');\r\n    }\r\n\r\n    // Defense-in-depth: Check skill test cooldown if job has skill bucket\r\n    if (application.Job.skillBucketId) {\r\n      const skillStatus =\r\n        await this.skillBucketService.checkCandidateSkillStatus(\r\n          application.Candidate.id,\r\n          application.Job.skillBucketId,\r\n        );\r\n\r\n      // Block if candidate is in retest cooldown (failed recently)\r\n      if (skillStatus.isFailed && !skillStatus.canRetest) {\r\n        throw new BadRequestException(\r\n          `Retest not allowed yet. Please wait ${skillStatus.retestInHours} hours before retrying.`,\r\n        );\r\n      }\r\n\r\n      // Also check if already passed and still valid (shouldn't need to retake)\r\n      if (skillStatus.isPassed && skillStatus.isValid) {\r\n        throw new BadRequestException(\r\n          `You already have a valid skill pass for this role (valid for ${skillStatus.validDaysRemaining} more days). No need to retake the test.`,\r\n        );\r\n      }\r\n    }\r\n\r\n    // Check if already has an active or completed session\r\n    const existingSession = application.TestSession.find(\r\n      (s) => s.status !== TestSessionStatus.EXPIRED,\r\n    );\r\n\r\n    if (existingSession) {\r\n      if (existingSession.status === TestSessionStatus.ACTIVE) {\r\n        // Return existing session (resume)\r\n        return this.getTestSession(existingSession.id, userId);\r\n      }\r\n      throw new BadRequestException(\r\n        'Test already attempted for this application',\r\n      );\r\n    }\r\n\r\n    const test = application.Job.Test;\r\n    const now = Date.now();\r\n    const endsAt = now + test.duration * 60 * 1000;\r\n\r\n    // Shuffle questions if enabled\r\n    let questionOrder = test.TestQuestion.map((_, i) => i);\r\n    if (test.shuffleQuestions) {\r\n      questionOrder = this.shuffleArray([...questionOrder]);\r\n    }\r\n\r\n    // Create test session in database\r\n    const session = await this.prisma.testSession.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        applicationId,\r\n        testId: test.id,\r\n        status: TestSessionStatus.ACTIVE,\r\n        startedAt: new Date(),\r\n        endsAt: new Date(endsAt),\r\n        totalQuestions: test.TestQuestion.length,\r\n        questionOrder,\r\n      },\r\n    });\r\n\r\n    // Store session in Redis with TTL\r\n    const sessionData: TestSessionData = {\r\n      sessionId: session.id,\r\n      applicationId,\r\n      testId: test.id,\r\n      userId,\r\n      startedAt: now,\r\n      endsAt,\r\n      questionOrder,\r\n      tabSwitchCount: 0,\r\n      maxTabSwitches: test.maxTabSwitches,\r\n    };\r\n\r\n    await this.redisSet(\r\n      REDIS_KEYS.TEST_SESSION(session.id),\r\n      JSON.stringify(sessionData),\r\n      endsAt - now + 60000, // Add 1 minute buffer\r\n    );\r\n\r\n    // Log audit\r\n    await this.prisma.auditLog.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        userId,\r\n        action: AuditAction.TEST_START,\r\n        entityType: 'TestSession',\r\n        entityId: session.id,\r\n        metadata: { applicationId, testId: test.id },\r\n      },\r\n    });\r\n\r\n    return this.getTestSession(session.id, userId);\r\n  }\r\n\r\n  async getTestSession(sessionId: string, userId: string) {\r\n    // Get from Redis/memory first\r\n    const redisData = await this.redisGet(REDIS_KEYS.TEST_SESSION(sessionId));\r\n\r\n    if (!redisData) {\r\n      // Session might have expired\r\n      throw new BadRequestException('Test session expired or not found');\r\n    }\r\n\r\n    const sessionData: TestSessionData = JSON.parse(redisData);\r\n\r\n    if (sessionData.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized to access this session');\r\n    }\r\n\r\n    // Check if time expired\r\n    if (Date.now() > sessionData.endsAt) {\r\n      await this.autoSubmitTest(sessionId);\r\n      throw new BadRequestException('Test time has expired');\r\n    }\r\n\r\n    // Get session with questions\r\n    const session = await this.prisma.testSession.findUnique({\r\n      where: { id: sessionId },\r\n      include: {\r\n        Test: {\r\n          include: {\r\n            TestQuestion: {\r\n              orderBy: { orderIndex: 'asc' },\r\n              select: {\r\n                id: true,\r\n                question: true,\r\n                options: true,\r\n                points: true,\r\n                // Exclude correctAnswer\r\n              },\r\n            },\r\n          },\r\n        },\r\n        TestAnswer: true,\r\n      },\r\n    });\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Session not found');\r\n    }\r\n\r\n    // Standard test - check that test relation exists\r\n    if (!session.Test) {\r\n      throw new BadRequestException(\r\n        'This is a rapid-fire test session. Use the rapid-fire endpoints.',\r\n      );\r\n    }\r\n\r\n    // Reorder questions based on shuffled order\r\n    const orderedQuestions = sessionData.questionOrder.map(\r\n      (i) => session.Test!.TestQuestion[i],\r\n    );\r\n\r\n    return {\r\n      sessionId: session.id,\r\n      testTitle: session.Test!.title,\r\n      duration: session.Test!.duration,\r\n      totalQuestions: session.totalQuestions,\r\n      remainingTime: Math.max(\r\n        0,\r\n        Math.floor((sessionData.endsAt - Date.now()) / 1000),\r\n      ),\r\n      TestQuestion: orderedQuestions,\r\n      answers: session.TestAnswer.map((a) => ({\r\n        questionId: a.questionId,\r\n        selectedAnswer: a.selectedAnswer,\r\n      })),\r\n      tabSwitchCount: sessionData.tabSwitchCount,\r\n      maxTabSwitches: sessionData.maxTabSwitches,\r\n    };\r\n  }\r\n\r\n  async submitAnswer(sessionId: string, userId: string, dto: SubmitAnswerDto) {\r\n    // Validate session from storage\r\n    const redisData = await this.redisGet(REDIS_KEYS.TEST_SESSION(sessionId));\r\n\r\n    if (!redisData) {\r\n      throw new BadRequestException('Test session expired or not found');\r\n    }\r\n\r\n    const sessionData: TestSessionData = JSON.parse(redisData);\r\n\r\n    if (sessionData.userId !== userId) {\r\n      throw new ForbiddenException('Not authorized');\r\n    }\r\n\r\n    if (Date.now() > sessionData.endsAt) {\r\n      await this.autoSubmitTest(sessionId);\r\n      throw new BadRequestException('Test time has expired');\r\n    }\r\n\r\n    // Verify question belongs to this test\r\n    const question = await this.prisma.testQuestion.findFirst({\r\n      where: {\r\n        id: dto.questionId,\r\n        testId: sessionData.testId,\r\n      },\r\n    });\r\n\r\n    if (!question) {\r\n      throw new BadRequestException('Invalid question');\r\n    }\r\n\r\n    // Check if answer is valid\r\n    if (\r\n      dto.selectedAnswer < 0 ||\r\n      dto.selectedAnswer >= (question.options as any[]).length\r\n    ) {\r\n      throw new BadRequestException('Invalid answer option');\r\n    }\r\n\r\n    // Save or update answer\r\n    const isCorrect = dto.selectedAnswer === question.correctAnswer;\r\n\r\n    await this.prisma.testAnswer.upsert({\r\n      where: {\r\n        sessionId_questionId: {\r\n          sessionId,\r\n          questionId: dto.questionId,\r\n        },\r\n      },\r\n      create: {\r\n        sessionId,\r\n        questionId: dto.questionId,\r\n        selectedAnswer: dto.selectedAnswer,\r\n        isCorrect,\r\n      },\r\n      update: {\r\n        selectedAnswer: dto.selectedAnswer,\r\n        isCorrect,\r\n        answeredAt: new Date(),\r\n      },\r\n    });\r\n\r\n    return { success: true, questionId: dto.questionId };\r\n  }\r\n\r\n  async submitTest(sessionId: string, userId: string) {\r\n    // Validate session\r\n    const session = await this.prisma.testSession.findUnique({\r\n      where: { id: sessionId },\r\n      include: {\r\n        JobApplication: { include: { Candidate: true } },\r\n        Test: true,\r\n        TestAnswer: true,\r\n      },\r\n    });\r\n\r\n    if (!session) {\r\n      throw new NotFoundException('Session not found');\r\n    }\r\n\r\n    // Check authorization (application may be null for rapid fire tests)\r\n    if (\r\n      session.JobApplication &&\r\n      session.JobApplication.Candidate.userId !== userId\r\n    ) {\r\n      throw new ForbiddenException('Not authorized');\r\n    }\r\n\r\n    if (session.status !== TestSessionStatus.ACTIVE) {\r\n      throw new BadRequestException('Test already submitted');\r\n    }\r\n\r\n    return this.processTestSubmission(session, false);\r\n  }\r\n\r\n  async logTestEvent(sessionId: string, userId: string, dto: TestEventDto) {\r\n    // Get session from storage\r\n    const redisData = await this.redisGet(REDIS_KEYS.TEST_SESSION(sessionId));\r\n\r\n    if (!redisData) {\r\n      return { success: false };\r\n    }\r\n\r\n    const sessionData: TestSessionData = JSON.parse(redisData);\r\n\r\n    if (sessionData.userId !== userId) {\r\n      return { success: false };\r\n    }\r\n\r\n    // Log event\r\n    await this.prisma.testEvent.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        sessionId,\r\n        eventType: dto.eventType,\r\n        eventData: dto.eventData,\r\n      },\r\n    });\r\n\r\n    // Handle tab switch\r\n    if (dto.eventType === 'TAB_SWITCH') {\r\n      sessionData.tabSwitchCount++;\r\n\r\n      // Update session storage\r\n      await this.redisSet(\r\n        REDIS_KEYS.TEST_SESSION(sessionId),\r\n        JSON.stringify(sessionData),\r\n      );\r\n\r\n      // Log audit\r\n      await this.prisma.auditLog.create({\r\n        data: {\r\n          id: crypto.randomUUID(),\r\n          userId,\r\n          action: AuditAction.TEST_TAB_SWITCH,\r\n          entityType: 'TestSession',\r\n          entityId: sessionId,\r\n          metadata: { count: sessionData.tabSwitchCount },\r\n        },\r\n      });\r\n\r\n      // Check if exceeds max\r\n      if (sessionData.tabSwitchCount >= sessionData.maxTabSwitches) {\r\n        // Auto-submit test\r\n        await this.autoSubmitTest(sessionId);\r\n        return {\r\n          success: true,\r\n          autoSubmitted: true,\r\n          message: 'Test auto-submitted due to too many tab switches',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        warning: true,\r\n        remainingWarnings:\r\n          sessionData.maxTabSwitches - sessionData.tabSwitchCount,\r\n      };\r\n    }\r\n\r\n    return { success: true };\r\n  }\r\n\r\n  // ===========================================\r\n  // INTERNAL HELPERS\r\n  // ===========================================\r\n\r\n  private async autoSubmitTest(sessionId: string) {\r\n    const session = await this.prisma.testSession.findUnique({\r\n      where: { id: sessionId },\r\n      include: {\r\n        JobApplication: { include: { Candidate: true } },\r\n        Test: true,\r\n        TestAnswer: true,\r\n      },\r\n    });\r\n\r\n    if (!session || session.status !== TestSessionStatus.ACTIVE) {\r\n      return;\r\n    }\r\n\r\n    return this.processTestSubmission(session, true);\r\n  }\r\n\r\n  private async processTestSubmission(session: any, isAutoSubmit: boolean) {\r\n    const correctAnswers = session.TestAnswer.filter(\r\n      (a: any) => a.isCorrect,\r\n    ).length;\r\n    const score = (correctAnswers / session.totalQuestions) * 100;\r\n    const isPassed = score >= session.Test.passingScore;\r\n\r\n    // Update session\r\n    await this.prisma.testSession.update({\r\n      where: { id: session.id },\r\n      data: {\r\n        status: isAutoSubmit\r\n          ? TestSessionStatus.AUTO_SUBMITTED\r\n          : TestSessionStatus.SUBMITTED,\r\n        submittedAt: new Date(),\r\n        score,\r\n        correctAnswers,\r\n        isPassed,\r\n      },\r\n    });\r\n\r\n    // Update application status - PASSED goes to WAITING for HR review\r\n    const newStatus = isPassed\r\n      ? ApplicationStatus.TEST_PASSED_WAITING_HR\r\n      : ApplicationStatus.REJECTED;\r\n\r\n    await this.prisma.jobApplication.update({\r\n      where: { id: session.applicationId },\r\n      data: {\r\n        status: newStatus,\r\n        testScore: score,\r\n        testPassedAt: isPassed ? new Date() : null,\r\n      },\r\n    });\r\n\r\n    // SKILL-BASED Test: Record skill test attempt if job has a skill bucket\r\n    try {\r\n      const application = await this.prisma.jobApplication.findUnique({\r\n        where: { id: session.applicationId },\r\n        include: {\r\n          Candidate: true,\r\n          Job: {\r\n            include: {\r\n              SkillBucket: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (application?.Job?.skillBucketId) {\r\n        await this.skillBucketService.recordSkillTestAttempt(\r\n          application.Candidate.id,\r\n          application.Job.skillBucketId,\r\n          isPassed,\r\n          score,\r\n          session.id,\r\n        );\r\n        this.logger.log(\r\n          `Recorded skill test attempt for candidate ${application.Candidate.id} ` +\r\n          `on skill bucket ${application.Job.skillBucketId}: passed=${isPassed}`,\r\n        );\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to record skill test attempt:', error);\r\n      // Don't fail the submission if skill tracking fails\r\n    }\r\n\r\n    // If passed, create referral entry\r\n    if (isPassed) {\r\n      await this.prisma.referral.create({\r\n        data: {\r\n          id: crypto.randomUUID(),\r\n          applicationId: session.applicationId,\r\n          type: 'HR_DIRECT', // Default to HR, can be changed to employee\r\n          status: ReferralStatus.PENDING,\r\n          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\r\n          updatedAt: new Date(),\r\n        },\r\n      });\r\n    }\r\n\r\n    // Clear session storage\r\n    await this.redisDel(REDIS_KEYS.TEST_SESSION(session.id));\r\n\r\n    // Log audit\r\n    await this.prisma.auditLog.create({\r\n      data: {\r\n        id: crypto.randomUUID(),\r\n        userId: session.application.candidate.userId,\r\n        action: AuditAction.TEST_SUBMIT,\r\n        entityType: 'TestSession',\r\n        entityId: session.id,\r\n        metadata: { score, isPassed, isAutoSubmit },\r\n      },\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      sessionId: session.id,\r\n      score,\r\n      isPassed,\r\n      correctAnswers,\r\n      totalTestQuestion: session.totalQuestions,\r\n      isAutoSubmit,\r\n    };\r\n  }\r\n\r\n  private shuffleArray<T>(array: T[]): T[] {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n  }\r\n}\r\n"],"names":["TestService","initRedis","redisUrl","configService","get","redisHost","redis","Redis","host","port","password","on","err","logger","warn","message","log","redisSet","key","value","pxMs","set","sessionStore","data","expiry","Date","now","redisGet","stored","delete","redisDel","del","createTest","dto","prisma","test","create","id","crypto","randomUUID","title","description","duration","passingScore","totalQuestions","shuffleQuestions","maxTabSwitches","difficulty","updatedAt","addQuestion","testId","findUnique","where","include","TestQuestion","NotFoundException","testQuestion","question","options","correctAnswer","explanation","points","orderIndex","length","getTestById","orderBy","createRoleTest","existingBucket","skillBucket","skillBucketId","Test","TestTemplate","testTemplateId","BadRequestException","validityDays","isActive","testTemplate","name","passingCriteria","testValidityDays","questionPoolSize","selectionRoleType","code","update","getAllRoleTests","skillBuckets","findMany","_count","select","TestSession","roleTestsWithQuestionCount","Promise","all","map","bucket","roleType","availableQuestions","questionBank","count","skillBucketName","skillBucketCode","questionsCount","sessionsCount","createdAt","getTestBySkillBucket","updateTest","undefined","activateTest","SkillBucket","questionCount","deactivateTest","getTestEligibility","candidateId","jobId","job","eligible","reason","existingAttempt","candidateTestAttempt","candidateId_jobId","status","CandidateTestAttemptStatus","PASSED","attemptStatus","score","FAILED","EXPIRED","IN_PROGRESS","testSessionId","expiresAt","startTest","applicationId","userId","application","jobApplication","Candidate","User","Job","ForbiddenException","ApplicationStatus","TEST_REQUIRED","TEST_PENDING","APPLIED","skillStatus","skillBucketService","checkCandidateSkillStatus","isFailed","canRetest","retestInHours","isPassed","isValid","validDaysRemaining","existingSession","find","s","TestSessionStatus","ACTIVE","getTestSession","endsAt","questionOrder","_","i","shuffleArray","session","testSession","startedAt","sessionData","sessionId","tabSwitchCount","REDIS_KEYS","TEST_SESSION","JSON","stringify","auditLog","action","AuditAction","TEST_START","entityType","entityId","metadata","redisData","parse","autoSubmitTest","TestAnswer","orderedQuestions","testTitle","remainingTime","Math","max","floor","answers","a","questionId","selectedAnswer","submitAnswer","findFirst","isCorrect","testAnswer","upsert","sessionId_questionId","answeredAt","success","submitTest","JobApplication","processTestSubmission","logTestEvent","testEvent","eventType","eventData","TEST_TAB_SWITCH","autoSubmitted","warning","remainingWarnings","isAutoSubmit","correctAnswers","filter","AUTO_SUBMITTED","SUBMITTED","submittedAt","newStatus","TEST_PASSED_WAITING_HR","REJECTED","testScore","testPassedAt","recordSkillTestAttempt","error","referral","type","ReferralStatus","PENDING","candidate","TEST_SUBMIT","totalTestQuestion","array","j","random","Logger","Map"],"mappings":"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"}