{"version":3,"sources":["../../src/prisma/prisma.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  OnModuleInit,\r\n  OnModuleDestroy,\r\n  Logger,\r\n} from '@nestjs/common';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\n@Injectable()\r\nexport class PrismaService\r\n  extends PrismaClient\r\n  implements OnModuleInit, OnModuleDestroy {\r\n  private readonly logger = new Logger(PrismaService.name);\r\n\r\n  constructor() {\r\n    super({\r\n      log:\r\n        process.env.NODE_ENV === 'development'\r\n          ? ['query', 'info', 'warn', 'error']\r\n          : ['error'],\r\n    });\r\n\r\n    this.logger.log('PrismaService initialized');\r\n\r\n    // Add middleware to handle connection errors and auto-reconnect\r\n    this.$use(async (params, next) => {\r\n      const maxRetries = 3;\r\n      let lastError: Error | undefined;\r\n\r\n      for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n        try {\r\n          return await next(params);\r\n        } catch (error: any) {\r\n          lastError = error;\r\n\r\n          // Check if it's a connection error\r\n          const isConnectionError =\r\n            error.message?.includes('Connection') ||\r\n            error.message?.includes('Closed') ||\r\n            error.message?.includes('ECONNREFUSED') ||\r\n            error.message?.includes('ETIMEDOUT') ||\r\n            error.code === 'P1001' ||\r\n            error.code === 'P1002' ||\r\n            error.code === 'P1017';\r\n\r\n          if (isConnectionError && attempt < maxRetries) {\r\n            this.logger.warn(\r\n              `Connection error on ${params.model}.${params.action} (attempt ${attempt}/${maxRetries}): ${error.message}`,\r\n            );\r\n\r\n            // Reconnect\r\n            try {\r\n              await this.$disconnect();\r\n              await new Promise((resolve) => setTimeout(resolve, 500 * attempt));\r\n              await this.$connect();\r\n              this.logger.log('Reconnected to database');\r\n            } catch (reconnectError) {\r\n              this.logger.error('Failed to reconnect:', reconnectError);\r\n            }\r\n          } else {\r\n            throw error;\r\n          }\r\n        }\r\n      }\r\n\r\n      throw lastError;\r\n    });\r\n  }\r\n\r\n  async onModuleInit() {\r\n    await this.connectWithRetry();\r\n  }\r\n\r\n  private async connectWithRetry(maxRetries = 5): Promise<void> {\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        this.logger.log(\r\n          `Connecting to database (attempt ${attempt}/${maxRetries})...`,\r\n        );\r\n        await this.$connect();\r\n\r\n        // Warm up the connection with a simple query\r\n        await this.$queryRaw`SELECT 1`;\r\n\r\n        this.logger.log('Successfully connected to database');\r\n        return;\r\n      } catch (error) {\r\n        this.logger.warn(\r\n          `Connection attempt ${attempt} failed: ${(error as Error).message}`,\r\n        );\r\n\r\n        if (attempt === maxRetries) {\r\n          this.logger.error(\r\n            'Failed to connect to database after all retries:',\r\n            error,\r\n          );\r\n          throw error;\r\n        }\r\n\r\n        // Exponential backoff: 1s, 2s, 4s, 8s, 16s\r\n        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 16000);\r\n        this.logger.log(`Retrying in ${delay / 1000}s...`);\r\n        await new Promise((resolve) => setTimeout(resolve, delay));\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reconnect if connection is lost (handles Neon cold starts)\r\n  async ensureConnection(): Promise<void> {\r\n    try {\r\n      await this.$queryRaw`SELECT 1`;\r\n    } catch {\r\n      this.logger.warn('Connection lost, reconnecting...');\r\n      await this.connectWithRetry(3);\r\n    }\r\n  }\r\n\r\n  async onModuleDestroy() {\r\n    await this.$disconnect();\r\n  }\r\n\r\n  // Helper for transactions with retry\r\n  async executeInTransaction<T>(\r\n    fn: (\r\n      prisma: Omit<\r\n        PrismaClient,\r\n        | '$connect'\r\n        | '$disconnect'\r\n        | '$on'\r\n        | '$transaction'\r\n        | '$use'\r\n        | '$extends'\r\n      >,\r\n    ) => Promise<T>,\r\n    maxRetries = 3,\r\n  ): Promise<T> {\r\n    let lastError: Error | undefined;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        return await this.$transaction(fn, {\r\n          maxWait: 30000,\r\n          timeout: 30000,\r\n        });\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        this.logger.warn(\r\n          `Transaction attempt ${attempt} failed: ${(error as Error).message}`,\r\n        );\r\n\r\n        if (attempt < maxRetries) {\r\n          await new Promise((resolve) => setTimeout(resolve, 1000 * attempt));\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError;\r\n  }\r\n}\r\n"],"names":["PrismaService","PrismaClient","onModuleInit","connectWithRetry","maxRetries","attempt","logger","log","$connect","$queryRaw","error","warn","message","delay","Math","min","pow","Promise","resolve","setTimeout","ensureConnection","onModuleDestroy","$disconnect","executeInTransaction","fn","lastError","$transaction","maxWait","timeout","process","env","NODE_ENV","Logger","name","$use","params","next","isConnectionError","includes","code","model","action","reconnectError"],"mappings":"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"}