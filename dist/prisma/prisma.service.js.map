{"version":3,"sources":["../../src/prisma/prisma.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  OnModuleInit,\r\n  OnModuleDestroy,\r\n  Logger,\r\n} from '@nestjs/common';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\n@Injectable()\r\nexport class PrismaService\r\n  extends PrismaClient\r\n  implements OnModuleInit, OnModuleDestroy {\r\n  private readonly logger = new Logger(PrismaService.name);\r\n  private keepAliveInterval: NodeJS.Timeout | null = null;\r\n\r\n  constructor() {\r\n    super({\r\n      log:\r\n        process.env.NODE_ENV === 'development'\r\n          ? ['query', 'info', 'warn', 'error']\r\n          : ['error'],\r\n    });\r\n\r\n    this.logger.log('PrismaService initialized');\r\n\r\n    // Add middleware to handle connection errors and auto-reconnect\r\n    this.$use(async (params, next) => {\r\n      const maxRetries = 3;\r\n      let lastError: Error | undefined;\r\n\r\n      for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n        try {\r\n          return await next(params);\r\n        } catch (error: any) {\r\n          lastError = error;\r\n\r\n          // Check if it's a connection error\r\n          const isConnectionError =\r\n            error.message?.includes('Connection') ||\r\n            error.message?.includes('Closed') ||\r\n            error.message?.includes('ECONNREFUSED') ||\r\n            error.message?.includes('ETIMEDOUT') ||\r\n            error.code === 'P1001' ||\r\n            error.code === 'P1002' ||\r\n            error.code === 'P1017';\r\n\r\n          if (isConnectionError && attempt < maxRetries) {\r\n            this.logger.warn(\r\n              `Connection error on ${params.model}.${params.action} (attempt ${attempt}/${maxRetries}): ${error.message}`,\r\n            );\r\n\r\n            // Reconnect\r\n            try {\r\n              await this.$disconnect();\r\n              await new Promise((resolve) => setTimeout(resolve, 500 * attempt));\r\n              await this.$connect();\r\n              this.logger.log('Reconnected to database');\r\n            } catch (reconnectError) {\r\n              this.logger.error('Failed to reconnect:', reconnectError);\r\n            }\r\n          } else {\r\n            throw error;\r\n          }\r\n        }\r\n      }\r\n\r\n      throw lastError;\r\n    });\r\n  }\r\n\r\n  async onModuleInit() {\r\n    await this.connectWithRetry();\r\n\r\n    // Start keep-alive ping every 4 minutes to prevent Neon idle disconnect\r\n    this.startKeepAlive();\r\n  }\r\n\r\n  private startKeepAlive() {\r\n    // Ping every 4 minutes (240000ms) - Neon typically disconnects after 5 mins idle\r\n    const PING_INTERVAL = 4 * 60 * 1000;\r\n\r\n    this.keepAliveInterval = setInterval(async () => {\r\n      try {\r\n        await this.$queryRaw`SELECT 1`;\r\n        this.logger.debug('Database keep-alive ping successful');\r\n      } catch (error) {\r\n        this.logger.warn('Keep-alive ping failed, attempting reconnect...');\r\n        try {\r\n          await this.connectWithRetry(3);\r\n        } catch (reconnectError) {\r\n          this.logger.error('Keep-alive reconnect failed:', reconnectError);\r\n        }\r\n      }\r\n    }, PING_INTERVAL);\r\n\r\n    this.logger.log('Database keep-alive started (interval: 4 minutes)');\r\n  }\r\n\r\n  private async connectWithRetry(maxRetries = 5): Promise<void> {\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        this.logger.log(\r\n          `Connecting to database (attempt ${attempt}/${maxRetries})...`,\r\n        );\r\n        await this.$connect();\r\n\r\n        // Warm up the connection with a simple query\r\n        await this.$queryRaw`SELECT 1`;\r\n\r\n        this.logger.log('Successfully connected to database');\r\n        return;\r\n      } catch (error) {\r\n        this.logger.warn(\r\n          `Connection attempt ${attempt} failed: ${(error as Error).message}`,\r\n        );\r\n\r\n        if (attempt === maxRetries) {\r\n          this.logger.error(\r\n            'Failed to connect to database after all retries:',\r\n            error,\r\n          );\r\n          throw error;\r\n        }\r\n\r\n        // Exponential backoff: 1s, 2s, 4s, 8s, 16s\r\n        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 16000);\r\n        this.logger.log(`Retrying in ${delay / 1000}s...`);\r\n        await new Promise((resolve) => setTimeout(resolve, delay));\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reconnect if connection is lost (handles Neon cold starts)\r\n  async ensureConnection(): Promise<void> {\r\n    try {\r\n      await this.$queryRaw`SELECT 1`;\r\n    } catch {\r\n      this.logger.warn('Connection lost, reconnecting...');\r\n      await this.connectWithRetry(3);\r\n    }\r\n  }\r\n\r\n  async onModuleDestroy() {\r\n    if (this.keepAliveInterval) {\r\n      clearInterval(this.keepAliveInterval);\r\n      this.keepAliveInterval = null;\r\n      this.logger.log('Database keep-alive stopped');\r\n    }\r\n    await this.$disconnect();\r\n  }\r\n\r\n  // Helper for transactions with retry\r\n  async executeInTransaction<T>(\r\n    fn: (\r\n      prisma: Omit<\r\n        PrismaClient,\r\n        | '$connect'\r\n        | '$disconnect'\r\n        | '$on'\r\n        | '$transaction'\r\n        | '$use'\r\n        | '$extends'\r\n      >,\r\n    ) => Promise<T>,\r\n    maxRetries = 3,\r\n  ): Promise<T> {\r\n    let lastError: Error | undefined;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        return await this.$transaction(fn, {\r\n          maxWait: 30000,\r\n          timeout: 30000,\r\n        });\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        this.logger.warn(\r\n          `Transaction attempt ${attempt} failed: ${(error as Error).message}`,\r\n        );\r\n\r\n        if (attempt < maxRetries) {\r\n          await new Promise((resolve) => setTimeout(resolve, 1000 * attempt));\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError;\r\n  }\r\n}\r\n"],"names":["PrismaService","PrismaClient","onModuleInit","connectWithRetry","startKeepAlive","PING_INTERVAL","keepAliveInterval","setInterval","$queryRaw","logger","debug","error","warn","reconnectError","log","maxRetries","attempt","$connect","message","delay","Math","min","pow","Promise","resolve","setTimeout","ensureConnection","onModuleDestroy","clearInterval","$disconnect","executeInTransaction","fn","lastError","$transaction","maxWait","timeout","process","env","NODE_ENV","Logger","name","$use","params","next","isConnectionError","includes","code","model","action"],"mappings":";;;;+BASaA;;;eAAAA;;;wBAJN;wBACsB;;;;;;;;;;AAGtB,IAAA,AAAMA,gBAAN,MAAMA,sBACHC,oBAAY;IA4DpB,MAAMC,eAAe;QACnB,MAAM,IAAI,CAACC,gBAAgB;QAE3B,wEAAwE;QACxE,IAAI,CAACC,cAAc;IACrB;IAEQA,iBAAiB;QACvB,iFAAiF;QACjF,MAAMC,gBAAgB,IAAI,KAAK;QAE/B,IAAI,CAACC,iBAAiB,GAAGC,YAAY;YACnC,IAAI;gBACF,MAAM,IAAI,CAACC,SAAS,CAAC,QAAQ,CAAC;gBAC9B,IAAI,CAACC,MAAM,CAACC,KAAK,CAAC;YACpB,EAAE,OAAOC,OAAO;gBACd,IAAI,CAACF,MAAM,CAACG,IAAI,CAAC;gBACjB,IAAI;oBACF,MAAM,IAAI,CAACT,gBAAgB,CAAC;gBAC9B,EAAE,OAAOU,gBAAgB;oBACvB,IAAI,CAACJ,MAAM,CAACE,KAAK,CAAC,gCAAgCE;gBACpD;YACF;QACF,GAAGR;QAEH,IAAI,CAACI,MAAM,CAACK,GAAG,CAAC;IAClB;IAEA,MAAcX,iBAAiBY,aAAa,CAAC,EAAiB;QAC5D,IAAK,IAAIC,UAAU,GAAGA,WAAWD,YAAYC,UAAW;YACtD,IAAI;gBACF,IAAI,CAACP,MAAM,CAACK,GAAG,CACb,CAAC,gCAAgC,EAAEE,QAAQ,CAAC,EAAED,WAAW,IAAI,CAAC;gBAEhE,MAAM,IAAI,CAACE,QAAQ;gBAEnB,6CAA6C;gBAC7C,MAAM,IAAI,CAACT,SAAS,CAAC,QAAQ,CAAC;gBAE9B,IAAI,CAACC,MAAM,CAACK,GAAG,CAAC;gBAChB;YACF,EAAE,OAAOH,OAAO;gBACd,IAAI,CAACF,MAAM,CAACG,IAAI,CACd,CAAC,mBAAmB,EAAEI,QAAQ,SAAS,EAAE,AAACL,MAAgBO,OAAO,EAAE;gBAGrE,IAAIF,YAAYD,YAAY;oBAC1B,IAAI,CAACN,MAAM,CAACE,KAAK,CACf,oDACAA;oBAEF,MAAMA;gBACR;gBAEA,2CAA2C;gBAC3C,MAAMQ,QAAQC,KAAKC,GAAG,CAAC,OAAOD,KAAKE,GAAG,CAAC,GAAGN,UAAU,IAAI;gBACxD,IAAI,CAACP,MAAM,CAACK,GAAG,CAAC,CAAC,YAAY,EAAEK,QAAQ,KAAK,IAAI,CAAC;gBACjD,MAAM,IAAII,QAAQ,CAACC,UAAYC,WAAWD,SAASL;YACrD;QACF;IACF;IAEA,6DAA6D;IAC7D,MAAMO,mBAAkC;QACtC,IAAI;YACF,MAAM,IAAI,CAAClB,SAAS,CAAC,QAAQ,CAAC;QAChC,EAAE,OAAM;YACN,IAAI,CAACC,MAAM,CAACG,IAAI,CAAC;YACjB,MAAM,IAAI,CAACT,gBAAgB,CAAC;QAC9B;IACF;IAEA,MAAMwB,kBAAkB;QACtB,IAAI,IAAI,CAACrB,iBAAiB,EAAE;YAC1BsB,cAAc,IAAI,CAACtB,iBAAiB;YACpC,IAAI,CAACA,iBAAiB,GAAG;YACzB,IAAI,CAACG,MAAM,CAACK,GAAG,CAAC;QAClB;QACA,MAAM,IAAI,CAACe,WAAW;IACxB;IAEA,qCAAqC;IACrC,MAAMC,qBACJC,EAUe,EACfhB,aAAa,CAAC,EACF;QACZ,IAAIiB;QAEJ,IAAK,IAAIhB,UAAU,GAAGA,WAAWD,YAAYC,UAAW;YACtD,IAAI;gBACF,OAAO,MAAM,IAAI,CAACiB,YAAY,CAACF,IAAI;oBACjCG,SAAS;oBACTC,SAAS;gBACX;YACF,EAAE,OAAOxB,OAAO;gBACdqB,YAAYrB;gBACZ,IAAI,CAACF,MAAM,CAACG,IAAI,CACd,CAAC,oBAAoB,EAAEI,QAAQ,SAAS,EAAE,AAACL,MAAgBO,OAAO,EAAE;gBAGtE,IAAIF,UAAUD,YAAY;oBACxB,MAAM,IAAIQ,QAAQ,CAACC,UAAYC,WAAWD,SAAS,OAAOR;gBAC5D;YACF;QACF;QAEA,MAAMgB;IACR;IA5KA,aAAc;QACZ,KAAK,CAAC;YACJlB,KACEsB,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBACrB;gBAAC;gBAAS;gBAAQ;gBAAQ;aAAQ,GAClC;gBAAC;aAAQ;QACjB,SATe7B,SAAS,IAAI8B,cAAM,CAACvC,cAAcwC,IAAI,QAC/ClC,oBAA2C;QAUjD,IAAI,CAACG,MAAM,CAACK,GAAG,CAAC;QAEhB,gEAAgE;QAChE,IAAI,CAAC2B,IAAI,CAAC,OAAOC,QAAQC;YACvB,MAAM5B,aAAa;YACnB,IAAIiB;YAEJ,IAAK,IAAIhB,UAAU,GAAGA,WAAWD,YAAYC,UAAW;gBACtD,IAAI;oBACF,OAAO,MAAM2B,KAAKD;gBACpB,EAAE,OAAO/B,OAAY;oBACnBqB,YAAYrB;oBAEZ,mCAAmC;oBACnC,MAAMiC,oBACJjC,MAAMO,OAAO,EAAE2B,SAAS,iBACxBlC,MAAMO,OAAO,EAAE2B,SAAS,aACxBlC,MAAMO,OAAO,EAAE2B,SAAS,mBACxBlC,MAAMO,OAAO,EAAE2B,SAAS,gBACxBlC,MAAMmC,IAAI,KAAK,WACfnC,MAAMmC,IAAI,KAAK,WACfnC,MAAMmC,IAAI,KAAK;oBAEjB,IAAIF,qBAAqB5B,UAAUD,YAAY;wBAC7C,IAAI,CAACN,MAAM,CAACG,IAAI,CACd,CAAC,oBAAoB,EAAE8B,OAAOK,KAAK,CAAC,CAAC,EAAEL,OAAOM,MAAM,CAAC,UAAU,EAAEhC,QAAQ,CAAC,EAAED,WAAW,GAAG,EAAEJ,MAAMO,OAAO,EAAE;wBAG7G,YAAY;wBACZ,IAAI;4BACF,MAAM,IAAI,CAACW,WAAW;4BACtB,MAAM,IAAIN,QAAQ,CAACC,UAAYC,WAAWD,SAAS,MAAMR;4BACzD,MAAM,IAAI,CAACC,QAAQ;4BACnB,IAAI,CAACR,MAAM,CAACK,GAAG,CAAC;wBAClB,EAAE,OAAOD,gBAAgB;4BACvB,IAAI,CAACJ,MAAM,CAACE,KAAK,CAAC,wBAAwBE;wBAC5C;oBACF,OAAO;wBACL,MAAMF;oBACR;gBACF;YACF;YAEA,MAAMqB;QACR;IACF;AAwHF"}